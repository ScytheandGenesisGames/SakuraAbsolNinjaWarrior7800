------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}	; constant
    273  28000 ????			    .Palette   SET	{2}	; constant/variable MACARG2CONST
    274  28000 ????			    .SpriteX   SET	{3}	; constant/variable MACARG3CONST
    275  28000 ????			    .SpriteY   SET	{4}	; constant/variable MACARG4CONST
    276  28000 ????			    .ByteOffset SET	{5}	; constant/variable MACARG5CONST
    277  28000 ????
    278  28000 ????				       if	MACARG4CONST = 0
    279  28000 ????				       lda	.SpriteY
    280  28000 ????				       else
    281  28000 ????				       lda	#.SpriteY
    282  28000 ????				       endif
    283  28000 ????
    284  28000 ????				       lsr
    285  28000 ????				       lsr
    286  28000 ????				       asr	#%11111110	; ensure carry is clear
    287  28000 ????				       if	WZONEHEIGHT = 16
    288  28000 ????				       asr	#%11111110	; ensure carry is clear
    289  28000 ????				       endif
    290  28000 ????
    291  28000 ????				       tax
    292  28000 ????
    293  28000 ????				       cpx	#WZONECOUNT
    294  28000 ????				       bcs	.PLOTSPRITEnext
    295  28000 ????						; carry is clear
    296  28000 ????
    297  28000 ????				       ifconst	VSCROLL
    298  28000 ????				       ldy	Xx3,x
    299  28000 ????				       lda	DLLMEM+11,y
    300  28000 ????				       else		; !VSCROLL
    301  28000 ????				       lda	DLPOINTL,x	; Get pointer to DL that this sprite starts in
    302  28000 ????				       endif
    303  28000 ????				       ifconst	DOUBLEBUFFER
    304  28000 ????				       adc	doublebufferdloffset
    305  28000 ????				       endif		; DOUBLEBUFFER
    306  28000 ????				       sta	dlpnt
    307  28000 ????				       ifconst	VSCROLL
    308  28000 ????				       lda	DLLMEM+10,y
    309  28000 ????				       else		; !VSCROLL
    310  28000 ????				       lda	DLPOINTH,x
    311  28000 ????				       endif		; !VSCROLL
    312  28000 ????				       ifconst	DOUBLEBUFFER
    313  28000 ????				       adc	#0
    314  28000 ????				       endif		; DOUBLEBUFFER
    315  28000 ????				       sta	dlpnt+1
    316  28000 ????
    317  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    318  28000 ????
    319  28000 ????				       ifconst	.ByteOffset
    320  28000 ????
    321  28000 ????				       if	MACARG5CONST = 1
    322  28000 ????				       lda	#.ByteOffset
    323  28000 ????				       else
    324  28000 ????				       lda	.ByteOffset
    325  28000 ????				       endif
    326  28000 ????				       ifconst	DOUBLEBUFFER
    327  28000 ????				       if	{1}_width = 1
    328  28000 ????				       clc
    329  28000 ????				       endif
    330  28000 ????				       endif
    331  28000 ????				       if	{1}_width = 2
    332  28000 ????				       asl
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 3
    335  28000 ????				       asl
    336  28000 ????				       if	MACARG5CONST = 1
    337  28000 ????				       adc	#.ByteOffset
    338  28000 ????				       else
    339  28000 ????				       adc	.ByteOffset
    340  28000 ????				       endif
    341  28000 ????				       endif
    342  28000 ????				       if	{1}_width = 4
    343  28000 ????				       asl
    344  28000 ????				       asl
    345  28000 ????				       endif
    346  28000 ????				       if	{1}_width = 5
    347  28000 ????				       asl
    348  28000 ????				       asl
    349  28000 ????				       if	MACARG5CONST = 1
    350  28000 ????				       adc	#.ByteOffset
    351  28000 ????				       else
    352  28000 ????				       adc	.ByteOffset
    353  28000 ????				       endif
    354  28000 ????				       endif
    355  28000 ????				       if	{1}_width = 6
    356  28000 ????				       asl
    357  28000 ????				       if	MACARG5CONST = 1
    358  28000 ????				       adc	#.ByteOffset
    359  28000 ????				       else
    360  28000 ????				       adc	.ByteOffset
    361  28000 ????				       endif
    362  28000 ????				       asl
    363  28000 ????				       endif
    364  28000 ????				       if	{1}_width = 7
    365  28000 ????				       asl
    366  28000 ????				       if	MACARG5CONST = 1
    367  28000 ????				       adc	#.ByteOffset
    368  28000 ????				       else
    369  28000 ????				       adc	.ByteOffset
    370  28000 ????				       endif
    371  28000 ????				       asl
    372  28000 ????				       if	MACARG5CONST = 1
    373  28000 ????				       adc	#.ByteOffset
    374  28000 ????				       else
    375  28000 ????				       adc	.ByteOffset
    376  28000 ????				       endif
    377  28000 ????				       endif
    378  28000 ????				       if	{1}_width = 8
    379  28000 ????				       asl
    380  28000 ????				       asl
    381  28000 ????				       asl
    382  28000 ????				       endif
    383  28000 ????				       if	{1}_width = 9
    384  28000 ????				       asl
    385  28000 ????				       asl
    386  28000 ????				       asl
    387  28000 ????				       if	MACARG5CONST = 1
    388  28000 ????				       adc	#.ByteOffset
    389  28000 ????				       else
    390  28000 ????				       adc	.ByteOffset
    391  28000 ????				       endif
    392  28000 ????				       endif
    393  28000 ????				       if	{1}_width = 10
    394  28000 ????				       asl
    395  28000 ????				       asl
    396  28000 ????				       if	MACARG5CONST = 1
    397  28000 ????				       adc	#.ByteOffset
    398  28000 ????				       else
    399  28000 ????				       adc	.ByteOffset
    400  28000 ????				       endif
    401  28000 ????				       asl
    402  28000 ????				       endif
    403  28000 ????				       if	{1}_width = 11
    404  28000 ????				       asl
    405  28000 ????				       asl
    406  28000 ????				       if	MACARG5CONST = 1
    407  28000 ????				       adc	#.ByteOffset
    408  28000 ????				       else
    409  28000 ????				       adc	.ByteOffset
    410  28000 ????				       endif
    411  28000 ????				       asl
    412  28000 ????				       if	MACARG5CONST = 1
    413  28000 ????				       adc	#.ByteOffset
    414  28000 ????				       else
    415  28000 ????				       adc	.ByteOffset
    416  28000 ????				       endif
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 12
    419  28000 ????				       asl
    420  28000 ????				       if	MACARG5CONST = 1
    421  28000 ????				       adc	#.ByteOffset
    422  28000 ????				       else
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       asl
    426  28000 ????				       asl
    427  28000 ????				       endif
    428  28000 ????				       if	{1}_width = 13
    429  28000 ????				       asl
    430  28000 ????				       if	MACARG5CONST = 1
    431  28000 ????				       adc	#.ByteOffset
    432  28000 ????				       else
    433  28000 ????				       adc	.ByteOffset
    434  28000 ????				       endif
    435  28000 ????				       asl
    436  28000 ????				       asl
    437  28000 ????				       if	MACARG5CONST = 1
    438  28000 ????				       adc	#.ByteOffset
    439  28000 ????				       else
    440  28000 ????				       adc	.ByteOffset
    441  28000 ????				       endif
    442  28000 ????
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 14
    445  28000 ????				       asl
    446  28000 ????				       if	MACARG5CONST = 1
    447  28000 ????				       adc	#.ByteOffset
    448  28000 ????				       else
    449  28000 ????				       adc	.ByteOffset
    450  28000 ????				       endif
    451  28000 ????				       asl
    452  28000 ????				       if	MACARG5CONST = 1
    453  28000 ????				       adc	#.ByteOffset
    454  28000 ????				       else
    455  28000 ????				       adc	.ByteOffset
    456  28000 ????				       endif
    457  28000 ????				       asl
    458  28000 ????				       endif
    459  28000 ????				       if	{1}_width = 15
    460  28000 ????				       asl
    461  28000 ????				       if	MACARG5CONST = 1
    462  28000 ????				       adc	#.ByteOffset
    463  28000 ????				       else
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       endif
    466  28000 ????				       asl
    467  28000 ????				       if	MACARG5CONST = 1
    468  28000 ????				       adc	#.ByteOffset
    469  28000 ????				       else
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       endif
    472  28000 ????				       asl
    473  28000 ????				       if	MACARG5CONST = 1
    474  28000 ????				       adc	#.ByteOffset
    475  28000 ????				       else
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       endif
    478  28000 ????				       endif
    479  28000 ????				       if	{1}_width = 16
    480  28000 ????				       asl
    481  28000 ????				       asl
    482  28000 ????				       asl
    483  28000 ????				       asl
    484  28000 ????				       endif
    485  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    486  28000 ????				       else
    487  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
    488  28000 ????				       endif		; .ByteOffset
    489  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    490  28000 ????
    491  28000 ????				       iny
    492  28000 ????
    493  28000 ????				       lda	#({1}_mode | %01000000)
    494  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    495  28000 ????
    496  28000 ????				       iny
    497  28000 ????
    498  28000 ????				       if	MACARG4CONST = 0
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       else
    501  28000 ????				       lda	#.SpriteY
    502  28000 ????				       endif
    503  28000 ????				       and	#(WZONEHEIGHT - 1)
    504  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    505  28000 ????				       ora	#>.GFXLabel
    506  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    507  28000 ????
    508  28000 ????				       iny
    509  28000 ????
    510  28000 ????				       if	MACARG2CONST = 1
    511  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    512  28000 ????				       else
    513  28000 ????				       lda	#({1}_width_twoscompliment)
    514  28000 ????				       ora	.Palette
    515  28000 ????				       endif
    516  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    517  28000 ????
    518  28000 ????				       iny
    519  28000 ????
    520  28000 ????				       if	MACARG3CONST = 1
    521  28000 ????				       lda	#.SpriteX
    522  28000 ????				       else
    523  28000 ????				       lda	.SpriteX
    524  28000 ????				       endif
    525  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    526  28000 ????
    527  28000 ????				       iny
    528  28000 ????				       sty	dlend,x
    529  28000 ????
    530  28000 ????				       ifconst	ALWAYSTERMINATE
    531  28000 ????				       iny
    532  28000 ????				       lda	#0
    533  28000 ????				       sta	(dlpnt),y
    534  28000 ????				       endif
    535  28000 ????
    536  28000 ????				       bcc	.PLOTSPRITEend
    537  28000 ????
    538  28000 ????			    .PLOTSPRITEnext
    539  28000 ????				       inx		; next zone
    540  28000 ????
    541  28000 ????				       cpx	#WZONECOUNT
    542  28000 ????				       bcs	.PLOTSPRITEend
    543  28000 ????						; carry is clear
    544  28000 ????
    545  28000 ????				       ifconst	VSCROLL
    546  28000 ????				       ldy	Xx3,x
    547  28000 ????				       lda	DLLMEM+11,y
    548  28000 ????				       else		; !VSCROLL
    549  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    550  28000 ????				       endif		; !VSCROLL
    551  28000 ????				       ifconst	DOUBLEBUFFER
    552  28000 ????				       adc	doublebufferdloffset
    553  28000 ????				       endif		; DOUBLEBUFFER
    554  28000 ????				       sta	dlpnt
    555  28000 ????				       ifconst	VSCROLL
    556  28000 ????				       lda	DLLMEM+10,y
    557  28000 ????				       else		; !VSCROLL
    558  28000 ????				       lda	DLPOINTH,x
    559  28000 ????				       endif		; !VSCROLL
    560  28000 ????				       ifconst	DOUBLEBUFFER
    561  28000 ????				       adc	#0
    562  28000 ????				       endif		; DOUBLEBUFFER
    563  28000 ????				       sta	dlpnt+1
    564  28000 ????
    565  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    566  28000 ????
    567  28000 ????				       ifconst	.ByteOffset
    568  28000 ????
    569  28000 ????				       if	MACARG5CONST = 1
    570  28000 ????				       lda	#.ByteOffset
    571  28000 ????				       else
    572  28000 ????				       lda	.ByteOffset
    573  28000 ????				       endif
    574  28000 ????				       if	{1}_width = 1
    575  28000 ????				       clc
    576  28000 ????				       endif
    577  28000 ????				       if	{1}_width = 2
    578  28000 ????				       asl		; carry clear
    579  28000 ????				       endif
    580  28000 ????				       if	{1}_width = 3
    581  28000 ????				       asl		; carry clear
    582  28000 ????				       if	MACARG5CONST = 1
    583  28000 ????				       adc	#.ByteOffset
    584  28000 ????				       else
    585  28000 ????				       adc	.ByteOffset
    586  28000 ????				       endif
    587  28000 ????				       endif
    588  28000 ????				       if	{1}_width = 4
    589  28000 ????				       asl		; carry clear
    590  28000 ????				       asl
    591  28000 ????				       endif
    592  28000 ????				       if	{1}_width = 5
    593  28000 ????				       asl		; carry clear
    594  28000 ????				       asl
    595  28000 ????				       if	MACARG5CONST = 1
    596  28000 ????				       adc	#.ByteOffset
    597  28000 ????				       else
    598  28000 ????				       adc	.ByteOffset
    599  28000 ????				       endif
    600  28000 ????				       endif
    601  28000 ????				       if	{1}_width = 6
    602  28000 ????				       asl		; carry clear
    603  28000 ????				       if	MACARG5CONST = 1
    604  28000 ????				       adc	#.ByteOffset
    605  28000 ????				       else
    606  28000 ????				       adc	.ByteOffset
    607  28000 ????				       endif
    608  28000 ????				       asl
    609  28000 ????				       endif
    610  28000 ????				       if	{1}_width = 7
    611  28000 ????				       asl		; carry clear
    612  28000 ????				       if	MACARG5CONST = 1
    613  28000 ????				       adc	#.ByteOffset
    614  28000 ????				       else
    615  28000 ????				       adc	.ByteOffset
    616  28000 ????				       endif
    617  28000 ????				       asl
    618  28000 ????				       endif
    619  28000 ????				       if	{1}_width = 8
    620  28000 ????				       asl		; carry clear
    621  28000 ????				       asl
    622  28000 ????				       asl
    623  28000 ????				       endif
    624  28000 ????				       if	{1}_width = 9
    625  28000 ????				       asl		; carry clear
    626  28000 ????				       asl
    627  28000 ????				       asl
    628  28000 ????				       if	MACARG5CONST = 1
    629  28000 ????				       adc	#.ByteOffset
    630  28000 ????				       else
    631  28000 ????				       adc	.ByteOffset
    632  28000 ????				       endif
    633  28000 ????				       endif
    634  28000 ????				       if	{1}_width = 10
    635  28000 ????				       asl		; carry clear
    636  28000 ????				       asl
    637  28000 ????				       if	MACARG5CONST = 1
    638  28000 ????				       adc	#.ByteOffset
    639  28000 ????				       else
    640  28000 ????				       adc	.ByteOffset
    641  28000 ????				       endif
    642  28000 ????				       asl
    643  28000 ????				       endif
    644  28000 ????				       if	{1}_width = 11
    645  28000 ????				       asl		; carry clear
    646  28000 ????				       asl
    647  28000 ????				       if	MACARG5CONST = 1
    648  28000 ????				       adc	#.ByteOffset
    649  28000 ????				       else
    650  28000 ????				       adc	.ByteOffset
    651  28000 ????				       endif
    652  28000 ????				       asl
    653  28000 ????				       if	MACARG5CONST = 1
    654  28000 ????				       adc	#.ByteOffset
    655  28000 ????				       else
    656  28000 ????				       adc	.ByteOffset
    657  28000 ????				       endif
    658  28000 ????				       endif
    659  28000 ????				       if	{1}_width = 12
    660  28000 ????				       asl		; carry clear
    661  28000 ????				       if	MACARG5CONST = 1
    662  28000 ????				       adc	#.ByteOffset
    663  28000 ????				       else
    664  28000 ????				       adc	.ByteOffset
    665  28000 ????				       endif
    666  28000 ????				       asl
    667  28000 ????				       asl
    668  28000 ????				       endif
    669  28000 ????				       if	{1}_width = 13
    670  28000 ????				       asl		; carry clear
    671  28000 ????				       if	MACARG5CONST = 1
    672  28000 ????				       adc	#.ByteOffset
    673  28000 ????				       else
    674  28000 ????				       adc	.ByteOffset
    675  28000 ????				       endif
    676  28000 ????				       asl
    677  28000 ????				       asl
    678  28000 ????				       if	MACARG5CONST = 1
    679  28000 ????				       adc	#.ByteOffset
    680  28000 ????				       else
    681  28000 ????				       adc	.ByteOffset
    682  28000 ????				       endif
    683  28000 ????				       endif
    684  28000 ????				       if	{1}_width = 14
    685  28000 ????				       asl		; carry clear
    686  28000 ????				       if	MACARG5CONST = 1
    687  28000 ????				       adc	#.ByteOffset
    688  28000 ????				       else
    689  28000 ????				       adc	.ByteOffset
    690  28000 ????				       endif
    691  28000 ????				       asl
    692  28000 ????				       if	MACARG5CONST = 1
    693  28000 ????				       adc	#.ByteOffset
    694  28000 ????				       else
    695  28000 ????				       adc	.ByteOffset
    696  28000 ????				       endif
    697  28000 ????				       asl
    698  28000 ????				       endif
    699  28000 ????				       if	{1}_width = 15
    700  28000 ????				       asl
    701  28000 ????				       if	MACARG5CONST = 1
    702  28000 ????				       adc	#.ByteOffset
    703  28000 ????				       else
    704  28000 ????				       adc	.ByteOffset
    705  28000 ????				       endif
    706  28000 ????				       asl
    707  28000 ????				       if	MACARG5CONST = 1
    708  28000 ????				       adc	#.ByteOffset
    709  28000 ????				       else
    710  28000 ????				       adc	.ByteOffset
    711  28000 ????				       endif
    712  28000 ????				       asl
    713  28000 ????				       if	MACARG5CONST = 1
    714  28000 ????				       adc	#.ByteOffset
    715  28000 ????				       else
    716  28000 ????				       adc	.ByteOffset
    717  28000 ????				       endif
    718  28000 ????				       endif
    719  28000 ????				       if	{1}_width = 16
    720  28000 ????				       asl
    721  28000 ????				       asl
    722  28000 ????				       asl
    723  28000 ????				       asl
    724  28000 ????				       endif
    725  28000 ????				       adc	#<.GFXLabel
    726  28000 ????				       else
    727  28000 ????				       lda	#<.GFXLabel
    728  28000 ????				       endif		; .ByteOffset
    729  28000 ????
    730  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    731  28000 ????
    732  28000 ????				       iny
    733  28000 ????
    734  28000 ????				       lda	#({1}_mode | %01000000)
    735  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    736  28000 ????
    737  28000 ????				       iny
    738  28000 ????
    739  28000 ????				       if	MACARG4CONST = 0
    740  28000 ????				       lda	.SpriteY
    741  28000 ????				       else
    742  28000 ????				       lda	#.SpriteY
    743  28000 ????				       endif
    744  28000 ????				       and	#(WZONEHEIGHT - 1)
    745  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    746  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    747  28000 ????
    748  28000 ????				       iny
    749  28000 ????
    750  28000 ????				       if	MACARG2CONST = 1
    751  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    752  28000 ????				       else
    753  28000 ????				       lda	#({1}_width_twoscompliment)
    754  28000 ????				       ora	.Palette
    755  28000 ????				       endif
    756  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    757  28000 ????
    758  28000 ????				       iny
    759  28000 ????
    760  28000 ????				       if	MACARG3CONST = 1
    761  28000 ????				       lda	#.SpriteX
    762  28000 ????				       else
    763  28000 ????				       lda	.SpriteX
    764  28000 ????				       endif
    765  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    766  28000 ????
    767  28000 ????				       iny
    768  28000 ????				       sty	dlend,x
    769  28000 ????
    770  28000 ????				       ifconst	ALWAYSTERMINATE
    771  28000 ????				       iny
    772  28000 ????				       lda	#0
    773  28000 ????				       sta	(dlpnt),y
    774  28000 ????				       endif
    775  28000 ????
    776  28000 ????			    .PLOTSPRITEend
    777  28000 ????				       ENDM
    778  28000 ????
    779  28000 ????				       MAC	plotsprite4
    780  28000 ????
    781  28000 ????						; A macro version of plotsprite. (with 4 byte objects)
    782  28000 ????						; This trades off rom space for speed.
    783  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    784  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    785  28000 ????
    786  28000 ????			    .GFXLabel  SET	{1}
    787  28000 ????			    .Palette   SET	{2}	; constant
    788  28000 ????			    .SpriteX   SET	{3}	; variable
    789  28000 ????			    .SpriteY   SET	{4}	; variable
    790  28000 ????			    .ByteOffset SET	{5}	; variable 
    791  28000 ????
    792  28000 ????				       if	MACARG4CONST = 0
    793  28000 ????				       lda	.SpriteY
    794  28000 ????				       else
    795  28000 ????				       lda	#.SpriteY
    796  28000 ????				       endif
    797  28000 ????				       lsr
    798  28000 ????				       lsr
    799  28000 ????				       asr	#%11111110	; ensure carry is clear
    800  28000 ????				       if	WZONEHEIGHT = 16
    801  28000 ????				       asr	#%11111110	; ensure carry is clear
    802  28000 ????				       endif
    803  28000 ????
    804  28000 ????				       tax
    805  28000 ????
    806  28000 ????				       cpx	#WZONECOUNT
    807  28000 ????				       bcs	.PLOTSPRITEnext
    808  28000 ????						; carry is clear
    809  28000 ????				       ifconst	VSCROLL
    810  28000 ????				       ldy	Xx3,x
    811  28000 ????				       lda	DLLMEM+11,y
    812  28000 ????				       else		; !VSCROLL
    813  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    814  28000 ????				       endif		; !VSCROLL
    815  28000 ????				       ifconst	DOUBLEBUFFER
    816  28000 ????				       adc	doublebufferdloffset
    817  28000 ????				       endif		; DOUBLEBUFFER
    818  28000 ????				       sta	dlpnt
    819  28000 ????				       ifconst	VSCROLL
    820  28000 ????				       lda	DLLMEM+10,y
    821  28000 ????				       else		; !VSCROLL
    822  28000 ????				       lda	DLPOINTH,x
    823  28000 ????				       endif		; !VSCROLL
    824  28000 ????				       ifconst	DOUBLEBUFFER
    825  28000 ????				       adc	#0
    826  28000 ????				       endif		; DOUBLEBUFFER
    827  28000 ????				       sta	dlpnt+1
    828  28000 ????
    829  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    830  28000 ????
    831  28000 ????				       ifconst	.ByteOffset
    832  28000 ????
    833  28000 ????				       if	MACARG5CONST = 1
    834  28000 ????				       lda	#.ByteOffset
    835  28000 ????				       else
    836  28000 ????				       lda	.ByteOffset
    837  28000 ????				       endif
    838  28000 ????				       ifconst	DOUBLEBUFFER
    839  28000 ????				       if	{1}_width = 1
    840  28000 ????				       clc
    841  28000 ????				       endif
    842  28000 ????				       endif
    843  28000 ????				       if	{1}_width = 2
    844  28000 ????				       asl
    845  28000 ????				       endif
    846  28000 ????				       if	{1}_width = 3
    847  28000 ????				       asl
    848  28000 ????				       if	MACARG5CONST = 1
    849  28000 ????				       adc	#.ByteOffset
    850  28000 ????				       else
    851  28000 ????				       adc	.ByteOffset
    852  28000 ????				       endif
    853  28000 ????				       endif
    854  28000 ????				       if	{1}_width = 4
    855  28000 ????				       asl
    856  28000 ????				       asl
    857  28000 ????				       endif
    858  28000 ????				       if	{1}_width = 5
    859  28000 ????				       asl
    860  28000 ????				       asl
    861  28000 ????				       if	MACARG5CONST = 1
    862  28000 ????				       adc	#.ByteOffset
    863  28000 ????				       else
    864  28000 ????				       adc	.ByteOffset
    865  28000 ????				       endif
    866  28000 ????				       endif
    867  28000 ????				       if	{1}_width = 6
    868  28000 ????				       asl
    869  28000 ????				       if	MACARG5CONST = 1
    870  28000 ????				       adc	#.ByteOffset
    871  28000 ????				       else
    872  28000 ????				       adc	.ByteOffset
    873  28000 ????				       endif
    874  28000 ????
    875  28000 ????				       asl
    876  28000 ????				       endif
    877  28000 ????				       if	{1}_width = 7
    878  28000 ????				       asl
    879  28000 ????				       if	MACARG5CONST = 1
    880  28000 ????				       adc	#.ByteOffset
    881  28000 ????				       else
    882  28000 ????				       adc	.ByteOffset
    883  28000 ????				       endif
    884  28000 ????				       asl
    885  28000 ????				       if	MACARG5CONST = 1
    886  28000 ????				       adc	#.ByteOffset
    887  28000 ????				       else
    888  28000 ????				       adc	.ByteOffset
    889  28000 ????				       endif
    890  28000 ????				       endif
    891  28000 ????				       if	{1}_width = 8
    892  28000 ????				       asl
    893  28000 ????				       asl
    894  28000 ????				       asl
    895  28000 ????				       endif
    896  28000 ????				       if	{1}_width = 9
    897  28000 ????				       asl
    898  28000 ????				       asl
    899  28000 ????				       asl
    900  28000 ????				       if	MACARG5CONST = 1
    901  28000 ????				       adc	#.ByteOffset
    902  28000 ????				       else
    903  28000 ????				       adc	.ByteOffset
    904  28000 ????				       endif
    905  28000 ????				       endif
    906  28000 ????				       if	{1}_width = 10
    907  28000 ????				       asl
    908  28000 ????				       asl
    909  28000 ????				       if	MACARG5CONST = 1
    910  28000 ????				       adc	#.ByteOffset
    911  28000 ????				       else
    912  28000 ????				       adc	.ByteOffset
    913  28000 ????				       endif
    914  28000 ????				       asl
    915  28000 ????				       endif
    916  28000 ????				       if	{1}_width = 11
    917  28000 ????				       asl
    918  28000 ????				       asl
    919  28000 ????				       if	MACARG5CONST = 1
    920  28000 ????				       adc	#.ByteOffset
    921  28000 ????				       else
    922  28000 ????				       adc	.ByteOffset
    923  28000 ????				       endif
    924  28000 ????				       asl
    925  28000 ????				       if	MACARG5CONST = 1
    926  28000 ????				       adc	#.ByteOffset
    927  28000 ????				       else
    928  28000 ????				       adc	.ByteOffset
    929  28000 ????				       endif
    930  28000 ????				       endif
    931  28000 ????				       if	{1}_width = 12
    932  28000 ????				       asl
    933  28000 ????				       if	MACARG5CONST = 1
    934  28000 ????				       adc	#.ByteOffset
    935  28000 ????				       else
    936  28000 ????				       adc	.ByteOffset
    937  28000 ????				       endif
    938  28000 ????				       asl
    939  28000 ????				       asl
    940  28000 ????				       endif
    941  28000 ????				       if	{1}_width = 13
    942  28000 ????				       asl
    943  28000 ????				       if	MACARG5CONST = 1
    944  28000 ????				       adc	#.ByteOffset
    945  28000 ????				       else
    946  28000 ????				       adc	.ByteOffset
    947  28000 ????				       endif
    948  28000 ????				       asl
    949  28000 ????				       asl
    950  28000 ????				       if	MACARG5CONST = 1
    951  28000 ????				       adc	#.ByteOffset
    952  28000 ????				       else
    953  28000 ????				       adc	.ByteOffset
    954  28000 ????				       endif
    955  28000 ????				       endif
    956  28000 ????				       if	{1}_width = 14
    957  28000 ????				       asl
    958  28000 ????				       if	MACARG5CONST = 1
    959  28000 ????				       adc	#.ByteOffset
    960  28000 ????				       else
    961  28000 ????				       adc	.ByteOffset
    962  28000 ????				       endif
    963  28000 ????				       asl
    964  28000 ????				       if	MACARG5CONST = 1
    965  28000 ????				       adc	#.ByteOffset
    966  28000 ????				       else
    967  28000 ????				       adc	.ByteOffset
    968  28000 ????				       endif
    969  28000 ????				       asl
    970  28000 ????				       endif
    971  28000 ????				       if	{1}_width = 15
    972  28000 ????				       asl
    973  28000 ????				       if	MACARG5CONST = 1
    974  28000 ????				       adc	#.ByteOffset
    975  28000 ????				       else
    976  28000 ????				       adc	.ByteOffset
    977  28000 ????				       endif
    978  28000 ????				       asl
    979  28000 ????				       if	MACARG5CONST = 1
    980  28000 ????				       adc	#.ByteOffset
    981  28000 ????				       else
    982  28000 ????				       adc	.ByteOffset
    983  28000 ????				       endif
    984  28000 ????				       asl
    985  28000 ????				       if	MACARG5CONST = 1
    986  28000 ????				       adc	#.ByteOffset
    987  28000 ????				       else
    988  28000 ????				       adc	.ByteOffset
    989  28000 ????				       endif
    990  28000 ????				       endif
    991  28000 ????				       if	{1}_width = 16
    992  28000 ????				       asl
    993  28000 ????				       asl
    994  28000 ????				       asl
    995  28000 ????				       asl
    996  28000 ????				       endif
    997  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    998  28000 ????				       else
    999  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
   1000  28000 ????				       endif		; .ByteOffset
   1001  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1002  28000 ????
   1003  28000 ????				       iny
   1004  28000 ????
   1005  28000 ????				       if	MACARG2CONST = 1
   1006  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1007  28000 ????				       else
   1008  28000 ????				       lda	#({1}_width_twoscompliment)
   1009  28000 ????				       ora	.Palette
   1010  28000 ????				       endif
   1011  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1012  28000 ????
   1013  28000 ????				       iny
   1014  28000 ????				       if	MACARG4CONST = 0
   1015  28000 ????				       lda	.SpriteY
   1016  28000 ????				       else
   1017  28000 ????				       lda	#.SpriteY
   1018  28000 ????				       endif
   1019  28000 ????				       and	#(WZONEHEIGHT - 1)
   1020  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
   1021  28000 ????				       ora	#>.GFXLabel
   1022  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1023  28000 ????
   1024  28000 ????				       iny
   1025  28000 ????				       if	MACARG3CONST = 1
   1026  28000 ????				       lda	#.SpriteX
   1027  28000 ????				       else
   1028  28000 ????				       lda	.SpriteX
   1029  28000 ????				       endif
   1030  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1031  28000 ????
   1032  28000 ????				       iny
   1033  28000 ????				       sty	dlend,x
   1034  28000 ????
   1035  28000 ????				       ifconst	ALWAYSTERMINATE
   1036  28000 ????				       iny
   1037  28000 ????				       lda	#0
   1038  28000 ????				       sta	(dlpnt),y
   1039  28000 ????				       endif
   1040  28000 ????
   1041  28000 ????				       bcc	.PLOTSPRITEend
   1042  28000 ????
   1043  28000 ????			    .PLOTSPRITEnext
   1044  28000 ????				       inx		; next zone
   1045  28000 ????
   1046  28000 ????				       cpx	#WZONECOUNT
   1047  28000 ????				       bcs	.PLOTSPRITEend
   1048  28000 ????						; carry is clear
   1049  28000 ????				       ifconst	VSCROLL
   1050  28000 ????				       ldy	Xx3,x
   1051  28000 ????				       lda	DLLMEM+11,y
   1052  28000 ????				       else		; !VSCROLL
   1053  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   1054  28000 ????				       endif		; !VSCROLL
   1055  28000 ????				       ifconst	DOUBLEBUFFER
   1056  28000 ????				       adc	doublebufferdloffset
   1057  28000 ????				       endif		; DOUBLEBUFFER
   1058  28000 ????				       sta	dlpnt
   1059  28000 ????				       ifconst	VSCROLL
   1060  28000 ????				       lda	DLLMEM+10,y
   1061  28000 ????				       else		; !VSCROLL
   1062  28000 ????				       lda	DLPOINTH,x
   1063  28000 ????				       endif		; !VSCROLL
   1064  28000 ????				       ifconst	DOUBLEBUFFER
   1065  28000 ????				       adc	#0
   1066  28000 ????				       endif		; DOUBLEBUFFER
   1067  28000 ????				       sta	dlpnt+1
   1068  28000 ????
   1069  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
   1070  28000 ????
   1071  28000 ????				       ifconst	.ByteOffset
   1072  28000 ????
   1073  28000 ????				       if	MACARG5CONST = 1
   1074  28000 ????				       lda	#.ByteOffset
   1075  28000 ????				       else
   1076  28000 ????				       lda	.ByteOffset
   1077  28000 ????				       endif
   1078  28000 ????				       if	{1}_width = 1
   1079  28000 ????				       clc
   1080  28000 ????				       endif
   1081  28000 ????				       if	{1}_width = 2
   1082  28000 ????				       asl		; carry clear
   1083  28000 ????				       endif
   1084  28000 ????				       if	{1}_width = 3
   1085  28000 ????				       asl		; carry clear
   1086  28000 ????				       if	MACARG5CONST = 1
   1087  28000 ????				       adc	#.ByteOffset
   1088  28000 ????				       else
   1089  28000 ????				       adc	.ByteOffset
   1090  28000 ????				       endif
   1091  28000 ????				       endif
   1092  28000 ????				       if	{1}_width = 4
   1093  28000 ????				       asl		; carry clear
   1094  28000 ????				       asl
   1095  28000 ????				       endif
   1096  28000 ????				       if	{1}_width = 5
   1097  28000 ????				       asl		; carry clear
   1098  28000 ????				       asl
   1099  28000 ????				       if	MACARG5CONST = 1
   1100  28000 ????				       adc	#.ByteOffset
   1101  28000 ????				       else
   1102  28000 ????				       adc	.ByteOffset
   1103  28000 ????				       endif
   1104  28000 ????				       endif
   1105  28000 ????				       if	{1}_width = 6
   1106  28000 ????				       asl		; carry clear
   1107  28000 ????				       if	MACARG5CONST = 1
   1108  28000 ????				       adc	#.ByteOffset
   1109  28000 ????				       else
   1110  28000 ????				       adc	.ByteOffset
   1111  28000 ????				       endif
   1112  28000 ????
   1113  28000 ????				       asl
   1114  28000 ????				       endif
   1115  28000 ????				       if	{1}_width = 7
   1116  28000 ????				       asl		; carry clear
   1117  28000 ????				       if	MACARG5CONST = 1
   1118  28000 ????				       adc	#.ByteOffset
   1119  28000 ????				       else
   1120  28000 ????				       adc	.ByteOffset
   1121  28000 ????				       endif
   1122  28000 ????				       asl
   1123  28000 ????				       endif
   1124  28000 ????				       if	{1}_width = 8
   1125  28000 ????				       asl		; carry clear
   1126  28000 ????				       asl
   1127  28000 ????				       asl
   1128  28000 ????				       endif
   1129  28000 ????				       if	{1}_width = 9
   1130  28000 ????				       asl		; carry clear
   1131  28000 ????				       asl
   1132  28000 ????				       asl
   1133  28000 ????				       if	MACARG5CONST = 1
   1134  28000 ????				       adc	#.ByteOffset
   1135  28000 ????				       else
   1136  28000 ????				       adc	.ByteOffset
   1137  28000 ????				       endif
   1138  28000 ????				       endif
   1139  28000 ????				       if	{1}_width = 10
   1140  28000 ????				       asl		; carry clear
   1141  28000 ????				       asl
   1142  28000 ????				       if	MACARG5CONST = 1
   1143  28000 ????				       adc	#.ByteOffset
   1144  28000 ????				       else
   1145  28000 ????				       adc	.ByteOffset
   1146  28000 ????				       endif
   1147  28000 ????				       asl
   1148  28000 ????				       endif
   1149  28000 ????				       if	{1}_width = 11
   1150  28000 ????				       asl		; carry clear
   1151  28000 ????				       asl
   1152  28000 ????				       if	MACARG5CONST = 1
   1153  28000 ????				       adc	#.ByteOffset
   1154  28000 ????				       else
   1155  28000 ????				       adc	.ByteOffset
   1156  28000 ????				       endif
   1157  28000 ????				       asl
   1158  28000 ????				       if	MACARG5CONST = 1
   1159  28000 ????				       adc	#.ByteOffset
   1160  28000 ????				       else
   1161  28000 ????				       adc	.ByteOffset
   1162  28000 ????				       endif
   1163  28000 ????				       endif
   1164  28000 ????				       if	{1}_width = 12
   1165  28000 ????				       asl		; carry clear
   1166  28000 ????				       if	MACARG5CONST = 1
   1167  28000 ????				       adc	#.ByteOffset
   1168  28000 ????				       else
   1169  28000 ????				       adc	.ByteOffset
   1170  28000 ????				       endif
   1171  28000 ????				       asl
   1172  28000 ????				       asl
   1173  28000 ????				       endif
   1174  28000 ????				       if	{1}_width = 13
   1175  28000 ????				       asl		; carry clear
   1176  28000 ????				       if	MACARG5CONST = 1
   1177  28000 ????				       adc	#.ByteOffset
   1178  28000 ????				       else
   1179  28000 ????				       adc	.ByteOffset
   1180  28000 ????				       endif
   1181  28000 ????				       asl
   1182  28000 ????				       asl
   1183  28000 ????				       if	MACARG5CONST = 1
   1184  28000 ????				       adc	#.ByteOffset
   1185  28000 ????				       else
   1186  28000 ????				       adc	.ByteOffset
   1187  28000 ????				       endif
   1188  28000 ????				       endif
   1189  28000 ????				       if	{1}_width = 14
   1190  28000 ????				       asl		; carry clear
   1191  28000 ????				       if	MACARG5CONST = 1
   1192  28000 ????				       adc	#.ByteOffset
   1193  28000 ????				       else
   1194  28000 ????				       adc	.ByteOffset
   1195  28000 ????				       endif
   1196  28000 ????				       asl
   1197  28000 ????				       if	MACARG5CONST = 1
   1198  28000 ????				       adc	#.ByteOffset
   1199  28000 ????				       else
   1200  28000 ????				       adc	.ByteOffset
   1201  28000 ????				       endif
   1202  28000 ????				       asl
   1203  28000 ????				       endif
   1204  28000 ????				       if	{1}_width = 15
   1205  28000 ????				       asl
   1206  28000 ????				       if	MACARG5CONST = 1
   1207  28000 ????				       adc	#.ByteOffset
   1208  28000 ????				       else
   1209  28000 ????				       adc	.ByteOffset
   1210  28000 ????				       endif
   1211  28000 ????				       asl
   1212  28000 ????				       if	MACARG5CONST = 1
   1213  28000 ????				       adc	#.ByteOffset
   1214  28000 ????				       else
   1215  28000 ????				       adc	.ByteOffset
   1216  28000 ????				       endif
   1217  28000 ????				       asl
   1218  28000 ????				       if	MACARG5CONST = 1
   1219  28000 ????				       adc	#.ByteOffset
   1220  28000 ????				       else
   1221  28000 ????				       adc	.ByteOffset
   1222  28000 ????				       endif
   1223  28000 ????				       endif
   1224  28000 ????				       if	{1}_width = 16
   1225  28000 ????				       asl
   1226  28000 ????				       asl
   1227  28000 ????				       asl
   1228  28000 ????				       asl
   1229  28000 ????				       endif
   1230  28000 ????				       adc	#<.GFXLabel
   1231  28000 ????				       else
   1232  28000 ????				       lda	#<.GFXLabel
   1233  28000 ????				       endif		; .ByteOffset
   1234  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1235  28000 ????
   1236  28000 ????				       iny
   1237  28000 ????				       if	MACARG2CONST = 1
   1238  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1239  28000 ????				       else
   1240  28000 ????				       lda	#({1}_width_twoscompliment)
   1241  28000 ????				       ora	.Palette
   1242  28000 ????				       endif
   1243  28000 ????
   1244  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1245  28000 ????
   1246  28000 ????				       iny
   1247  28000 ????				       if	MACARG4CONST = 0
   1248  28000 ????				       lda	.SpriteY
   1249  28000 ????				       else
   1250  28000 ????				       lda	#.SpriteY
   1251  28000 ????				       endif
   1252  28000 ????				       and	#(WZONEHEIGHT - 1)
   1253  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
   1254  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1255  28000 ????
   1256  28000 ????				       iny
   1257  28000 ????				       if	MACARG3CONST = 1
   1258  28000 ????				       lda	#.SpriteX
   1259  28000 ????				       else
   1260  28000 ????				       lda	.SpriteX
   1261  28000 ????				       endif
   1262  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1263  28000 ????
   1264  28000 ????				       iny
   1265  28000 ????				       sty	dlend,x
   1266  28000 ????
   1267  28000 ????				       ifconst	ALWAYSTERMINATE
   1268  28000 ????				       iny
   1269  28000 ????				       lda	#0
   1270  28000 ????				       sta	(dlpnt),y
   1271  28000 ????				       endif
   1272  28000 ????
   1273  28000 ????			    .PLOTSPRITEend
   1274  28000 ????				       ENDM
   1275  28000 ????
   1276  28000 ????				       MAC	scrollsetup
   1277  28000 ????
   1278  28000 ????						; If vertical scrolling is enabled...
   1279  28000 ????						;   * Fills the DLs with hidden masking sprites.
   1280  28000 ????						; Adds blank sprites to the DLs to fill the screen.
   1281  28000 ????						; If horizontal scrolling is enabled...
   1282  28000 ????						;   * Adds another blank DL off-screen
   1283  28000 ????
   1284  28000 ????						; {1} - constant - the first dl of the scrolling area
   1285  28000 ????						; {2} - symbol   - blank tile label
   1286  28000 ????
   1287  28000 ????						; *** clear the saved dl ending for scrolling zones...
   1288  28000 ????				       ldx	#{1}
   1289  28000 ????				       lda	#0
   1290  28000 ????			    .scrollcleardls
   1291  28000 ????				       sta	dlend,x
   1292  28000 ????				       inx
   1293  28000 ????				       cpx	#WZONECOUNT
   1294  28000 ????				       bne	.scrollcleardls
   1295  28000 ????
   1296  28000 ????				       ifconst	VSCROLL
   1297  28000 ????						; *** adjust the ending for our mask dl to allow for mask objects...
   1298  28000 ????				       dex
   1299  28000 ????				       lda	#(maskscrollspriteend-maskscrollsprite)
   1300  28000 ????				       sta	dlend,x
   1301  28000 ????
   1302  28000 ????						; *** Add 4x dma masking objects to last zone...
   1303  28000 ????				       ldx	#(maskscrollspriteend-maskscrollsprite-1)
   1304  28000 ????			    .scrollpopulateloop1
   1305  28000 ????				       lda	maskscrollsprite,x
   1306  28000 ????				       sta	LASTZONEADDRESS+0,x
   1307  28000 ????				       ifconst	DOUBLEBUFFER
   1308  28000 ????				       sta	LASTZONEADDRESS+0+DOUBLEBUFFEROFFSET,x
   1309  28000 ????				       endif		; DOUBLEBUFFER
   1310  28000 ????				       dex
   1311  28000 ????				       bpl	.scrollpopulateloop1
   1312  28000 ????				       inx		; x=0
   1313  28000 ????				       stx	finescrolly
   1314  28000 ????				       endif		; VSCROLL
   1315  28000 ????
   1316  28000 ????						; *** Add blank sprite-tile objects to the scrolling zones...
   1317  28000 ????			    PLOTSP4    =	1	; ensure we use 4 byte sprites
   1318  28000 ????
   1319  28000 ????						; convert byte width of the sprit to coordinate width...
   1320  28000 ????				       if	{2}_mode = 0	; ### 160A, 320A, 320D
   1321  28000 ????			    .scrollXWIDTH SET	({2}_width * 4)	; 4x 160-mode pixels per byte
   1322  28000 ????				       else		; ### 160B, 320B, 320C
   1323  28000 ????			    .scrollXWIDTH SET	({2}_width * 2)	; 2x 160-mode pixels per byte
   1324  28000 ????				       endif
   1325  28000 ????
   1326  28000 ????						; figure out how many sprites we need to fill a screen width...
   1327  28000 ????			    .scrollSPRITECOuNT SET	((160+.scrollXWIDTH-1)/.scrollXWIDTH)
   1328  28000 ????				       ifconst	HSCROLL
   1329  28000 ????			    .scrollSPRITECOuNT SET	(.scrollSPRITECOuNT+1)
   1330  28000 ????				       endif		; HSCROLL
   1331  28000 ????
   1332  28000 ????						; setup plotsprite4 parameters...
   1333  28000 ????				       lda	#<{2}
   1334  28000 ????				       sta	temp1
   1335  28000 ????				       lda	#>{2}
   1336  28000 ????				       sta	temp2
   1337  28000 ????				       lda	#{2}_width_twoscompliment
   1338  28000 ????				       sta	temp3	; width
   1339  28000 ????
   1340  28000 ????				       lda	#{1}
   1341  28000 ????				       asl
   1342  28000 ????				       asl
   1343  28000 ????				       asl
   1344  28000 ????				       if	WZONEHEIGHT
   1345  28000 ????				       asl
   1346  28000 ????				       endif
   1347  28000 ????				       sta	temp5	; Y
   1348  28000 ????			    .scrollpopulateloop2
   1349  28000 ????				       lda	#0
   1350  28000 ????				       sta	temp4	; X
   1351  28000 ????			    .scrollpopulateloop3
   1352  28000 ????				       jsr	skipplotsprite4wait
   1353  28000 ????				       lda	temp4	; X
   1354  28000 ????				       clc
   1355  28000 ????				       adc	#.scrollXWIDTH
   1356  28000 ????				       sta	temp4	; X
   1357  28000 ????				       cmp	#(.scrollSPRITECOuNT*.scrollXWIDTH)
   1358  28000 ????				       bne	.scrollpopulateloop3
   1359  28000 ????				       lda	temp5	; Y
   1360  28000 ????				       clc
   1361  28000 ????				       adc	#WZONEHEIGHT
   1362  28000 ????				       sta	temp5	; Y
   1363  28000 ????				       cmp	#((WZONECOUNT*WZONEHEIGHT)+WZONEHEIGHT)
   1364  28000 ????				       bne	.scrollpopulateloop2
   1365  28000 ????				       ENDM
   1366  28000 ????
   1367  28000 ????				       MAC	sizeof
   1368  28000 ????
   1369  28000 ????						; echoes the size difference between the current address and the
   1370  28000 ????						; a label that was passed as an argument. This is a quick way to
   1371  28000 ????						; determine the size of a structure.
   1372  28000 ????
   1373  28000 ????			    .NAME      SETSTR	{1}
   1374  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
   1375  28000 ????				       ENDM
   1376  28000 ????
   1377  28000 ????						;
   1378  28000 ????						; speakjet.inc
   1379  28000 ????						;
   1380  28000 ????						;
   1381  28000 ????						; AtariVox Speech Synth Driver
   1382  28000 ????						;
   1383  28000 ????						; By Alex Herbert, 2004
   1384  28000 ????						;
   1385  28000 ????
   1386  28000 ????
   1387  28000 ????
   1388  28000 ????
   1389  28000 ????						; Constants
   1390  28000 ????
   1391  28000 ????
   1392  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
   1393  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
   1394  28000 ????
   1395  28000 ????
   1396  28000 ????
   1397  28000 ????						; Macros
   1398  28000 ????
   1399  28000 ????				       mac	spkout
   1400  28000 ????
   1401  28000 ????						; check buffer-full status
   1402  28000 ????				       lda	SWCHA
   1403  28000 ????				       and	#SERIAL_RDYMASK
   1404  28000 ????				       beq	.speech_done
   1405  28000 ????
   1406  28000 ????						; get next speech byte
   1407  28000 ????				       ldy	#$00
   1408  28000 ????				       lda	(speech_addr),y
   1409  28000 ????
   1410  28000 ????						; invert data and check for end of string
   1411  28000 ????				       eor	#$ff
   1412  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
   1413  28000 ????				       beq	.speech_done
   1414  28000 ????				       sta	{1}
   1415  28000 ????
   1416  28000 ????						; increment speech pointer
   1417  28000 ????				       inc	speech_addr
   1418  28000 ????				       bne	.incaddr_skip
   1419  28000 ????				       inc	speech_addr+1
   1420  28000 ????			    .incaddr_skip
   1421  28000 ????
   1422  28000 ????						; output byte as serial data
   1423  28000 ????
   1424  28000 ????				       sec		; start bit
   1425  28000 ????			    .byteout_loop
   1426  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
   1427  28000 ????				       lda	SWACNT	; 4
   1428  28000 ????				       and	#$fe	; 2 6
   1429  28000 ????				       adc	#$00	; 2 8
   1430  28000 ????				       sta	SWACNT	; 4 12
   1431  28000 ????
   1432  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
   1433  28000 ????				       cpy	#$09	; 2 14
   1434  28000 ????				       beq	.speech_done	; 2 16
   1435  28000 ????				       iny		; 2 18
   1436  28000 ????
   1437  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
   1438  28000 ????						; to match the original baud rate...
   1439  28000 ????						;ldx	  #$07 ; 2600
   1440  28000 ????				       ldx	#$0D
   1441  28000 ????
   1442  28000 ????			    .delay_loop
   1443  28000 ????				       dex		; 
   1444  28000 ????				       bne	.delay_loop	; 36 54
   1445  28000 ????
   1446  28000 ????						; shift next data bit into carry
   1447  28000 ????				       lsr	{1}	; 5 59
   1448  28000 ????
   1449  28000 ????						; and loop (branch always taken)
   1450  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
   1451  28000 ????
   1452  28000 ????			    .speech_done
   1453  28000 ????
   1454  28000 ????				       endm
   1455  28000 ????
   1456  28000 ????
   1457  28000 ????				       mac	speak
   1458  28000 ????
   1459  28000 ????				       lda	#<{1}
   1460  28000 ????				       sta	speech_addr
   1461  28000 ????				       lda	#>{1}
   1462  28000 ????				       sta	speech_addr+1
   1463  28000 ????
   1464  28000 ????				       endm
   1465  28000 ????
   1466  28000 ????
   1467  28000 ????
   1468  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
   1469  28000 ????
   1470  28000 ????				       processor	6502
   1471  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    123  28000 ????		02 85	    TIMINT     =	$285	;Interval Timer Interrupt		       read-only
    124  28000 ????
    125  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    font_mode  =	$00
      4  28000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  28000 ????		00 35	    font_width =	$35
      6  28000 ????		01 42	    wait       =	var2
      7  28000 ????
      8  28000 ????		01 41	    bgColor    =	var1
      9  28000 ????
     10  28000 ????		00 0f	    font_color1 =	$0f
     11  28000 ????		00 00	    font_color0 =	$00
     12  28000 ????		00 08	    bankswitchmode =	8
     13  28000 ????		00 01	    ROM128K    =	1
     14  28000 ????		00 01	    BANKSETROM =	1
     15  28000 ????		00 01	    plotvalueonscreen =	1
     16  28000 ????		00 10	    ZONEHEIGHT =	16
     17  28000 ????		00 01	    NTSC       =	1
     18  28000 ????		00 01	    SNES2ATARISUPPORT =	1
     19  28000 ????		00 01	    MEGA7800SUPPORT =	1
     20  28000 ????		00 01	    MULTIBUTTON =	1
     21  28000 ????		00 01	    collisionwrap =	1
     22  28000 ????		80 00	    alphadata0 =	$8000
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    sSWCHA     =	$2131
     63  28000 ????						; reserved	 = $2132
     64  28000 ????
     65  28000 ????		21 33	    hsdisplaymode =	$2133
     66  28000 ????		21 34	    gamedifficulty =	$2134
     67  28000 ????		21 35	    hsinitialpos =	$2135
     68  28000 ????		21 36	    hsinitialhold =	$2136
     69  28000 ????		21 37	    hscursorx  =	$2137
     70  28000 ????		21 38	    hsjoydebounce =	$2138
     71  28000 ????		21 39	    hsswcha    =	$2139
     72  28000 ????		21 3a	    hsinpt1    =	$213A
     73  28000 ????		21 3b	    hscolorchaseindex =	$213B
     74  28000 ????		21 3c	    visibleDLLstart =	$213C
     75  28000 ????		21 3d	    overscanDLLstart =	$213D
     76  28000 ????		21 3e	    frameslost =	$213E
     77  28000 ????		21 3f	    hsreturn   =	$213F
     78  28000 ????
     79  28000 ????
     80  28000 ????		00 40	    rand       =	$40
     81  28000 ????		00 41	    rand16     =	$41
     82  28000 ????		00 42	    temp1      =	$42
     83  28000 ????		00 43	    temp2      =	$43
     84  28000 ????		00 44	    temp3      =	$44
     85  28000 ????		00 45	    temp4      =	$45
     86  28000 ????		00 46	    temp5      =	$46
     87  28000 ????		00 47	    temp6      =	$47
     88  28000 ????		00 48	    temp7      =	$48
     89  28000 ????		00 49	    temp8      =	$49
     90  28000 ????		00 4a	    temp9      =	$4a
     91  28000 ????
     92  28000 ????		00 4b	    pokeybase  =	$4b
     93  28000 ????		00 4b	    pokeybaselo =	$4b
     94  28000 ????		00 4c	    pokeybasehi =	$4c
     95  28000 ????
     96  28000 ????		00 4d	    visibleover =	$4d
     97  28000 ????
     98  28000 ????		00 4e	    sfx1pointlo =	$4e
     99  28000 ????		00 4f	    sfx2pointlo =	$4f
    100  28000 ????		00 50	    sfx1pointhi =	$50
    101  28000 ????		00 51	    sfx2pointhi =	$51
    102  28000 ????
    103  28000 ????		00 52	    sfx1priority =	$52
    104  28000 ????		00 53	    sfx2priority =	$53
    105  28000 ????		00 54	    sfx1poffset =	$54
    106  28000 ????		00 55	    sfx2poffset =	$55
    107  28000 ????
    108  28000 ????		00 56	    sfx1frames =	$56
    109  28000 ????		00 57	    sfx2frames =	$57
    110  28000 ????		00 58	    sfx1tick   =	$58
    111  28000 ????		00 59	    sfx2tick   =	$59
    112  28000 ????
    113  28000 ????		00 5a	    tempmath   =	$5a
    114  28000 ????
    115  28000 ????		00 5b	    pokey1pointlo =	$5b
    116  28000 ????		00 5c	    pokey1pointhi =	$5c
    117  28000 ????		00 5d	    pokey2pointlo =	$5d
    118  28000 ????		00 5e	    pokey2pointhi =	$5e
    119  28000 ????		00 5f	    pokey3pointlo =	$5f
    120  28000 ????		00 60	    pokey3pointhi =	$60
    121  28000 ????		00 61	    pokey4pointlo =	$61
    122  28000 ????		00 62	    pokey4pointhi =	$62
    123  28000 ????
    124  28000 ????		00 63	    dlpnt      =	$63	; to $64
    125  28000 ????		00 65	    dlend      =	$65	; to $81 - for 29 possible visible dll entries
    126  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 29 possible visible dll entries
    127  28000 ????
    128  28000 ????		00 9f	    speech_addr =	$9f
    129  28000 ????		00 a0	    speech_addr_hi =	$a0
    130  28000 ????
    131  28000 ????		00 a1	    HSGameTableLo =	$a1
    132  28000 ????		00 a2	    HSGameTableHi =	$a2
    133  28000 ????		00 a3	    HSVoxHi    =	$a3
    134  28000 ????		00 a4	    HSVoxLo    =	$a4
    135  28000 ????
    136  28000 ????						;channel pointers
    137  28000 ????
    138  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    139  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    140  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    141  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    142  28000 ????
    143  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    144  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    145  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    146  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    147  28000 ????
    148  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    149  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    150  28000 ????		00 af	    songchannel3layer3lo =	$aF
    151  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    152  28000 ????
    153  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    154  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    155  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    156  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    157  28000 ????
    158  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    159  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    160  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    161  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    162  28000 ????
    163  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    164  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    165  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    166  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    167  28000 ????
    168  28000 ????		00 bd	    songdatalo =	$bd
    169  28000 ????		00 be	    songdatahi =	$be
    170  28000 ????
    171  28000 ????		00 bf	    inactivechannelcount =	$bf
    172  28000 ????
    173  28000 ????		00 c0	    songchannel1transpose =	$c0
    174  28000 ????		00 c1	    songchannel2transpose =	$c1
    175  28000 ????		00 c2	    songchannel3transpose =	$c2
    176  28000 ????		00 c3	    songchannel4transpose =	$c3
    177  28000 ????
    178  28000 ????		00 c4	    songstackindex =	$c4
    179  28000 ????
    180  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    181  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    182  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    183  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    184  28000 ????
    185  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    186  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    187  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    188  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    189  28000 ????
    190  28000 ????		00 cd	    sfx1notedata =	$cd
    191  28000 ????		00 ce	    sfx2notedata =	$ce
    192  28000 ????
    193  28000 ????		00 cf	    songloops  =	$cf
    194  28000 ????
    195  28000 ????		00 d0	    songpointerlo =	$D0
    196  28000 ????		00 d1	    songpointerhi =	$D1
    197  28000 ????
    198  28000 ????		00 d2	    voxlock    =	$D2
    199  28000 ????		00 d3	    voxqueuesize =	$D3
    200  28000 ????
    201  28000 ????		00 d4	    vblankroutines =	$D4
    202  28000 ????
    203  28000 ????		00 d5	    doublebufferstate =	$D5
    204  28000 ????		00 d6	    doublebufferdloffset =	$D6
    205  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    206  28000 ????
    207  28000 ????		00 d8	    inttemp1   =	$D8
    208  28000 ????		00 d9	    inttemp2   =	$D9
    209  28000 ????		00 da	    inttemp3   =	$DA
    210  28000 ????		00 db	    inttemp4   =	$DB
    211  28000 ????		00 dc	    inttemp5   =	$DC
    212  28000 ????		00 dd	    inttemp6   =	$DD
    213  28000 ????
    214  28000 ????		00 de	    sfxschedulelock =	$DE
    215  28000 ????		00 df	    sfxschedulemissed =	$DF
    216  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    217  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    218  28000 ????		00 e2	    sfxpitchoffset =	$E2
    219  28000 ????		00 e3	    sfxnoteindex =	$E3
    220  28000 ????
    221  28000 ????						; reserved = $E4
    222  28000 ????						; reserved = $E5
    223  28000 ????
    224  28000 ????		00 e6	    A	       =	$e6
    225  28000 ????		00 e6	    a	       =	$e6
    226  28000 ????		00 e7	    B	       =	$e7
    227  28000 ????		00 e7	    b	       =	$e7
    228  28000 ????		00 e8	    C	       =	$e8
    229  28000 ????		00 e8	    c	       =	$e8
    230  28000 ????		00 e9	    D	       =	$e9
    231  28000 ????		00 e9	    d	       =	$e9
    232  28000 ????		00 ea	    E	       =	$ea
    233  28000 ????		00 ea	    e	       =	$ea
    234  28000 ????		00 eb	    F	       =	$eb
    235  28000 ????		00 eb	    f	       =	$eb
    236  28000 ????		00 ec	    G	       =	$ec
    237  28000 ????		00 ec	    g	       =	$ec
    238  28000 ????		00 ed	    H	       =	$ed
    239  28000 ????		00 ed	    h	       =	$ed
    240  28000 ????		00 ee	    I	       =	$ee
    241  28000 ????		00 ee	    i	       =	$ee
    242  28000 ????		00 ef	    J	       =	$ef
    243  28000 ????		00 ef	    j	       =	$ef
    244  28000 ????		00 f0	    K	       =	$f0
    245  28000 ????		00 f0	    k	       =	$f0
    246  28000 ????		00 f1	    L	       =	$f1
    247  28000 ????		00 f1	    l	       =	$f1
    248  28000 ????		00 f2	    M	       =	$f2
    249  28000 ????		00 f2	    m	       =	$f2
    250  28000 ????		00 f3	    N	       =	$f3
    251  28000 ????		00 f3	    n	       =	$f3
    252  28000 ????		00 f4	    O	       =	$f4
    253  28000 ????		00 f4	    o	       =	$f4
    254  28000 ????		00 f5	    P	       =	$f5
    255  28000 ????		00 f5	    p	       =	$f5
    256  28000 ????		00 f6	    Q	       =	$f6
    257  28000 ????		00 f6	    q	       =	$f6
    258  28000 ????		00 f7	    R	       =	$f7
    259  28000 ????		00 f7	    r	       =	$f7
    260  28000 ????		00 f8	    S	       =	$f8
    261  28000 ????		00 f8	    s	       =	$f8
    262  28000 ????		00 f9	    T	       =	$f9
    263  28000 ????		00 f9	    t	       =	$f9
    264  28000 ????		00 fa	    U	       =	$fa
    265  28000 ????		00 fa	    u	       =	$fa
    266  28000 ????		00 fb	    V	       =	$fb
    267  28000 ????		00 fb	    v	       =	$fb
    268  28000 ????		00 fc	    W	       =	$fc
    269  28000 ????		00 fc	    w	       =	$fc
    270  28000 ????		00 fd	    X	       =	$fd
    271  28000 ????		00 fd	    x	       =	$fd
    272  28000 ????		00 fe	    Y	       =	$fe
    273  28000 ????		00 fe	    y	       =	$fe
    274  28000 ????		00 ff	    Z	       =	$ff
    275  28000 ????		00 ff	    z	       =	$ff
    276  28000 ????
    277  28000 ????						; var0-var99 variables use the top of the stack
    278  28000 ????		01 40	    var0       =	$140
    279  28000 ????		01 41	    var1       =	$141
    280  28000 ????		01 42	    var2       =	$142
    281  28000 ????		01 43	    var3       =	$143
    282  28000 ????		01 44	    var4       =	$144
    283  28000 ????		01 45	    var5       =	$145
    284  28000 ????		01 46	    var6       =	$146
    285  28000 ????		01 47	    var7       =	$147
    286  28000 ????		01 48	    var8       =	$148
    287  28000 ????		01 49	    var9       =	$149
    288  28000 ????		01 4a	    var10      =	$14a
    289  28000 ????		01 4b	    var11      =	$14b
    290  28000 ????		01 4c	    var12      =	$14c
    291  28000 ????		01 4d	    var13      =	$14d
    292  28000 ????		01 4e	    var14      =	$14e
    293  28000 ????		01 4f	    var15      =	$14f
    294  28000 ????		01 50	    var16      =	$150
    295  28000 ????		01 51	    var17      =	$151
    296  28000 ????		01 52	    var18      =	$152
    297  28000 ????		01 53	    var19      =	$153
    298  28000 ????		01 54	    var20      =	$154
    299  28000 ????		01 55	    var21      =	$155
    300  28000 ????		01 56	    var22      =	$156
    301  28000 ????		01 57	    var23      =	$157
    302  28000 ????		01 58	    var24      =	$158
    303  28000 ????		01 59	    var25      =	$159
    304  28000 ????		01 5a	    var26      =	$15a
    305  28000 ????		01 5b	    var27      =	$15b
    306  28000 ????		01 5c	    var28      =	$15c
    307  28000 ????		01 5d	    var29      =	$15d
    308  28000 ????		01 5e	    var30      =	$15e
    309  28000 ????		01 5f	    var31      =	$15f
    310  28000 ????		01 60	    var32      =	$160
    311  28000 ????		01 61	    var33      =	$161
    312  28000 ????		01 62	    var34      =	$162
    313  28000 ????		01 63	    var35      =	$163
    314  28000 ????		01 64	    var36      =	$164
    315  28000 ????		01 65	    var37      =	$165
    316  28000 ????		01 66	    var38      =	$166
    317  28000 ????		01 67	    var39      =	$167
    318  28000 ????		01 68	    var40      =	$168
    319  28000 ????		01 69	    var41      =	$169
    320  28000 ????		01 6a	    var42      =	$16a
    321  28000 ????		01 6b	    var43      =	$16b
    322  28000 ????		01 6c	    var44      =	$16c
    323  28000 ????		01 6d	    var45      =	$16d
    324  28000 ????		01 6e	    var46      =	$16e
    325  28000 ????		01 6f	    var47      =	$16f
    326  28000 ????		01 70	    var48      =	$170
    327  28000 ????		01 71	    var49      =	$171
    328  28000 ????		01 72	    var50      =	$172
    329  28000 ????		01 73	    var51      =	$173
    330  28000 ????		01 74	    var52      =	$174
    331  28000 ????		01 75	    var53      =	$175
    332  28000 ????		01 76	    var54      =	$176
    333  28000 ????		01 77	    var55      =	$177
    334  28000 ????		01 78	    var56      =	$178
    335  28000 ????		01 79	    var57      =	$179
    336  28000 ????		01 7a	    var58      =	$17a
    337  28000 ????		01 7b	    var59      =	$17b
    338  28000 ????		01 7c	    var60      =	$17c
    339  28000 ????		01 7d	    var61      =	$17d
    340  28000 ????		01 7e	    var62      =	$17e
    341  28000 ????		01 7f	    var63      =	$17f
    342  28000 ????		01 80	    var64      =	$180
    343  28000 ????		01 81	    var65      =	$181
    344  28000 ????		01 82	    var66      =	$182
    345  28000 ????		01 83	    var67      =	$183
    346  28000 ????		01 84	    var68      =	$184
    347  28000 ????		01 85	    var69      =	$185
    348  28000 ????		01 86	    var70      =	$186
    349  28000 ????		01 87	    var71      =	$187
    350  28000 ????		01 88	    var72      =	$188
    351  28000 ????		01 89	    var73      =	$189
    352  28000 ????		01 8a	    var74      =	$18a
    353  28000 ????		01 8b	    var75      =	$18b
    354  28000 ????		01 8c	    var76      =	$18c
    355  28000 ????		01 8d	    var77      =	$18d
    356  28000 ????		01 8e	    var78      =	$18e
    357  28000 ????		01 8f	    var79      =	$18f
    358  28000 ????		01 90	    var80      =	$190
    359  28000 ????		01 91	    var81      =	$191
    360  28000 ????		01 92	    var82      =	$192
    361  28000 ????		01 93	    var83      =	$193
    362  28000 ????		01 94	    var84      =	$194
    363  28000 ????		01 95	    var85      =	$195
    364  28000 ????		01 96	    var86      =	$196
    365  28000 ????		01 97	    var87      =	$197
    366  28000 ????		01 98	    var88      =	$198
    367  28000 ????		01 99	    var89      =	$199
    368  28000 ????		01 9a	    var90      =	$19a
    369  28000 ????		01 9b	    var91      =	$19b
    370  28000 ????		01 9c	    var92      =	$19c
    371  28000 ????		01 9d	    var93      =	$19d
    372  28000 ????		01 9e	    var94      =	$19e
    373  28000 ????		01 9f	    var95      =	$19f
    374  28000 ????		01 a0	    var96      =	$1a0
    375  28000 ????		01 a1	    var97      =	$1a1
    376  28000 ????		01 a2	    var98      =	$1a2
    377  28000 ????		01 a3	    var99      =	$1a3
    378  28000 ????
    379 U01c6 ????				      SEG.U	"7800basicRAM"
    380 U01a4					      ORG	$1A4
    381 U01a4
    382 U01a4							; MAX allocation locations are in comments...
    383 U01a4		       00	   framecounter DS	1	; $1A4
    384 U01a5		       00	   countdownseconds DS	1	; $1A5
    385 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    386 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    387 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    388 U01ad		       00	   valbufend  DS	1	; $1AD
    389 U01ae		       00	   valbufendsave DS	1	; $1AE
    390 U01af		       00	   finescrollx DS	1	; $1AF
    391 U01b0		       00	   finescrolly DS	1	; $1B0
    392 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    393 U01b2		       00	   interruptindex DS	1	; $1B2
    394 U01b3
    395 U01b3				  -	      ifconst	DOUBLEBUFFER
    396 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    397 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    398 U01b3					      endif
    399 U01b3
    400 U01b3		       00	   pausedisable DS	1	; $1B5
    401 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    402 U01b5
    403 U01b5				  -	      ifconst	AVOXVOICE
    404 U01b5				  -avoxenable DS	1	; $1B7
    405 U01b5				  -tempavox   DS	1	; $1B8
    406 U01b5					      endif
    407 U01b5
    408 U01b5				  -	      ifconst	MUSICTRACKER
    409 U01b5				  -songtempo  DS	1	; $1B9
    410 U01b5				  -songtick   DS	1	; $1BA
    411 U01b5				  -
    412 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    413 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    414 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    415 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    416 U01b5				  -
    417 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    418 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    419 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    420 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    421 U01b5				  -
    422 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    423 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    424 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    425 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    426 U01b5				  -
    427 U01b5				  -songchannel1busywait DS	1	; $1C7
    428 U01b5				  -songchannel2busywait DS	1	; $1C8
    429 U01b5				  -songchannel3busywait DS	1	; $1C9
    430 U01b5				  -songchannel4busywait DS	1	; $1CA
    431 U01b5				  -
    432 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    433 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    434 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    435 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    436 U01b5					      endif
    437 U01b5
    438 U01b5		       00	   palframes  DS	1
    439 U01b6		       00	   ntscslowframe DS	1
    440 U01b7		       00	   palfastframe DS	1
    441 U01b8
    442 U01b8				  -	      ifconst	MOUSESUPPORT
    443 U01b8				  -port0resolution DS	1
    444 U01b8				  -port1resolution DS	1
    445 U01b8					      else
    446 U01b8				  -	      ifconst	TRAKBALLSUPPORT
    447 U01b8				  -port0resolution DS	1
    448 U01b8				  -port1resolution DS	1
    449 U01b8					      endif
    450 U01b8					      endif
    451 U01b8
    452 U01b8		       00	   port0control DS	1
    453 U01b9		       00	   port1control DS	1
    454 U01ba
    455 U01ba							; port#control values...
    456 U01ba							;	1 = proline
    457 U01ba							;	2 = lightgun
    458 U01ba							;	3 = paddle
    459 U01ba							;	4 = trakball
    460 U01ba							;	5 = vcs joystick
    461 U01ba							;	6 = driving
    462 U01ba							;	7 = keypad
    463 U01ba							;	8 = st mouse/cx80
    464 U01ba							;	9 = amiga mouse
    465 U01ba							;     10 = atarivox
    466 U01ba
    467 U01ba							; controller 0 data...
    468 U01ba		       00	   paddleposition0 DS	1
    469 U01ba		       01 ba	   keypadmatrix0a =	paddleposition0
    470 U01ba		       01 ba	   drivingposition0 =	paddleposition0
    471 U01ba		       01 ba	   trakballx0 =	paddleposition0
    472 U01ba		       01 ba	   mousex0    =	paddleposition0
    473 U01ba		       01 ba	   lighttgunx0 =	paddleposition0
    474 U01ba		       01 ba	   snes2atari0lo =	paddleposition0
    475 U01ba		       01 ba	   mega7800data0 =	paddleposition0
    476 U01bb
    477 U01bb							; controller 1 data...
    478 U01bb		       00	   paddleposition2 DS	1
    479 U01bb		       01 bb	   keypadmatrix1a =	paddleposition2
    480 U01bb		       01 bb	   drivingposition1 =	paddleposition2
    481 U01bb		       01 bb	   trakballx1 =	paddleposition2
    482 U01bb		       01 bb	   mousex1    =	paddleposition2
    483 U01bb		       01 bb	   lightgunx1 =	paddleposition2
    484 U01bb		       01 bb	   snes2atari1lo =	paddleposition2
    485 U01bb		       01 bb	   mega7800data1 =	paddleposition2
    486 U01bc
    487 U01bc							; controller 0 altdata...
    488 U01bc		       00	   paddleposition1 DS	1
    489 U01bc		       01 bc	   keypadmatrix0b =	paddleposition1
    490 U01bc		       01 bc	   trakbally0 =	paddleposition1
    491 U01bc		       01 bc	   mousey0    =	paddleposition1
    492 U01bc		       01 bc	   lightguny0 =	paddleposition1
    493 U01bc		       01 bc	   snes2atari0hi =	paddleposition1
    494 U01bc		       01 bc	   mega7800state0 =	paddleposition1
    495 U01bd
    496 U01bd							; controller 1 altdata...
    497 U01bd		       00	   paddleposition3 DS	1
    498 U01bd		       01 bd	   keypadmatrix1b =	paddleposition3
    499 U01bd		       01 bd	   trakbally1 =	paddleposition3
    500 U01bd		       01 bd	   mousey1    =	paddleposition3
    501 U01bd		       01 bd	   lightguny1 =	paddleposition3
    502 U01bd		       01 bd	   snes2atari1hi =	paddleposition3
    503 U01bd		       01 bd	   mega7800state1 =	paddleposition3
    504 U01be
    505 U01be							; controller state save. for trakball state+dir codes, rotary position codes
    506 U01be		       00	   controller0statesave DS	1
    507 U01be		       01 be	   paddleprevious0 =	controller0statesave
    508 U01be		       01 be	   mousecodex0 =	controller0statesave
    509 U01be		       01 be	   trakballcodex0 =	controller0statesave
    510 U01be		       01 be	   keypadmatrix0c =	controller0statesave
    511 U01be		       01 be	   snesdetected0 =	controller0statesave
    512 U01bf
    513 U01bf		       00	   controller1statesave DS	1
    514 U01bf		       01 bf	   paddleprevious2 =	controller1statesave
    515 U01bf		       01 bf	   mousecodex1 =	controller1statesave
    516 U01bf		       01 bf	   trakballcodex1 =	controller1statesave
    517 U01bf		       01 bf	   keypadmatrix1c =	controller1statesave
    518 U01bf		       01 bf	   snesdetected1 =	controller1statesave
    519 U01c0
    520 U01c0		       00	   paddleprevious1 DS	1
    521 U01c0		       01 c0	   keypadmatrix0d =	paddleprevious1
    522 U01c0		       01 c0	   mousecodey0 =	paddleprevious1
    523 U01c0		       01 c0	   trakballcodey0 =	paddleprevious1
    524 U01c1
    525 U01c1		       00	   paddleprevious3 DS	1
    526 U01c1		       01 c1	   keypadmatrix1d =	paddleprevious3
    527 U01c1		       01 c1	   mousecodey1 =	paddleprevious3
    528 U01c1		       01 c1	   trakballcodey1 =	paddleprevious3
    529 U01c2
    530 U01c2				  -	      ifconst	pokeysupport
    531 U01c2				  -pokey1frames DS	1
    532 U01c2				  -pokey1tick DS	1
    533 U01c2				  -pokey2frames DS	1
    534 U01c2				  -pokey2tick DS	1
    535 U01c2				  -pokey3frames DS	1
    536 U01c2				  -pokey3tick DS	1
    537 U01c2				  -pokey4frames DS	1
    538 U01c2				  -pokey4tick DS	1
    539 U01c2				  -pokey1priority DS	1
    540 U01c2				  -pokey1offset DS	1
    541 U01c2				  -pokey2priority DS	1
    542 U01c2				  -pokey2offset DS	1
    543 U01c2				  -pokey3priority DS	1
    544 U01c2				  -pokey3offset DS	1
    545 U01c2				  -pokey4priority DS	1
    546 U01c2				  -pokey4offset DS	1
    547 U01c2					      endif
    548 U01c2
    549 U01c2				  -	      ifconst	pokeykeysupport
    550 U01c2				  -pokeylastkeycode DS	1
    551 U01c2				  -pokeykeycode DS	1
    552 U01c2				  -pokeykeydebounce DS	1
    553 U01c2					      endif
    554 U01c2
    555 U01c2				  -	      ifconst	RMT
    556 U01c2				  -rasterpause DS	1
    557 U01c2					      endif		; RMT
    558 U01c2				  -	      ifconst	RMTVOLUME
    559 U01c2				  -rmtvolume  DS	1
    560 U01c2					      endif		; RMTVOLUME
    561 U01c2				  -	      ifconst	TIAVOLUME
    562 U01c2				  -tiavolume  DS	1
    563 U01c2					      endif		; TIAVOLUME
    564 U01c2
    565 U01c2				  -	      ifconst	FOURBITFADE
    566 U01c2				  -fourbittemp1 DS	1
    567 U01c2				  -fourbitfadevalue DS	1
    568 U01c2				  -fourbittemp1int DS	1
    569 U01c2				  -fourbitfadevalueint DS	1
    570 U01c2					      endif		; FOURBITFADE
    571 U01c2
    572 U01c2					      ifconst	SNES2ATARISUPPORT
    573 U01c2		       00	   snesport   DS	1
    574 U01c3					      endif		; SNES2ATARISUPPORT
    575 U01c3
    576 U01c3				  -	      ifconst	KEYPADSUPPORT
    577 U01c3				  -keypadcounter DS	1
    578 U01c3					      endif
    579 U01c3
    580 U01c3					      ifconst	MULTIBUTTON
    581 U01c3		       00	   multibuttoncount0 DS	1
    582 U01c4		       00	   multibuttoncount1 DS	1
    583 U01c5					      endif
    584 U01c5
    585 U01c5							; see if we need an interrupthold byte...
    586 U01c5				   INTERRUPTNEEDED SET	0
    587 U01c5				  -	      ifconst	.topscreenroutine
    588 U01c5				  -INTERRUPTNEEDED SET	1
    589 U01c5					      endif
    590 U01c5				  -	      ifconst	.bottomscreenroutine
    591 U01c5				  -INTERRUPTNEEDED SET	1
    592 U01c5					      endif
    593 U01c5				  -	      ifconst	.userinterrupt
    594 U01c5				  -INTERRUPTNEEDED SET	1
    595 U01c5					      endif
    596 U01c5				  -	      if	INTERRUPTNEEDED = 1
    597 U01c5				  -interrupthold DS	1
    598 U01c5					      endif
    599 U01c5
    600 U01c5					      ifnconst	CANARYOFF
    601 U01c5		       00	   canary     DS	1
    602 U01c6					      endif
    603 U01c6
    604 U01c6				  -	      ifnconst	bankswitchmode
    605 U01c6				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    606 U01c6					      else
   stack allowance: 19 nested subroutines.
    607 U01c6					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    608 U01c6					      endif
    609 U01c6					      ifnconst	CANARYOFF
   the canary is situated at: $1c5
    610 U01c6					      echo	"  the canary is situated at:",[canary]
    611 U01c6				  -	      else
    612 U01c6				  -	      echo	"  the canary is disabled."
    613 U01c6					      endif
    614 U01c6
    615 U01c6							; $1EE - $1FF reserved for stack
    616 U01c6
    617  28000 ????				       SEG	"GAME"
    618  28000 ????
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
------- FILE 7800_extravars.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800_extravars.h"
      1  28000 ????		22 00	    var100     =	$2200
      2  28000 ????		22 01	    var101     =	$2201
      3  28000 ????		22 02	    var102     =	$2202
      4  28000 ????		22 03	    var103     =	$2203
      5  28000 ????		22 04	    var104     =	$2204
      6  28000 ????		22 05	    var105     =	$2205
      7  28000 ????		22 06	    var106     =	$2206
      8  28000 ????		22 07	    var107     =	$2207
      9  28000 ????		22 08	    var108     =	$2208
     10  28000 ????		22 09	    var109     =	$2209
     11  28000 ????		22 0a	    var110     =	$220A
     12  28000 ????		22 0b	    var111     =	$220B
     13  28000 ????		22 0c	    var112     =	$220C
     14  28000 ????		22 0d	    var113     =	$220D
     15  28000 ????		22 0e	    var114     =	$220E
     16  28000 ????		22 0f	    var115     =	$220F
     17  28000 ????		22 10	    var116     =	$2210
     18  28000 ????		22 11	    var117     =	$2211
     19  28000 ????		22 12	    var118     =	$2212
     20  28000 ????		22 13	    var119     =	$2213
     21  28000 ????		22 14	    var120     =	$2214
     22  28000 ????		22 15	    var121     =	$2215
     23  28000 ????		22 16	    var122     =	$2216
     24  28000 ????		22 17	    var123     =	$2217
     25  28000 ????		22 18	    var124     =	$2218
     26  28000 ????		22 19	    var125     =	$2219
     27  28000 ????		22 1a	    var126     =	$221A
     28  28000 ????		22 1b	    var127     =	$221B
     29  28000 ????		22 1c	    var128     =	$221C
     30  28000 ????		22 1d	    var129     =	$221D
     31  28000 ????		22 1e	    var130     =	$221E
     32  28000 ????		22 1f	    var131     =	$221F
     33  28000 ????		22 20	    var132     =	$2220
     34  28000 ????		22 21	    var133     =	$2221
     35  28000 ????		22 22	    var134     =	$2222
     36  28000 ????		22 23	    var135     =	$2223
     37  28000 ????		22 24	    var136     =	$2224
     38  28000 ????		22 25	    var137     =	$2225
     39  28000 ????		22 26	    var138     =	$2226
     40  28000 ????		22 27	    var139     =	$2227
     41  28000 ????		22 28	    var140     =	$2228
     42  28000 ????		22 29	    var141     =	$2229
     43  28000 ????		22 2a	    var142     =	$222A
     44  28000 ????		22 2b	    var143     =	$222B
     45  28000 ????		22 2c	    var144     =	$222C
     46  28000 ????		22 2d	    var145     =	$222D
     47  28000 ????		22 2e	    var146     =	$222E
     48  28000 ????		22 2f	    var147     =	$222F
     49  28000 ????		22 30	    var148     =	$2230
     50  28000 ????		22 31	    var149     =	$2231
     51  28000 ????		22 32	    var150     =	$2232
     52  28000 ????		22 33	    var151     =	$2233
     53  28000 ????		22 34	    var152     =	$2234
     54  28000 ????		22 35	    var153     =	$2235
     55  28000 ????		22 36	    var154     =	$2236
     56  28000 ????		22 37	    var155     =	$2237
     57  28000 ????		22 38	    var156     =	$2238
     58  28000 ????		22 39	    var157     =	$2239
     59  28000 ????		22 3a	    var158     =	$223A
     60  28000 ????		22 3b	    var159     =	$223B
     61  28000 ????		22 3c	    var160     =	$223C
     62  28000 ????		22 3d	    var161     =	$223D
     63  28000 ????		22 3e	    var162     =	$223E
     64  28000 ????		22 3f	    var163     =	$223F
     65  28000 ????		22 40	    var164     =	$2240
     66  28000 ????		22 41	    var165     =	$2241
     67  28000 ????		22 42	    var166     =	$2242
     68  28000 ????		22 43	    var167     =	$2243
     69  28000 ????		22 44	    var168     =	$2244
     70  28000 ????		22 45	    var169     =	$2245
     71  28000 ????		22 46	    var170     =	$2246
     72  28000 ????		22 47	    var171     =	$2247
     73  28000 ????		22 48	    var172     =	$2248
     74  28000 ????		22 49	    var173     =	$2249
     75  28000 ????		22 4a	    var174     =	$224A
     76  28000 ????		22 4b	    var175     =	$224B
     77  28000 ????		22 4c	    var176     =	$224C
     78  28000 ????		22 4d	    var177     =	$224D
     79  28000 ????		22 4e	    var178     =	$224E
     80  28000 ????		22 4f	    var179     =	$224F
     81  28000 ????		22 50	    var180     =	$2250
     82  28000 ????		22 51	    var181     =	$2251
     83  28000 ????		22 52	    var182     =	$2252
     84  28000 ????		22 53	    var183     =	$2253
     85  28000 ????		22 54	    var184     =	$2254
     86  28000 ????		22 55	    var185     =	$2255
     87  28000 ????		22 56	    var186     =	$2256
     88  28000 ????		22 57	    var187     =	$2257
     89  28000 ????		22 58	    var188     =	$2258
     90  28000 ????		22 59	    var189     =	$2259
     91  28000 ????		22 5a	    var190     =	$225A
     92  28000 ????		22 5b	    var191     =	$225B
     93  28000 ????		22 5c	    var192     =	$225C
     94  28000 ????		22 5d	    var193     =	$225D
     95  28000 ????		22 5e	    var194     =	$225E
     96  28000 ????		22 5f	    var195     =	$225F
     97  28000 ????		22 60	    var196     =	$2260
     98  28000 ????		22 61	    var197     =	$2261
     99  28000 ????		22 62	    var198     =	$2262
    100  28000 ????		22 63	    var199     =	$2263
    101  28000 ????		22 64	    var200     =	$2264
    102  28000 ????		22 65	    var201     =	$2265
    103  28000 ????		22 66	    var202     =	$2266
    104  28000 ????		22 67	    var203     =	$2267
    105  28000 ????		22 68	    var204     =	$2268
    106  28000 ????		22 69	    var205     =	$2269
    107  28000 ????		22 6a	    var206     =	$226A
    108  28000 ????		22 6b	    var207     =	$226B
    109  28000 ????		22 6c	    var208     =	$226C
    110  28000 ????		22 6d	    var209     =	$226D
    111  28000 ????		22 6e	    var210     =	$226E
    112  28000 ????		22 6f	    var211     =	$226F
    113  28000 ????		22 70	    var212     =	$2270
    114  28000 ????		22 71	    var213     =	$2271
    115  28000 ????		22 72	    var214     =	$2272
    116  28000 ????		22 73	    var215     =	$2273
    117  28000 ????		22 74	    var216     =	$2274
    118  28000 ????		22 75	    var217     =	$2275
    119  28000 ????		22 76	    var218     =	$2276
    120  28000 ????		22 77	    var219     =	$2277
    121  28000 ????		22 78	    var220     =	$2278
    122  28000 ????		22 79	    var221     =	$2279
    123  28000 ????		22 7a	    var222     =	$227A
    124  28000 ????		22 7b	    var223     =	$227B
    125  28000 ????		22 7c	    var224     =	$227C
    126  28000 ????		22 7d	    var225     =	$227D
    127  28000 ????		22 7e	    var226     =	$227E
    128  28000 ????		22 7f	    var227     =	$227F
    129  28000 ????		22 80	    var228     =	$2280
    130  28000 ????		22 81	    var229     =	$2281
    131  28000 ????		22 82	    var230     =	$2282
    132  28000 ????		22 83	    var231     =	$2283
    133  28000 ????		22 84	    var232     =	$2284
    134  28000 ????		22 85	    var233     =	$2285
    135  28000 ????		22 86	    var234     =	$2286
    136  28000 ????		22 87	    var235     =	$2287
    137  28000 ????		22 88	    var236     =	$2288
    138  28000 ????		22 89	    var237     =	$2289
    139  28000 ????		22 8a	    var238     =	$228A
    140  28000 ????		22 8b	    var239     =	$228B
    141  28000 ????		22 8c	    var240     =	$228C
    142  28000 ????		22 8d	    var241     =	$228D
    143  28000 ????		22 8e	    var242     =	$228E
    144  28000 ????		22 8f	    var243     =	$228F
    145  28000 ????		22 90	    var244     =	$2290
    146  28000 ????		22 91	    var245     =	$2291
    147  28000 ????		22 92	    var246     =	$2292
    148  28000 ????		22 93	    var247     =	$2293
    149  28000 ????		22 94	    var248     =	$2294
    150  28000 ????		22 95	    var249     =	$2295
    151  28000 ????		22 96	    var250     =	$2296
    152  28000 ????		22 97	    var251     =	$2297
    153  28000 ????		22 98	    var252     =	$2298
    154  28000 ????		22 99	    var253     =	$2299
    155  28000 ????		22 9a	    var254     =	$229A
    156  28000 ????		22 9b	    var255     =	$229B
    157  28000 ????		22 9c	    var256     =	$229C
    158  28000 ????		22 9d	    var257     =	$229D
    159  28000 ????		22 9e	    var258     =	$229E
    160  28000 ????		22 9f	    var259     =	$229F
    161  28000 ????		22 a0	    var260     =	$22A0
    162  28000 ????		22 a1	    var261     =	$22A1
    163  28000 ????		22 a2	    var262     =	$22A2
    164  28000 ????		22 a3	    var263     =	$22A3
    165  28000 ????		22 a4	    var264     =	$22A4
    166  28000 ????		22 a5	    var265     =	$22A5
    167  28000 ????		22 a6	    var266     =	$22A6
    168  28000 ????		22 a7	    var267     =	$22A7
    169  28000 ????		22 a8	    var268     =	$22A8
    170  28000 ????		22 a9	    var269     =	$22A9
    171  28000 ????		22 aa	    var270     =	$22AA
    172  28000 ????		22 ab	    var271     =	$22AB
    173  28000 ????		22 ac	    var272     =	$22AC
    174  28000 ????		22 ad	    var273     =	$22AD
    175  28000 ????		22 ae	    var274     =	$22AE
    176  28000 ????		22 af	    var275     =	$22AF
    177  28000 ????		22 b0	    var276     =	$22B0
    178  28000 ????		22 b1	    var277     =	$22B1
    179  28000 ????		22 b2	    var278     =	$22B2
    180  28000 ????		22 b3	    var279     =	$22B3
    181  28000 ????		22 b4	    var280     =	$22B4
    182  28000 ????		22 b5	    var281     =	$22B5
    183  28000 ????		22 b6	    var282     =	$22B6
    184  28000 ????		22 b7	    var283     =	$22B7
    185  28000 ????		22 b8	    var284     =	$22B8
    186  28000 ????		22 b9	    var285     =	$22B9
    187  28000 ????		22 ba	    var286     =	$22BA
    188  28000 ????		22 bb	    var287     =	$22BB
    189  28000 ????		22 bc	    var288     =	$22BC
    190  28000 ????		22 bd	    var289     =	$22BD
    191  28000 ????		22 be	    var290     =	$22BE
    192  28000 ????		22 bf	    var291     =	$22BF
    193  28000 ????		22 c0	    var292     =	$22C0
    194  28000 ????		22 c1	    var293     =	$22C1
    195  28000 ????		22 c2	    var294     =	$22C2
    196  28000 ????		22 c3	    var295     =	$22C3
    197  28000 ????		22 c4	    var296     =	$22C4
    198  28000 ????		22 c5	    var297     =	$22C5
    199  28000 ????		22 c6	    var298     =	$22C6
    200  28000 ????		22 c7	    var299     =	$22C7
    201  28000 ????		22 c8	    var300     =	$22C8
    202  28000 ????		22 c9	    var301     =	$22C9
    203  28000 ????		22 ca	    var302     =	$22CA
    204  28000 ????		22 cb	    var303     =	$22CB
    205  28000 ????		22 cc	    var304     =	$22CC
    206  28000 ????		22 cd	    var305     =	$22CD
    207  28000 ????		22 ce	    var306     =	$22CE
    208  28000 ????		22 cf	    var307     =	$22CF
    209  28000 ????		22 d0	    var308     =	$22D0
    210  28000 ????		22 d1	    var309     =	$22D1
    211  28000 ????		22 d2	    var310     =	$22D2
    212  28000 ????		22 d3	    var311     =	$22D3
    213  28000 ????		22 d4	    var312     =	$22D4
    214  28000 ????		22 d5	    var313     =	$22D5
    215  28000 ????		22 d6	    var314     =	$22D6
    216  28000 ????		22 d7	    var315     =	$22D7
    217  28000 ????		22 d8	    var316     =	$22D8
    218  28000 ????		22 d9	    var317     =	$22D9
    219  28000 ????		22 da	    var318     =	$22DA
    220  28000 ????		22 db	    var319     =	$22DB
    221  28000 ????		22 dc	    var320     =	$22DC
    222  28000 ????		22 dd	    var321     =	$22DD
    223  28000 ????		22 de	    var322     =	$22DE
    224  28000 ????		22 df	    var323     =	$22DF
    225  28000 ????		22 e0	    var324     =	$22E0
    226  28000 ????		22 e1	    var325     =	$22E1
    227  28000 ????		22 e2	    var326     =	$22E2
    228  28000 ????		22 e3	    var327     =	$22E3
    229  28000 ????		22 e4	    var328     =	$22E4
    230  28000 ????		22 e5	    var329     =	$22E5
    231  28000 ????		22 e6	    var330     =	$22E6
    232  28000 ????		22 e7	    var331     =	$22E7
    233  28000 ????		22 e8	    var332     =	$22E8
    234  28000 ????		22 e9	    var333     =	$22E9
    235  28000 ????		22 ea	    var334     =	$22EA
    236  28000 ????		22 eb	    var335     =	$22EB
    237  28000 ????		22 ec	    var336     =	$22EC
    238  28000 ????		22 ed	    var337     =	$22ED
    239  28000 ????		22 ee	    var338     =	$22EE
    240  28000 ????		22 ef	    var339     =	$22EF
    241  28000 ????		22 f0	    var340     =	$22F0
    242  28000 ????		22 f1	    var341     =	$22F1
    243  28000 ????		22 f2	    var342     =	$22F2
    244  28000 ????		22 f3	    var343     =	$22F3
    245  28000 ????		22 f4	    var344     =	$22F4
    246  28000 ????		22 f5	    var345     =	$22F5
    247  28000 ????		22 f6	    var346     =	$22F6
    248  28000 ????		22 f7	    var347     =	$22F7
    249  28000 ????		22 f8	    var348     =	$22F8
    250  28000 ????		22 f9	    var349     =	$22F9
    251  28000 ????		22 fa	    var350     =	$22FA
    252  28000 ????		22 fb	    var351     =	$22FB
    253  28000 ????		22 fc	    var352     =	$22FC
    254  28000 ????		22 fd	    var353     =	$22FD
    255  28000 ????		22 fe	    var354     =	$22FE
    256  28000 ????		22 ff	    var355     =	$22FF
    257  28000 ????		23 00	    var356     =	$2300
    258  28000 ????		23 01	    var357     =	$2301
    259  28000 ????		23 02	    var358     =	$2302
    260  28000 ????		23 03	    var359     =	$2303
    261  28000 ????		23 04	    var360     =	$2304
    262  28000 ????		23 05	    var361     =	$2305
    263  28000 ????		23 06	    var362     =	$2306
    264  28000 ????		23 07	    var363     =	$2307
    265  28000 ????		23 08	    var364     =	$2308
    266  28000 ????		23 09	    var365     =	$2309
    267  28000 ????		23 0a	    var366     =	$230A
    268  28000 ????		23 0b	    var367     =	$230B
    269  28000 ????		23 0c	    var368     =	$230C
    270  28000 ????		23 0d	    var369     =	$230D
    271  28000 ????		23 0e	    var370     =	$230E
    272  28000 ????		23 0f	    var371     =	$230F
    273  28000 ????		23 10	    var372     =	$2310
    274  28000 ????		23 11	    var373     =	$2311
    275  28000 ????		23 12	    var374     =	$2312
    276  28000 ????		23 13	    var375     =	$2313
    277  28000 ????		23 14	    var376     =	$2314
    278  28000 ????		23 15	    var377     =	$2315
    279  28000 ????		23 16	    var378     =	$2316
    280  28000 ????		23 17	    var379     =	$2317
    281  28000 ????		23 18	    var380     =	$2318
    282  28000 ????		23 19	    var381     =	$2319
    283  28000 ????		23 1a	    var382     =	$231A
    284  28000 ????		23 1b	    var383     =	$231B
    285  28000 ????		23 1c	    var384     =	$231C
    286  28000 ????		23 1d	    var385     =	$231D
    287  28000 ????		23 1e	    var386     =	$231E
    288  28000 ????		23 1f	    var387     =	$231F
    289  28000 ????		23 20	    var388     =	$2320
    290  28000 ????		23 21	    var389     =	$2321
    291  28000 ????		23 22	    var390     =	$2322
    292  28000 ????		23 23	    var391     =	$2323
    293  28000 ????		23 24	    var392     =	$2324
    294  28000 ????		23 25	    var393     =	$2325
    295  28000 ????		23 26	    var394     =	$2326
    296  28000 ????		23 27	    var395     =	$2327
    297  28000 ????		23 28	    var396     =	$2328
    298  28000 ????		23 29	    var397     =	$2329
    299  28000 ????		23 2a	    var398     =	$232A
    300  28000 ????		23 2b	    var399     =	$232B
    301  28000 ????		23 2c	    var400     =	$232C
    302  28000 ????		23 2d	    var401     =	$232D
    303  28000 ????		23 2e	    var402     =	$232E
    304  28000 ????		23 2f	    var403     =	$232F
    305  28000 ????		23 30	    var404     =	$2330
    306  28000 ????		23 31	    var405     =	$2331
    307  28000 ????		23 32	    var406     =	$2332
    308  28000 ????		23 33	    var407     =	$2333
    309  28000 ????		23 34	    var408     =	$2334
    310  28000 ????		23 35	    var409     =	$2335
    311  28000 ????		23 36	    var410     =	$2336
    312  28000 ????		23 37	    var411     =	$2337
    313  28000 ????		23 38	    var412     =	$2338
    314  28000 ????		23 39	    var413     =	$2339
    315  28000 ????		23 3a	    var414     =	$233A
    316  28000 ????		23 3b	    var415     =	$233B
    317  28000 ????		23 3c	    var416     =	$233C
    318  28000 ????		23 3d	    var417     =	$233D
    319  28000 ????		23 3e	    var418     =	$233E
    320  28000 ????		23 3f	    var419     =	$233F
    321  28000 ????		23 40	    var420     =	$2340
    322  28000 ????		23 41	    var421     =	$2341
    323  28000 ????		23 42	    var422     =	$2342
    324  28000 ????		23 43	    var423     =	$2343
    325  28000 ????		23 44	    var424     =	$2344
    326  28000 ????		23 45	    var425     =	$2345
    327  28000 ????		23 46	    var426     =	$2346
    328  28000 ????		23 47	    var427     =	$2347
    329  28000 ????		23 48	    var428     =	$2348
    330  28000 ????		23 49	    var429     =	$2349
    331  28000 ????		23 4a	    var430     =	$234A
    332  28000 ????		23 4b	    var431     =	$234B
    333  28000 ????		23 4c	    var432     =	$234C
    334  28000 ????		23 4d	    var433     =	$234D
    335  28000 ????		23 4e	    var434     =	$234E
    336  28000 ????		23 4f	    var435     =	$234F
    337  28000 ????		23 50	    var436     =	$2350
    338  28000 ????		23 51	    var437     =	$2351
    339  28000 ????		23 52	    var438     =	$2352
    340  28000 ????		23 53	    var439     =	$2353
    341  28000 ????		23 54	    var440     =	$2354
    342  28000 ????		23 55	    var441     =	$2355
    343  28000 ????		23 56	    var442     =	$2356
    344  28000 ????		23 57	    var443     =	$2357
    345  28000 ????		23 58	    var444     =	$2358
    346  28000 ????		23 59	    var445     =	$2359
    347  28000 ????		23 5a	    var446     =	$235A
    348  28000 ????		23 5b	    var447     =	$235B
    349  28000 ????		23 5c	    var448     =	$235C
    350  28000 ????		23 5d	    var449     =	$235D
    351  28000 ????		23 5e	    var450     =	$235E
    352  28000 ????		23 5f	    var451     =	$235F
    353  28000 ????		23 60	    var452     =	$2360
    354  28000 ????		23 61	    var453     =	$2361
    355  28000 ????		23 62	    var454     =	$2362
    356  28000 ????		23 63	    var455     =	$2363
    357  28000 ????		23 64	    var456     =	$2364
    358  28000 ????		23 65	    var457     =	$2365
    359  28000 ????		23 66	    var458     =	$2366
    360  28000 ????		23 67	    var459     =	$2367
    361  28000 ????		23 68	    var460     =	$2368
    362  28000 ????		23 69	    var461     =	$2369
    363  28000 ????		23 6a	    var462     =	$236A
    364  28000 ????		23 6b	    var463     =	$236B
    365  28000 ????		23 6c	    var464     =	$236C
    366  28000 ????		23 6d	    var465     =	$236D
    367  28000 ????		23 6e	    var466     =	$236E
    368  28000 ????		23 6f	    var467     =	$236F
    369  28000 ????		23 70	    var468     =	$2370
    370  28000 ????		23 71	    var469     =	$2371
    371  28000 ????		23 72	    var470     =	$2372
    372  28000 ????		23 73	    var471     =	$2373
    373  28000 ????		23 74	    var472     =	$2374
    374  28000 ????		23 75	    var473     =	$2375
    375  28000 ????		23 76	    var474     =	$2376
    376  28000 ????		23 77	    var475     =	$2377
    377  28000 ????		23 78	    var476     =	$2378
    378  28000 ????		23 79	    var477     =	$2379
    379  28000 ????		23 7a	    var478     =	$237A
    380  28000 ????		23 7b	    var479     =	$237B
    381  28000 ????		23 7c	    var480     =	$237C
    382  28000 ????		23 7d	    var481     =	$237D
    383  28000 ????		23 7e	    var482     =	$237E
    384  28000 ????		23 7f	    var483     =	$237F
    385  28000 ????		23 80	    var484     =	$2380
    386  28000 ????		23 81	    var485     =	$2381
    387  28000 ????		23 82	    var486     =	$2382
    388  28000 ????		23 83	    var487     =	$2383
    389  28000 ????		23 84	    var488     =	$2384
    390  28000 ????		23 85	    var489     =	$2385
    391  28000 ????		23 86	    var490     =	$2386
    392  28000 ????		23 87	    var491     =	$2387
    393  28000 ????		23 88	    var492     =	$2388
    394  28000 ????		23 89	    var493     =	$2389
    395  28000 ????		23 8a	    var494     =	$238A
    396  28000 ????		23 8b	    var495     =	$238B
    397  28000 ????		23 8c	    var496     =	$238C
    398  28000 ????		23 8d	    var497     =	$238D
    399  28000 ????		23 8e	    var498     =	$238E
    400  28000 ????		23 8f	    var499     =	$238F
    401  28000 ????		23 90	    var500     =	$2390
    402  28000 ????		23 91	    var501     =	$2391
    403  28000 ????		23 92	    var502     =	$2392
    404  28000 ????		23 93	    var503     =	$2393
    405  28000 ????		23 94	    var504     =	$2394
    406  28000 ????		23 95	    var505     =	$2395
    407  28000 ????		23 96	    var506     =	$2396
    408  28000 ????		23 97	    var507     =	$2397
    409  28000 ????		23 98	    var508     =	$2398
    410  28000 ????		23 99	    var509     =	$2399
    411  28000 ????		23 9a	    var510     =	$239A
    412  28000 ????		23 9b	    var511     =	$239B
    413  28000 ????		23 9c	    var512     =	$239C
    414  28000 ????		23 9d	    var513     =	$239D
    415  28000 ????		23 9e	    var514     =	$239E
    416  28000 ????		23 9f	    var515     =	$239F
    417  28000 ????		23 a0	    var516     =	$23A0
    418  28000 ????		23 a1	    var517     =	$23A1
    419  28000 ????		23 a2	    var518     =	$23A2
    420  28000 ????		23 a3	    var519     =	$23A3
    421  28000 ????		23 a4	    var520     =	$23A4
    422  28000 ????		23 a5	    var521     =	$23A5
    423  28000 ????		23 a6	    var522     =	$23A6
    424  28000 ????		23 a7	    var523     =	$23A7
    425  28000 ????		23 a8	    var524     =	$23A8
    426  28000 ????		23 a9	    var525     =	$23A9
    427  28000 ????		23 aa	    var526     =	$23AA
    428  28000 ????		23 ab	    var527     =	$23AB
    429  28000 ????		23 ac	    var528     =	$23AC
    430  28000 ????		23 ad	    var529     =	$23AD
    431  28000 ????		23 ae	    var530     =	$23AE
    432  28000 ????		23 af	    var531     =	$23AF
    433  28000 ????		23 b0	    var532     =	$23B0
    434  28000 ????		23 b1	    var533     =	$23B1
    435  28000 ????		23 b2	    var534     =	$23B2
    436  28000 ????		23 b3	    var535     =	$23B3
    437  28000 ????		23 b4	    var536     =	$23B4
    438  28000 ????		23 b5	    var537     =	$23B5
    439  28000 ????		23 b6	    var538     =	$23B6
    440  28000 ????		23 b7	    var539     =	$23B7
    441  28000 ????		23 b8	    var540     =	$23B8
    442  28000 ????		23 b9	    var541     =	$23B9
    443  28000 ????		23 ba	    var542     =	$23BA
    444  28000 ????		23 bb	    var543     =	$23BB
    445  28000 ????		23 bc	    var544     =	$23BC
    446  28000 ????		23 bd	    var545     =	$23BD
    447  28000 ????		23 be	    var546     =	$23BE
    448  28000 ????		23 bf	    var547     =	$23BF
    449  28000 ????		23 c0	    var548     =	$23C0
    450  28000 ????		23 c1	    var549     =	$23C1
    451  28000 ????		23 c2	    var550     =	$23C2
    452  28000 ????		23 c3	    var551     =	$23C3
    453  28000 ????		23 c4	    var552     =	$23C4
    454  28000 ????		23 c5	    var553     =	$23C5
    455  28000 ????		23 c6	    var554     =	$23C6
    456  28000 ????		23 c7	    var555     =	$23C7
    457  28000 ????		23 c8	    var556     =	$23C8
    458  28000 ????		23 c9	    var557     =	$23C9
    459  28000 ????		23 ca	    var558     =	$23CA
    460  28000 ????		23 cb	    var559     =	$23CB
    461  28000 ????		23 cc	    var560     =	$23CC
    462  28000 ????		23 cd	    var561     =	$23CD
    463  28000 ????		23 ce	    var562     =	$23CE
    464  28000 ????		23 cf	    var563     =	$23CF
    465  28000 ????		23 d0	    var564     =	$23D0
    466  28000 ????		23 d1	    var565     =	$23D1
    467  28000 ????		23 d2	    var566     =	$23D2
    468  28000 ????		23 d3	    var567     =	$23D3
    469  28000 ????		23 d4	    var568     =	$23D4
    470  28000 ????		23 d5	    var569     =	$23D5
    471  28000 ????		23 d6	    var570     =	$23D6
    472  28000 ????		23 d7	    var571     =	$23D7
    473  28000 ????		23 d8	    var572     =	$23D8
    474  28000 ????		23 d9	    var573     =	$23D9
    475  28000 ????		23 da	    var574     =	$23DA
    476  28000 ????		23 db	    var575     =	$23DB
    477  28000 ????		23 dc	    var576     =	$23DC
    478  28000 ????		23 dd	    var577     =	$23DD
    479  28000 ????		23 de	    var578     =	$23DE
    480  28000 ????		23 df	    var579     =	$23DF
    481  28000 ????		23 e0	    var580     =	$23E0
    482  28000 ????		23 e1	    var581     =	$23E1
    483  28000 ????		23 e2	    var582     =	$23E2
    484  28000 ????		23 e3	    var583     =	$23E3
    485  28000 ????		23 e4	    var584     =	$23E4
    486  28000 ????		23 e5	    var585     =	$23E5
    487  28000 ????		23 e6	    var586     =	$23E6
    488  28000 ????		23 e7	    var587     =	$23E7
    489  28000 ????		23 e8	    var588     =	$23E8
    490  28000 ????		23 e9	    var589     =	$23E9
    491  28000 ????		23 ea	    var590     =	$23EA
    492  28000 ????		23 eb	    var591     =	$23EB
    493  28000 ????		23 ec	    var592     =	$23EC
    494  28000 ????		23 ed	    var593     =	$23ED
    495  28000 ????		23 ee	    var594     =	$23EE
    496  28000 ????		23 ef	    var595     =	$23EF
    497  28000 ????		23 f0	    var596     =	$23F0
    498  28000 ????		23 f1	    var597     =	$23F1
    499  28000 ????		23 f2	    var598     =	$23F2
    500  28000 ????		23 f3	    var599     =	$23F3
    501  28000 ????		23 f4	    var600     =	$23F4
    502  28000 ????		23 f5	    var601     =	$23F5
    503  28000 ????		23 f6	    var602     =	$23F6
    504  28000 ????		23 f7	    var603     =	$23F7
    505  28000 ????		23 f8	    var604     =	$23F8
    506  28000 ????		23 f9	    var605     =	$23F9
    507  28000 ????		23 fa	    var606     =	$23FA
    508  28000 ????		23 fb	    var607     =	$23FB
    509  28000 ????		23 fc	    var608     =	$23FC
    510  28000 ????		23 fd	    var609     =	$23FD
    511  28000 ????		23 fe	    var610     =	$23FE
    512  28000 ????		23 ff	    var611     =	$23FF
    513  28000 ????		24 00	    var612     =	$2400
    514  28000 ????		24 01	    var613     =	$2401
    515  28000 ????		24 02	    var614     =	$2402
    516  28000 ????		24 03	    var615     =	$2403
    517  28000 ????		24 04	    var616     =	$2404
    518  28000 ????		24 05	    var617     =	$2405
    519  28000 ????		24 06	    var618     =	$2406
    520  28000 ????		24 07	    var619     =	$2407
    521  28000 ????		24 08	    var620     =	$2408
    522  28000 ????		24 09	    var621     =	$2409
    523  28000 ????		24 0a	    var622     =	$240A
    524  28000 ????		24 0b	    var623     =	$240B
    525  28000 ????		24 0c	    var624     =	$240C
    526  28000 ????		24 0d	    var625     =	$240D
    527  28000 ????		24 0e	    var626     =	$240E
    528  28000 ????		24 0f	    var627     =	$240F
    529  28000 ????		24 10	    var628     =	$2410
    530  28000 ????		24 11	    var629     =	$2411
    531  28000 ????		24 12	    var630     =	$2412
    532  28000 ????		24 13	    var631     =	$2413
    533  28000 ????		24 14	    var632     =	$2414
    534  28000 ????		24 15	    var633     =	$2415
    535  28000 ????		24 16	    var634     =	$2416
    536  28000 ????		24 17	    var635     =	$2417
    537  28000 ????		24 18	    var636     =	$2418
    538  28000 ????		24 19	    var637     =	$2419
    539  28000 ????		24 1a	    var638     =	$241A
    540  28000 ????		24 1b	    var639     =	$241B
    541  28000 ????		24 1c	    var640     =	$241C
    542  28000 ????		24 1d	    var641     =	$241D
    543  28000 ????		24 1e	    var642     =	$241E
    544  28000 ????		24 1f	    var643     =	$241F
    545  28000 ????		24 20	    var644     =	$2420
    546  28000 ????		24 21	    var645     =	$2421
    547  28000 ????		24 22	    var646     =	$2422
    548  28000 ????		24 23	    var647     =	$2423
    549  28000 ????		24 24	    var648     =	$2424
    550  28000 ????		24 25	    var649     =	$2425
    551  28000 ????		24 26	    var650     =	$2426
    552  28000 ????		24 27	    var651     =	$2427
    553  28000 ????		24 28	    var652     =	$2428
    554  28000 ????		24 29	    var653     =	$2429
    555  28000 ????		24 2a	    var654     =	$242A
    556  28000 ????		24 2b	    var655     =	$242B
    557  28000 ????		24 2c	    var656     =	$242C
    558  28000 ????		24 2d	    var657     =	$242D
    559  28000 ????		24 2e	    var658     =	$242E
    560  28000 ????		24 2f	    var659     =	$242F
    561  28000 ????		24 30	    var660     =	$2430
    562  28000 ????		24 31	    var661     =	$2431
    563  28000 ????		24 32	    var662     =	$2432
    564  28000 ????		24 33	    var663     =	$2433
    565  28000 ????		24 34	    var664     =	$2434
    566  28000 ????		24 35	    var665     =	$2435
    567  28000 ????		24 36	    var666     =	$2436
    568  28000 ????		24 37	    var667     =	$2437
    569  28000 ????		24 38	    var668     =	$2438
    570  28000 ????		24 39	    var669     =	$2439
    571  28000 ????		24 3a	    var670     =	$243A
    572  28000 ????		24 3b	    var671     =	$243B
    573  28000 ????		24 3c	    var672     =	$243C
    574  28000 ????		24 3d	    var673     =	$243D
    575  28000 ????		24 3e	    var674     =	$243E
    576  28000 ????		24 3f	    var675     =	$243F
    577  28000 ????		24 40	    var676     =	$2440
    578  28000 ????		24 41	    var677     =	$2441
    579  28000 ????		24 42	    var678     =	$2442
    580  28000 ????		24 43	    var679     =	$2443
    581  28000 ????		24 44	    var680     =	$2444
    582  28000 ????		24 45	    var681     =	$2445
    583  28000 ????		24 46	    var682     =	$2446
    584  28000 ????		24 47	    var683     =	$2447
    585  28000 ????		24 48	    var684     =	$2448
    586  28000 ????		24 49	    var685     =	$2449
    587  28000 ????		24 4a	    var686     =	$244A
    588  28000 ????		24 4b	    var687     =	$244B
    589  28000 ????		24 4c	    var688     =	$244C
    590  28000 ????		24 4d	    var689     =	$244D
    591  28000 ????		24 4e	    var690     =	$244E
    592  28000 ????		24 4f	    var691     =	$244F
    593  28000 ????		24 50	    var692     =	$2450
    594  28000 ????		24 51	    var693     =	$2451
    595  28000 ????		24 52	    var694     =	$2452
    596  28000 ????		24 53	    var695     =	$2453
    597  28000 ????		24 54	    var696     =	$2454
    598  28000 ????		24 55	    var697     =	$2455
    599  28000 ????		24 56	    var698     =	$2456
    600  28000 ????		24 57	    var699     =	$2457
    601  28000 ????		24 58	    var700     =	$2458
    602  28000 ????		24 59	    var701     =	$2459
    603  28000 ????		24 5a	    var702     =	$245A
    604  28000 ????		24 5b	    var703     =	$245B
    605  28000 ????		24 5c	    var704     =	$245C
    606  28000 ????		24 5d	    var705     =	$245D
    607  28000 ????		24 5e	    var706     =	$245E
    608  28000 ????		24 5f	    var707     =	$245F
    609  28000 ????		24 60	    var708     =	$2460
    610  28000 ????		24 61	    var709     =	$2461
    611  28000 ????		24 62	    var710     =	$2462
    612  28000 ????		24 63	    var711     =	$2463
    613  28000 ????		24 64	    var712     =	$2464
    614  28000 ????		24 65	    var713     =	$2465
    615  28000 ????		24 66	    var714     =	$2466
    616  28000 ????		24 67	    var715     =	$2467
    617  28000 ????		24 68	    var716     =	$2468
    618  28000 ????		24 69	    var717     =	$2469
    619  28000 ????		24 6a	    var718     =	$246A
    620  28000 ????		24 6b	    var719     =	$246B
    621  28000 ????		24 6c	    var720     =	$246C
    622  28000 ????		24 6d	    var721     =	$246D
    623  28000 ????		24 6e	    var722     =	$246E
    624  28000 ????		24 6f	    var723     =	$246F
    625  28000 ????		24 70	    var724     =	$2470
    626  28000 ????		24 71	    var725     =	$2471
    627  28000 ????		24 72	    var726     =	$2472
    628  28000 ????		24 73	    var727     =	$2473
    629  28000 ????		24 74	    var728     =	$2474
    630  28000 ????		24 75	    var729     =	$2475
    631  28000 ????		24 76	    var730     =	$2476
    632  28000 ????		24 77	    var731     =	$2477
    633  28000 ????		24 78	    var732     =	$2478
    634  28000 ????		24 79	    var733     =	$2479
    635  28000 ????		24 7a	    var734     =	$247A
    636  28000 ????		24 7b	    var735     =	$247B
    637  28000 ????		24 7c	    var736     =	$247C
    638  28000 ????		24 7d	    var737     =	$247D
    639  28000 ????		24 7e	    var738     =	$247E
    640  28000 ????		24 7f	    var739     =	$247F
    641  28000 ????		24 80	    var740     =	$2480
    642  28000 ????		24 81	    var741     =	$2481
    643  28000 ????		24 82	    var742     =	$2482
    644  28000 ????		24 83	    var743     =	$2483
    645  28000 ????		24 84	    var744     =	$2484
    646  28000 ????		24 85	    var745     =	$2485
    647  28000 ????		24 86	    var746     =	$2486
    648  28000 ????		24 87	    var747     =	$2487
    649  28000 ????		24 88	    var748     =	$2488
    650  28000 ????		24 89	    var749     =	$2489
    651  28000 ????		24 8a	    var750     =	$248A
    652  28000 ????		24 8b	    var751     =	$248B
    653  28000 ????		24 8c	    var752     =	$248C
    654  28000 ????		24 8d	    var753     =	$248D
    655  28000 ????		24 8e	    var754     =	$248E
    656  28000 ????		24 8f	    var755     =	$248F
    657  28000 ????		24 90	    var756     =	$2490
    658  28000 ????		24 91	    var757     =	$2491
    659  28000 ????		24 92	    var758     =	$2492
    660  28000 ????		24 93	    var759     =	$2493
    661  28000 ????		24 94	    var760     =	$2494
    662  28000 ????		24 95	    var761     =	$2495
    663  28000 ????		24 96	    var762     =	$2496
    664  28000 ????		24 97	    var763     =	$2497
    665  28000 ????		24 98	    var764     =	$2498
    666  28000 ????		24 99	    var765     =	$2499
    667  28000 ????		24 9a	    var766     =	$249A
    668  28000 ????		24 9b	    var767     =	$249B
    669  28000 ????		24 9c	    var768     =	$249C
    670  28000 ????		24 9d	    var769     =	$249D
    671  28000 ????		24 9e	    var770     =	$249E
    672  28000 ????		24 9f	    var771     =	$249F
    673  28000 ????		24 a0	    var772     =	$24A0
    674  28000 ????		24 a1	    var773     =	$24A1
    675  28000 ????		24 a2	    var774     =	$24A2
    676  28000 ????		24 a3	    var775     =	$24A3
    677  28000 ????		24 a4	    var776     =	$24A4
    678  28000 ????		24 a5	    var777     =	$24A5
    679  28000 ????		24 a6	    var778     =	$24A6
    680  28000 ????		24 a7	    var779     =	$24A7
    681  28000 ????		24 a8	    var780     =	$24A8
    682  28000 ????		24 a9	    var781     =	$24A9
    683  28000 ????		24 aa	    var782     =	$24AA
    684  28000 ????		24 ab	    var783     =	$24AB
    685  28000 ????		24 ac	    var784     =	$24AC
    686  28000 ????		24 ad	    var785     =	$24AD
    687  28000 ????		24 ae	    var786     =	$24AE
    688  28000 ????		24 af	    var787     =	$24AF
    689  28000 ????		24 b0	    var788     =	$24B0
    690  28000 ????		24 b1	    var789     =	$24B1
    691  28000 ????		24 b2	    var790     =	$24B2
    692  28000 ????		24 b3	    var791     =	$24B3
    693  28000 ????		24 b4	    var792     =	$24B4
    694  28000 ????		24 b5	    var793     =	$24B5
    695  28000 ????		24 b6	    var794     =	$24B6
    696  28000 ????		24 b7	    var795     =	$24B7
    697  28000 ????		24 b8	    var796     =	$24B8
    698  28000 ????		24 b9	    var797     =	$24B9
    699  28000 ????		24 ba	    var798     =	$24BA
    700  28000 ????		24 bb	    var799     =	$24BB
    701  28000 ????		24 bc	    var800     =	$24BC
    702  28000 ????		24 bd	    var801     =	$24BD
    703  28000 ????		24 be	    var802     =	$24BE
    704  28000 ????		24 bf	    var803     =	$24BF
    705  28000 ????		24 c0	    var804     =	$24C0
    706  28000 ????		24 c1	    var805     =	$24C1
    707  28000 ????		24 c2	    var806     =	$24C2
    708  28000 ????		24 c3	    var807     =	$24C3
    709  28000 ????		24 c4	    var808     =	$24C4
    710  28000 ????		24 c5	    var809     =	$24C5
    711  28000 ????		24 c6	    var810     =	$24C6
    712  28000 ????		24 c7	    var811     =	$24C7
    713  28000 ????		24 c8	    var812     =	$24C8
    714  28000 ????		24 c9	    var813     =	$24C9
    715  28000 ????		24 ca	    var814     =	$24CA
    716  28000 ????		24 cb	    var815     =	$24CB
    717  28000 ????		24 cc	    var816     =	$24CC
    718  28000 ????		24 cd	    var817     =	$24CD
    719  28000 ????		24 ce	    var818     =	$24CE
    720  28000 ????		24 cf	    var819     =	$24CF
    721  28000 ????		24 d0	    var820     =	$24D0
    722  28000 ????		24 d1	    var821     =	$24D1
    723  28000 ????		24 d2	    var822     =	$24D2
    724  28000 ????		24 d3	    var823     =	$24D3
    725  28000 ????		24 d4	    var824     =	$24D4
    726  28000 ????		24 d5	    var825     =	$24D5
    727  28000 ????		24 d6	    var826     =	$24D6
    728  28000 ????		24 d7	    var827     =	$24D7
    729  28000 ????		24 d8	    var828     =	$24D8
    730  28000 ????		24 d9	    var829     =	$24D9
    731  28000 ????		24 da	    var830     =	$24DA
    732  28000 ????		24 db	    var831     =	$24DB
    733  28000 ????		24 dc	    var832     =	$24DC
    734  28000 ????		24 dd	    var833     =	$24DD
    735  28000 ????		24 de	    var834     =	$24DE
    736  28000 ????		24 df	    var835     =	$24DF
    737  28000 ????		24 e0	    var836     =	$24E0
    738  28000 ????		24 e1	    var837     =	$24E1
    739  28000 ????		24 e2	    var838     =	$24E2
    740  28000 ????		24 e3	    var839     =	$24E3
    741  28000 ????		24 e4	    var840     =	$24E4
    742  28000 ????		24 e5	    var841     =	$24E5
    743  28000 ????		24 e6	    var842     =	$24E6
    744  28000 ????		24 e7	    var843     =	$24E7
    745  28000 ????		24 e8	    var844     =	$24E8
    746  28000 ????		24 e9	    var845     =	$24E9
    747  28000 ????		24 ea	    var846     =	$24EA
    748  28000 ????		24 eb	    var847     =	$24EB
    749  28000 ????		24 ec	    var848     =	$24EC
    750  28000 ????		24 ed	    var849     =	$24ED
    751  28000 ????		24 ee	    var850     =	$24EE
    752  28000 ????		24 ef	    var851     =	$24EF
    753  28000 ????		24 f0	    var852     =	$24F0
    754  28000 ????		24 f1	    var853     =	$24F1
    755  28000 ????		24 f2	    var854     =	$24F2
    756  28000 ????		24 f3	    var855     =	$24F3
    757  28000 ????		24 f4	    var856     =	$24F4
    758  28000 ????		24 f5	    var857     =	$24F5
    759  28000 ????		24 f6	    var858     =	$24F6
    760  28000 ????		24 f7	    var859     =	$24F7
    761  28000 ????		24 f8	    var860     =	$24F8
    762  28000 ????		24 f9	    var861     =	$24F9
    763  28000 ????		24 fa	    var862     =	$24FA
    764  28000 ????		24 fb	    var863     =	$24FB
    765  28000 ????		24 fc	    var864     =	$24FC
    766  28000 ????		24 fd	    var865     =	$24FD
    767  28000 ????		24 fe	    var866     =	$24FE
    768  28000 ????		24 ff	    var867     =	$24FF
    769  28000 ????		25 00	    var868     =	$2500
    770  28000 ????		25 01	    var869     =	$2501
    771  28000 ????		25 02	    var870     =	$2502
    772  28000 ????		25 03	    var871     =	$2503
    773  28000 ????		25 04	    var872     =	$2504
    774  28000 ????		25 05	    var873     =	$2505
    775  28000 ????		25 06	    var874     =	$2506
    776  28000 ????		25 07	    var875     =	$2507
    777  28000 ????		25 08	    var876     =	$2508
    778  28000 ????		25 09	    var877     =	$2509
    779  28000 ????		25 0a	    var878     =	$250A
    780  28000 ????		25 0b	    var879     =	$250B
    781  28000 ????		25 0c	    var880     =	$250C
    782  28000 ????		25 0d	    var881     =	$250D
    783  28000 ????		25 0e	    var882     =	$250E
    784  28000 ????		25 0f	    var883     =	$250F
    785  28000 ????		25 10	    var884     =	$2510
    786  28000 ????		25 11	    var885     =	$2511
    787  28000 ????		25 12	    var886     =	$2512
    788  28000 ????		25 13	    var887     =	$2513
    789  28000 ????		25 14	    var888     =	$2514
    790  28000 ????		25 15	    var889     =	$2515
    791  28000 ????		25 16	    var890     =	$2516
    792  28000 ????		25 17	    var891     =	$2517
    793  28000 ????		25 18	    var892     =	$2518
    794  28000 ????		25 19	    var893     =	$2519
    795  28000 ????		25 1a	    var894     =	$251A
    796  28000 ????		25 1b	    var895     =	$251B
    797  28000 ????		25 1c	    var896     =	$251C
    798  28000 ????		25 1d	    var897     =	$251D
    799  28000 ????		25 1e	    var898     =	$251E
    800  28000 ????		25 1f	    var899     =	$251F
    801  28000 ????		25 20	    var900     =	$2520
    802  28000 ????		25 21	    var901     =	$2521
    803  28000 ????		25 22	    var902     =	$2522
    804  28000 ????		25 23	    var903     =	$2523
    805  28000 ????		25 24	    var904     =	$2524
    806  28000 ????		25 25	    var905     =	$2525
    807  28000 ????		25 26	    var906     =	$2526
    808  28000 ????		25 27	    var907     =	$2527
    809  28000 ????		25 28	    var908     =	$2528
    810  28000 ????		25 29	    var909     =	$2529
    811  28000 ????		25 2a	    var910     =	$252A
    812  28000 ????		25 2b	    var911     =	$252B
    813  28000 ????		25 2c	    var912     =	$252C
    814  28000 ????		25 2d	    var913     =	$252D
    815  28000 ????		25 2e	    var914     =	$252E
    816  28000 ????		25 2f	    var915     =	$252F
    817  28000 ????		25 30	    var916     =	$2530
    818  28000 ????		25 31	    var917     =	$2531
    819  28000 ????		25 32	    var918     =	$2532
    820  28000 ????		25 33	    var919     =	$2533
    821  28000 ????		25 34	    var920     =	$2534
    822  28000 ????		25 35	    var921     =	$2535
    823  28000 ????		25 36	    var922     =	$2536
    824  28000 ????		25 37	    var923     =	$2537
    825  28000 ????		25 38	    var924     =	$2538
    826  28000 ????		25 39	    var925     =	$2539
    827  28000 ????		25 3a	    var926     =	$253A
    828  28000 ????		25 3b	    var927     =	$253B
    829  28000 ????		25 3c	    var928     =	$253C
    830  28000 ????		25 3d	    var929     =	$253D
    831  28000 ????		25 3e	    var930     =	$253E
    832  28000 ????		25 3f	    var931     =	$253F
    833  28000 ????		25 40	    var932     =	$2540
    834  28000 ????		25 41	    var933     =	$2541
    835  28000 ????		25 42	    var934     =	$2542
    836  28000 ????		25 43	    var935     =	$2543
    837  28000 ????		25 44	    var936     =	$2544
    838  28000 ????		25 45	    var937     =	$2545
    839  28000 ????		25 46	    var938     =	$2546
    840  28000 ????		25 47	    var939     =	$2547
    841  28000 ????		25 48	    var940     =	$2548
    842  28000 ????		25 49	    var941     =	$2549
    843  28000 ????		25 4a	    var942     =	$254A
    844  28000 ????		25 4b	    var943     =	$254B
    845  28000 ????		25 4c	    var944     =	$254C
    846  28000 ????		25 4d	    var945     =	$254D
    847  28000 ????		25 4e	    var946     =	$254E
    848  28000 ????		25 4f	    var947     =	$254F
    849  28000 ????		25 50	    var948     =	$2550
    850  28000 ????		25 51	    var949     =	$2551
    851  28000 ????		25 52	    var950     =	$2552
    852  28000 ????		25 53	    var951     =	$2553
    853  28000 ????		25 54	    var952     =	$2554
    854  28000 ????		25 55	    var953     =	$2555
    855  28000 ????		25 56	    var954     =	$2556
    856  28000 ????		25 57	    var955     =	$2557
    857  28000 ????		25 58	    var956     =	$2558
    858  28000 ????		25 59	    var957     =	$2559
    859  28000 ????		25 5a	    var958     =	$255A
    860  28000 ????		25 5b	    var959     =	$255B
    861  28000 ????		25 5c	    var960     =	$255C
    862  28000 ????		25 5d	    var961     =	$255D
    863  28000 ????		25 5e	    var962     =	$255E
    864  28000 ????		25 5f	    var963     =	$255F
    865  28000 ????		25 60	    var964     =	$2560
    866  28000 ????		25 61	    var965     =	$2561
    867  28000 ????		25 62	    var966     =	$2562
    868  28000 ????		25 63	    var967     =	$2563
    869  28000 ????		25 64	    var968     =	$2564
    870  28000 ????		25 65	    var969     =	$2565
    871  28000 ????		25 66	    var970     =	$2566
    872  28000 ????		25 67	    var971     =	$2567
    873  28000 ????		25 68	    var972     =	$2568
    874  28000 ????		25 69	    var973     =	$2569
    875  28000 ????		25 6a	    var974     =	$256A
    876  28000 ????		25 6b	    var975     =	$256B
    877  28000 ????		25 6c	    var976     =	$256C
    878  28000 ????		25 6d	    var977     =	$256D
    879  28000 ????		25 6e	    var978     =	$256E
    880  28000 ????		25 6f	    var979     =	$256F
    881  28000 ????		25 70	    var980     =	$2570
    882  28000 ????		25 71	    var981     =	$2571
    883  28000 ????		25 72	    var982     =	$2572
    884  28000 ????		25 73	    var983     =	$2573
    885  28000 ????		25 74	    var984     =	$2574
    886  28000 ????		25 75	    var985     =	$2575
    887  28000 ????		25 76	    var986     =	$2576
    888  28000 ????		25 77	    var987     =	$2577
    889  28000 ????		25 78	    var988     =	$2578
    890  28000 ????		25 79	    var989     =	$2579
    891  28000 ????		25 7a	    var990     =	$257A
    892  28000 ????		25 7b	    var991     =	$257B
    893  28000 ????		25 7c	    var992     =	$257C
    894  28000 ????		25 7d	    var993     =	$257D
    895  28000 ????		25 7e	    var994     =	$257E
    896  28000 ????		25 7f	    var995     =	$257F
    897  28000 ????		25 80	    var996     =	$2580
    898  28000 ????		25 81	    var997     =	$2581
    899  28000 ????		25 82	    var998     =	$2582
    900  28000 ????		25 83	    var999     =	$2583
    901  28000 ????		25 84	    var1000    =	$2584
    902  28000 ????		25 85	    var1001    =	$2585
    903  28000 ????		25 86	    var1002    =	$2586
    904  28000 ????		25 87	    var1003    =	$2587
    905  28000 ????		25 88	    var1004    =	$2588
    906  28000 ????		25 89	    var1005    =	$2589
    907  28000 ????		25 8a	    var1006    =	$258A
    908  28000 ????		25 8b	    var1007    =	$258B
    909  28000 ????		25 8c	    var1008    =	$258C
    910  28000 ????		25 8d	    var1009    =	$258D
    911  28000 ????		25 8e	    var1010    =	$258E
    912  28000 ????		25 8f	    var1011    =	$258F
    913  28000 ????		25 90	    var1012    =	$2590
    914  28000 ????		25 91	    var1013    =	$2591
    915  28000 ????		25 92	    var1014    =	$2592
    916  28000 ????		25 93	    var1015    =	$2593
    917  28000 ????		25 94	    var1016    =	$2594
    918  28000 ????		25 95	    var1017    =	$2595
    919  28000 ????		25 96	    var1018    =	$2596
    920  28000 ????		25 97	    var1019    =	$2597
    921  28000 ????		25 98	    var1020    =	$2598
    922  28000 ????		25 99	    var1021    =	$2599
    923  28000 ????		25 9a	    var1022    =	$259A
    924  28000 ????		25 9b	    var1023    =	$259B
    925  28000 ????		25 9c	    var1024    =	$259C
    926  28000 ????		25 9d	    var1025    =	$259D
    927  28000 ????		25 9e	    var1026    =	$259E
    928  28000 ????		25 9f	    var1027    =	$259F
    929  28000 ????		25 a0	    var1028    =	$25A0
    930  28000 ????		25 a1	    var1029    =	$25A1
    931  28000 ????		25 a2	    var1030    =	$25A2
    932  28000 ????		25 a3	    var1031    =	$25A3
    933  28000 ????		25 a4	    var1032    =	$25A4
    934  28000 ????		25 a5	    var1033    =	$25A5
    935  28000 ????		25 a6	    var1034    =	$25A6
    936  28000 ????		25 a7	    var1035    =	$25A7
    937  28000 ????		25 a8	    var1036    =	$25A8
    938  28000 ????		25 a9	    var1037    =	$25A9
    939  28000 ????		25 aa	    var1038    =	$25AA
    940  28000 ????		25 ab	    var1039    =	$25AB
    941  28000 ????		25 ac	    var1040    =	$25AC
    942  28000 ????		25 ad	    var1041    =	$25AD
    943  28000 ????		25 ae	    var1042    =	$25AE
    944  28000 ????		25 af	    var1043    =	$25AF
    945  28000 ????		25 b0	    var1044    =	$25B0
    946  28000 ????		25 b1	    var1045    =	$25B1
    947  28000 ????		25 b2	    var1046    =	$25B2
    948  28000 ????		25 b3	    var1047    =	$25B3
    949  28000 ????		25 b4	    var1048    =	$25B4
    950  28000 ????		25 b5	    var1049    =	$25B5
    951  28000 ????		25 b6	    var1050    =	$25B6
    952  28000 ????		25 b7	    var1051    =	$25B7
    953  28000 ????		25 b8	    var1052    =	$25B8
    954  28000 ????		25 b9	    var1053    =	$25B9
    955  28000 ????		25 ba	    var1054    =	$25BA
    956  28000 ????		25 bb	    var1055    =	$25BB
    957  28000 ????		25 bc	    var1056    =	$25BC
    958  28000 ????		25 bd	    var1057    =	$25BD
    959  28000 ????		25 be	    var1058    =	$25BE
    960  28000 ????		25 bf	    var1059    =	$25BF
    961  28000 ????		25 c0	    var1060    =	$25C0
    962  28000 ????		25 c1	    var1061    =	$25C1
    963  28000 ????		25 c2	    var1062    =	$25C2
    964  28000 ????		25 c3	    var1063    =	$25C3
    965  28000 ????		25 c4	    var1064    =	$25C4
    966  28000 ????		25 c5	    var1065    =	$25C5
    967  28000 ????		25 c6	    var1066    =	$25C6
    968  28000 ????		25 c7	    var1067    =	$25C7
    969  28000 ????		25 c8	    var1068    =	$25C8
    970  28000 ????		25 c9	    var1069    =	$25C9
    971  28000 ????		25 ca	    var1070    =	$25CA
    972  28000 ????		25 cb	    var1071    =	$25CB
    973  28000 ????		25 cc	    var1072    =	$25CC
    974  28000 ????		25 cd	    var1073    =	$25CD
    975  28000 ????		25 ce	    var1074    =	$25CE
    976  28000 ????		25 cf	    var1075    =	$25CF
    977  28000 ????		25 d0	    var1076    =	$25D0
    978  28000 ????		25 d1	    var1077    =	$25D1
    979  28000 ????		25 d2	    var1078    =	$25D2
    980  28000 ????		25 d3	    var1079    =	$25D3
    981  28000 ????		25 d4	    var1080    =	$25D4
    982  28000 ????		25 d5	    var1081    =	$25D5
    983  28000 ????		25 d6	    var1082    =	$25D6
    984  28000 ????		25 d7	    var1083    =	$25D7
    985  28000 ????		25 d8	    var1084    =	$25D8
    986  28000 ????		25 d9	    var1085    =	$25D9
    987  28000 ????		25 da	    var1086    =	$25DA
    988  28000 ????		25 db	    var1087    =	$25DB
    989  28000 ????		25 dc	    var1088    =	$25DC
    990  28000 ????		25 dd	    var1089    =	$25DD
    991  28000 ????		25 de	    var1090    =	$25DE
    992  28000 ????		25 df	    var1091    =	$25DF
    993  28000 ????		25 e0	    var1092    =	$25E0
    994  28000 ????		25 e1	    var1093    =	$25E1
    995  28000 ????		25 e2	    var1094    =	$25E2
    996  28000 ????		25 e3	    var1095    =	$25E3
    997  28000 ????		25 e4	    var1096    =	$25E4
    998  28000 ????		25 e5	    var1097    =	$25E5
    999  28000 ????		25 e6	    var1098    =	$25E6
   1000  28000 ????		25 e7	    var1099    =	$25E7
   1001  28000 ????		25 e8	    var1100    =	$25E8
   1002  28000 ????		25 e9	    var1101    =	$25E9
   1003  28000 ????		25 ea	    var1102    =	$25EA
   1004  28000 ????		25 eb	    var1103    =	$25EB
   1005  28000 ????		25 ec	    var1104    =	$25EC
   1006  28000 ????		25 ed	    var1105    =	$25ED
   1007  28000 ????		25 ee	    var1106    =	$25EE
   1008  28000 ????		25 ef	    var1107    =	$25EF
   1009  28000 ????		25 f0	    var1108    =	$25F0
   1010  28000 ????		25 f1	    var1109    =	$25F1
   1011  28000 ????		25 f2	    var1110    =	$25F2
   1012  28000 ????		25 f3	    var1111    =	$25F3
   1013  28000 ????		25 f4	    var1112    =	$25F4
   1014  28000 ????		25 f5	    var1113    =	$25F5
   1015  28000 ????		25 f6	    var1114    =	$25F6
   1016  28000 ????		25 f7	    var1115    =	$25F7
   1017  28000 ????		25 f8	    var1116    =	$25F8
   1018  28000 ????		25 f9	    var1117    =	$25F9
   1019  28000 ????		25 fa	    var1118    =	$25FA
   1020  28000 ????		25 fb	    var1119    =	$25FB
   1021  28000 ????		25 fc	    var1120    =	$25FC
   1022  28000 ????		25 fd	    var1121    =	$25FD
   1023  28000 ????		25 fe	    var1122    =	$25FE
   1024  28000 ????		25 ff	    var1123    =	$25FF
   1025  28000 ????		26 00	    var1124    =	$2600
   1026  28000 ????		26 01	    var1125    =	$2601
   1027  28000 ????		26 02	    var1126    =	$2602
   1028  28000 ????		26 03	    var1127    =	$2603
   1029  28000 ????		26 04	    var1128    =	$2604
   1030  28000 ????		26 05	    var1129    =	$2605
   1031  28000 ????		26 06	    var1130    =	$2606
   1032  28000 ????		26 07	    var1131    =	$2607
   1033  28000 ????		26 08	    var1132    =	$2608
   1034  28000 ????		26 09	    var1133    =	$2609
   1035  28000 ????		26 0a	    var1134    =	$260A
   1036  28000 ????		26 0b	    var1135    =	$260B
   1037  28000 ????		26 0c	    var1136    =	$260C
   1038  28000 ????		26 0d	    var1137    =	$260D
   1039  28000 ????		26 0e	    var1138    =	$260E
   1040  28000 ????		26 0f	    var1139    =	$260F
   1041  28000 ????		26 10	    var1140    =	$2610
   1042  28000 ????		26 11	    var1141    =	$2611
   1043  28000 ????		26 12	    var1142    =	$2612
   1044  28000 ????		26 13	    var1143    =	$2613
   1045  28000 ????		26 14	    var1144    =	$2614
   1046  28000 ????		26 15	    var1145    =	$2615
   1047  28000 ????		26 16	    var1146    =	$2616
   1048  28000 ????		26 17	    var1147    =	$2617
   1049  28000 ????		26 18	    var1148    =	$2618
   1050  28000 ????		26 19	    var1149    =	$2619
   1051  28000 ????		26 1a	    var1150    =	$261A
   1052  28000 ????		26 1b	    var1151    =	$261B
   1053  28000 ????		26 1c	    var1152    =	$261C
   1054  28000 ????		26 1d	    var1153    =	$261D
   1055  28000 ????		26 1e	    var1154    =	$261E
   1056  28000 ????		26 1f	    var1155    =	$261F
   1057  28000 ????		26 20	    var1156    =	$2620
   1058  28000 ????		26 21	    var1157    =	$2621
   1059  28000 ????		26 22	    var1158    =	$2622
   1060  28000 ????		26 23	    var1159    =	$2623
   1061  28000 ????		26 24	    var1160    =	$2624
   1062  28000 ????		26 25	    var1161    =	$2625
   1063  28000 ????		26 26	    var1162    =	$2626
   1064  28000 ????		26 27	    var1163    =	$2627
   1065  28000 ????		26 28	    var1164    =	$2628
   1066  28000 ????		26 29	    var1165    =	$2629
   1067  28000 ????		26 2a	    var1166    =	$262A
   1068  28000 ????		26 2b	    var1167    =	$262B
   1069  28000 ????		26 2c	    var1168    =	$262C
   1070  28000 ????		26 2d	    var1169    =	$262D
   1071  28000 ????		26 2e	    var1170    =	$262E
   1072  28000 ????		26 2f	    var1171    =	$262F
   1073  28000 ????		26 30	    var1172    =	$2630
   1074  28000 ????		26 31	    var1173    =	$2631
   1075  28000 ????		26 32	    var1174    =	$2632
   1076  28000 ????		26 33	    var1175    =	$2633
   1077  28000 ????		26 34	    var1176    =	$2634
   1078  28000 ????		26 35	    var1177    =	$2635
   1079  28000 ????		26 36	    var1178    =	$2636
   1080  28000 ????		26 37	    var1179    =	$2637
   1081  28000 ????		26 38	    var1180    =	$2638
   1082  28000 ????		26 39	    var1181    =	$2639
   1083  28000 ????		26 3a	    var1182    =	$263A
   1084  28000 ????		26 3b	    var1183    =	$263B
   1085  28000 ????		26 3c	    var1184    =	$263C
   1086  28000 ????		26 3d	    var1185    =	$263D
   1087  28000 ????		26 3e	    var1186    =	$263E
   1088  28000 ????		26 3f	    var1187    =	$263F
   1089  28000 ????		26 40	    var1188    =	$2640
   1090  28000 ????		26 41	    var1189    =	$2641
   1091  28000 ????		26 42	    var1190    =	$2642
   1092  28000 ????		26 43	    var1191    =	$2643
   1093  28000 ????		26 44	    var1192    =	$2644
   1094  28000 ????		26 45	    var1193    =	$2645
   1095  28000 ????		26 46	    var1194    =	$2646
   1096  28000 ????		26 47	    var1195    =	$2647
   1097  28000 ????		26 48	    var1196    =	$2648
   1098  28000 ????		26 49	    var1197    =	$2649
   1099  28000 ????		26 4a	    var1198    =	$264A
   1100  28000 ????		26 4b	    var1199    =	$264B
   1101  28000 ????		26 4c	    var1200    =	$264C
   1102  28000 ????		26 4d	    var1201    =	$264D
   1103  28000 ????		26 4e	    var1202    =	$264E
   1104  28000 ????		26 4f	    var1203    =	$264F
   1105  28000 ????		26 50	    var1204    =	$2650
   1106  28000 ????		26 51	    var1205    =	$2651
   1107  28000 ????		26 52	    var1206    =	$2652
   1108  28000 ????		26 53	    var1207    =	$2653
   1109  28000 ????		26 54	    var1208    =	$2654
   1110  28000 ????		26 55	    var1209    =	$2655
   1111  28000 ????		26 56	    var1210    =	$2656
   1112  28000 ????		26 57	    var1211    =	$2657
   1113  28000 ????		26 58	    var1212    =	$2658
   1114  28000 ????		26 59	    var1213    =	$2659
   1115  28000 ????		26 5a	    var1214    =	$265A
   1116  28000 ????		26 5b	    var1215    =	$265B
   1117  28000 ????		26 5c	    var1216    =	$265C
   1118  28000 ????		26 5d	    var1217    =	$265D
   1119  28000 ????		26 5e	    var1218    =	$265E
   1120  28000 ????		26 5f	    var1219    =	$265F
   1121  28000 ????		26 60	    var1220    =	$2660
   1122  28000 ????		26 61	    var1221    =	$2661
   1123  28000 ????		26 62	    var1222    =	$2662
   1124  28000 ????		26 63	    var1223    =	$2663
   1125  28000 ????		26 64	    var1224    =	$2664
   1126  28000 ????		26 65	    var1225    =	$2665
   1127  28000 ????		26 66	    var1226    =	$2666
   1128  28000 ????		26 67	    var1227    =	$2667
   1129  28000 ????		26 68	    var1228    =	$2668
   1130  28000 ????		26 69	    var1229    =	$2669
   1131  28000 ????		26 6a	    var1230    =	$266A
   1132  28000 ????		26 6b	    var1231    =	$266B
   1133  28000 ????		26 6c	    var1232    =	$266C
   1134  28000 ????		26 6d	    var1233    =	$266D
   1135  28000 ????		26 6e	    var1234    =	$266E
   1136  28000 ????		26 6f	    var1235    =	$266F
   1137  28000 ????		26 70	    var1236    =	$2670
   1138  28000 ????		26 71	    var1237    =	$2671
   1139  28000 ????		26 72	    var1238    =	$2672
   1140  28000 ????		26 73	    var1239    =	$2673
   1141  28000 ????		26 74	    var1240    =	$2674
   1142  28000 ????		26 75	    var1241    =	$2675
   1143  28000 ????		26 76	    var1242    =	$2676
   1144  28000 ????		26 77	    var1243    =	$2677
   1145  28000 ????		26 78	    var1244    =	$2678
   1146  28000 ????		26 79	    var1245    =	$2679
   1147  28000 ????		26 7a	    var1246    =	$267A
   1148  28000 ????		26 7b	    var1247    =	$267B
   1149  28000 ????		26 7c	    var1248    =	$267C
   1150  28000 ????		26 7d	    var1249    =	$267D
   1151  28000 ????		26 7e	    var1250    =	$267E
   1152  28000 ????		26 7f	    var1251    =	$267F
   1153  28000 ????		26 80	    var1252    =	$2680
   1154  28000 ????		26 81	    var1253    =	$2681
   1155  28000 ????		26 82	    var1254    =	$2682
   1156  28000 ????		26 83	    var1255    =	$2683
   1157  28000 ????		26 84	    var1256    =	$2684
   1158  28000 ????		26 85	    var1257    =	$2685
   1159  28000 ????		26 86	    var1258    =	$2686
   1160  28000 ????		26 87	    var1259    =	$2687
   1161  28000 ????		26 88	    var1260    =	$2688
   1162  28000 ????		26 89	    var1261    =	$2689
   1163  28000 ????		26 8a	    var1262    =	$268A
   1164  28000 ????		26 8b	    var1263    =	$268B
   1165  28000 ????		26 8c	    var1264    =	$268C
   1166  28000 ????		26 8d	    var1265    =	$268D
   1167  28000 ????		26 8e	    var1266    =	$268E
   1168  28000 ????		26 8f	    var1267    =	$268F
   1169  28000 ????		26 90	    var1268    =	$2690
   1170  28000 ????		26 91	    var1269    =	$2691
   1171  28000 ????		26 92	    var1270    =	$2692
   1172  28000 ????		26 93	    var1271    =	$2693
   1173  28000 ????		26 94	    var1272    =	$2694
   1174  28000 ????		26 95	    var1273    =	$2695
   1175  28000 ????		26 96	    var1274    =	$2696
   1176  28000 ????		26 97	    var1275    =	$2697
   1177  28000 ????		26 98	    var1276    =	$2698
   1178  28000 ????		26 99	    var1277    =	$2699
   1179  28000 ????		26 9a	    var1278    =	$269A
   1180  28000 ????		26 9b	    var1279    =	$269B
   1181  28000 ????		26 9c	    var1280    =	$269C
   1182  28000 ????		26 9d	    var1281    =	$269D
   1183  28000 ????		26 9e	    var1282    =	$269E
   1184  28000 ????		26 9f	    var1283    =	$269F
   1185  28000 ????		26 a0	    var1284    =	$26A0
   1186  28000 ????		26 a1	    var1285    =	$26A1
   1187  28000 ????		26 a2	    var1286    =	$26A2
   1188  28000 ????		26 a3	    var1287    =	$26A3
   1189  28000 ????		26 a4	    var1288    =	$26A4
   1190  28000 ????		26 a5	    var1289    =	$26A5
   1191  28000 ????		26 a6	    var1290    =	$26A6
   1192  28000 ????		26 a7	    var1291    =	$26A7
   1193  28000 ????		26 a8	    var1292    =	$26A8
   1194  28000 ????		26 a9	    var1293    =	$26A9
   1195  28000 ????		26 aa	    var1294    =	$26AA
   1196  28000 ????		26 ab	    var1295    =	$26AB
   1197  28000 ????		26 ac	    var1296    =	$26AC
   1198  28000 ????		26 ad	    var1297    =	$26AD
   1199  28000 ????		26 ae	    var1298    =	$26AE
   1200  28000 ????		26 af	    var1299    =	$26AF
   1201  28000 ????		26 b0	    var1300    =	$26B0
   1202  28000 ????		26 b1	    var1301    =	$26B1
   1203  28000 ????		26 b2	    var1302    =	$26B2
   1204  28000 ????		26 b3	    var1303    =	$26B3
   1205  28000 ????		26 b4	    var1304    =	$26B4
   1206  28000 ????		26 b5	    var1305    =	$26B5
   1207  28000 ????		26 b6	    var1306    =	$26B6
   1208  28000 ????		26 b7	    var1307    =	$26B7
   1209  28000 ????		26 b8	    var1308    =	$26B8
   1210  28000 ????		26 b9	    var1309    =	$26B9
   1211  28000 ????		26 ba	    var1310    =	$26BA
   1212  28000 ????		26 bb	    var1311    =	$26BB
   1213  28000 ????		26 bc	    var1312    =	$26BC
   1214  28000 ????		26 bd	    var1313    =	$26BD
   1215  28000 ????		26 be	    var1314    =	$26BE
   1216  28000 ????		26 bf	    var1315    =	$26BF
   1217  28000 ????		26 c0	    var1316    =	$26C0
   1218  28000 ????		26 c1	    var1317    =	$26C1
   1219  28000 ????		26 c2	    var1318    =	$26C2
   1220  28000 ????		26 c3	    var1319    =	$26C3
   1221  28000 ????		26 c4	    var1320    =	$26C4
   1222  28000 ????		26 c5	    var1321    =	$26C5
   1223  28000 ????		26 c6	    var1322    =	$26C6
   1224  28000 ????		26 c7	    var1323    =	$26C7
   1225  28000 ????		26 c8	    var1324    =	$26C8
   1226  28000 ????		26 c9	    var1325    =	$26C9
   1227  28000 ????		26 ca	    var1326    =	$26CA
   1228  28000 ????		26 cb	    var1327    =	$26CB
   1229  28000 ????		26 cc	    var1328    =	$26CC
   1230  28000 ????		26 cd	    var1329    =	$26CD
   1231  28000 ????		26 ce	    var1330    =	$26CE
   1232  28000 ????		26 cf	    var1331    =	$26CF
   1233  28000 ????		26 d0	    var1332    =	$26D0
   1234  28000 ????		26 d1	    var1333    =	$26D1
   1235  28000 ????		26 d2	    var1334    =	$26D2
   1236  28000 ????		26 d3	    var1335    =	$26D3
   1237  28000 ????		26 d4	    var1336    =	$26D4
   1238  28000 ????		26 d5	    var1337    =	$26D5
   1239  28000 ????		26 d6	    var1338    =	$26D6
   1240  28000 ????		26 d7	    var1339    =	$26D7
   1241  28000 ????		26 d8	    var1340    =	$26D8
   1242  28000 ????		26 d9	    var1341    =	$26D9
   1243  28000 ????		26 da	    var1342    =	$26DA
   1244  28000 ????		26 db	    var1343    =	$26DB
   1245  28000 ????		26 dc	    var1344    =	$26DC
   1246  28000 ????		26 dd	    var1345    =	$26DD
   1247  28000 ????		26 de	    var1346    =	$26DE
   1248  28000 ????		26 df	    var1347    =	$26DF
   1249  28000 ????		26 e0	    var1348    =	$26E0
   1250  28000 ????		26 e1	    var1349    =	$26E1
   1251  28000 ????		26 e2	    var1350    =	$26E2
   1252  28000 ????		26 e3	    var1351    =	$26E3
   1253  28000 ????		26 e4	    var1352    =	$26E4
   1254  28000 ????		26 e5	    var1353    =	$26E5
   1255  28000 ????		26 e6	    var1354    =	$26E6
   1256  28000 ????		26 e7	    var1355    =	$26E7
   1257  28000 ????		26 e8	    var1356    =	$26E8
   1258  28000 ????		26 e9	    var1357    =	$26E9
   1259  28000 ????		26 ea	    var1358    =	$26EA
   1260  28000 ????		26 eb	    var1359    =	$26EB
   1261  28000 ????		26 ec	    var1360    =	$26EC
   1262  28000 ????		26 ed	    var1361    =	$26ED
   1263  28000 ????		26 ee	    var1362    =	$26EE
   1264  28000 ????		26 ef	    var1363    =	$26EF
   1265  28000 ????		26 f0	    var1364    =	$26F0
   1266  28000 ????		26 f1	    var1365    =	$26F1
   1267  28000 ????		26 f2	    var1366    =	$26F2
   1268  28000 ????		26 f3	    var1367    =	$26F3
   1269  28000 ????		26 f4	    var1368    =	$26F4
   1270  28000 ????		26 f5	    var1369    =	$26F5
   1271  28000 ????		26 f6	    var1370    =	$26F6
   1272  28000 ????		26 f7	    var1371    =	$26F7
   1273  28000 ????		26 f8	    var1372    =	$26F8
   1274  28000 ????		26 f9	    var1373    =	$26F9
   1275  28000 ????		26 fa	    var1374    =	$26FA
   1276  28000 ????		26 fb	    var1375    =	$26FB
   1277  28000 ????		26 fc	    var1376    =	$26FC
   1278  28000 ????		26 fd	    var1377    =	$26FD
   1279  28000 ????		26 fe	    var1378    =	$26FE
   1280  28000 ????		26 ff	    var1379    =	$26FF
   1281  28000 ????		27 00	    var1380    =	$2700
   1282  28000 ????		27 01	    var1381    =	$2701
   1283  28000 ????		27 02	    var1382    =	$2702
   1284  28000 ????		27 03	    var1383    =	$2703
   1285  28000 ????		27 04	    var1384    =	$2704
   1286  28000 ????		27 05	    var1385    =	$2705
   1287  28000 ????		27 06	    var1386    =	$2706
   1288  28000 ????		27 07	    var1387    =	$2707
   1289  28000 ????		27 08	    var1388    =	$2708
   1290  28000 ????		27 09	    var1389    =	$2709
   1291  28000 ????		27 0a	    var1390    =	$270A
   1292  28000 ????		27 0b	    var1391    =	$270B
   1293  28000 ????		27 0c	    var1392    =	$270C
   1294  28000 ????		27 0d	    var1393    =	$270D
   1295  28000 ????		27 0e	    var1394    =	$270E
   1296  28000 ????		27 0f	    var1395    =	$270F
   1297  28000 ????		27 10	    var1396    =	$2710
   1298  28000 ????		27 11	    var1397    =	$2711
   1299  28000 ????		27 12	    var1398    =	$2712
   1300  28000 ????		27 13	    var1399    =	$2713
   1301  28000 ????		27 14	    var1400    =	$2714
   1302  28000 ????		27 15	    var1401    =	$2715
   1303  28000 ????		27 16	    var1402    =	$2716
   1304  28000 ????		27 17	    var1403    =	$2717
   1305  28000 ????		27 18	    var1404    =	$2718
   1306  28000 ????		27 19	    var1405    =	$2719
   1307  28000 ????		27 1a	    var1406    =	$271A
   1308  28000 ????		27 1b	    var1407    =	$271B
   1309  28000 ????		27 1c	    var1408    =	$271C
   1310  28000 ????		27 1d	    var1409    =	$271D
   1311  28000 ????		27 1e	    var1410    =	$271E
   1312  28000 ????		27 1f	    var1411    =	$271F
   1313  28000 ????		27 20	    var1412    =	$2720
   1314  28000 ????		27 21	    var1413    =	$2721
   1315  28000 ????		27 22	    var1414    =	$2722
   1316  28000 ????		27 23	    var1415    =	$2723
   1317  28000 ????		27 24	    var1416    =	$2724
   1318  28000 ????		27 25	    var1417    =	$2725
   1319  28000 ????		27 26	    var1418    =	$2726
   1320  28000 ????		27 27	    var1419    =	$2727
   1321  28000 ????		27 28	    var1420    =	$2728
   1322  28000 ????		27 29	    var1421    =	$2729
   1323  28000 ????		27 2a	    var1422    =	$272A
   1324  28000 ????		27 2b	    var1423    =	$272B
   1325  28000 ????		27 2c	    var1424    =	$272C
   1326  28000 ????		27 2d	    var1425    =	$272D
   1327  28000 ????		27 2e	    var1426    =	$272E
   1328  28000 ????		27 2f	    var1427    =	$272F
   1329  28000 ????		27 30	    var1428    =	$2730
   1330  28000 ????		27 31	    var1429    =	$2731
   1331  28000 ????		27 32	    var1430    =	$2732
   1332  28000 ????		27 33	    var1431    =	$2733
   1333  28000 ????		27 34	    var1432    =	$2734
   1334  28000 ????		27 35	    var1433    =	$2735
   1335  28000 ????		27 36	    var1434    =	$2736
   1336  28000 ????		27 37	    var1435    =	$2737
   1337  28000 ????		27 38	    var1436    =	$2738
   1338  28000 ????		27 39	    var1437    =	$2739
   1339  28000 ????		27 3a	    var1438    =	$273A
   1340  28000 ????		27 3b	    var1439    =	$273B
   1341  28000 ????		27 3c	    var1440    =	$273C
   1342  28000 ????		27 3d	    var1441    =	$273D
   1343  28000 ????		27 3e	    var1442    =	$273E
   1344  28000 ????		27 3f	    var1443    =	$273F
   1345  28000 ????		27 40	    var1444    =	$2740
   1346  28000 ????		27 41	    var1445    =	$2741
   1347  28000 ????		27 42	    var1446    =	$2742
   1348  28000 ????		27 43	    var1447    =	$2743
   1349  28000 ????		27 44	    var1448    =	$2744
   1350  28000 ????		27 45	    var1449    =	$2745
   1351  28000 ????		27 46	    var1450    =	$2746
   1352  28000 ????		27 47	    var1451    =	$2747
   1353  28000 ????		27 48	    var1452    =	$2748
   1354  28000 ????		27 49	    var1453    =	$2749
   1355  28000 ????		27 4a	    var1454    =	$274A
   1356  28000 ????		27 4b	    var1455    =	$274B
   1357  28000 ????		27 4c	    var1456    =	$274C
   1358  28000 ????		27 4d	    var1457    =	$274D
   1359  28000 ????		27 4e	    var1458    =	$274E
   1360  28000 ????		27 4f	    var1459    =	$274F
   1361  28000 ????		27 50	    var1460    =	$2750
   1362  28000 ????		27 51	    var1461    =	$2751
   1363  28000 ????		27 52	    var1462    =	$2752
   1364  28000 ????		27 53	    var1463    =	$2753
   1365  28000 ????		27 54	    var1464    =	$2754
   1366  28000 ????		27 55	    var1465    =	$2755
   1367  28000 ????		27 56	    var1466    =	$2756
   1368  28000 ????		27 57	    var1467    =	$2757
   1369  28000 ????		27 58	    var1468    =	$2758
   1370  28000 ????		27 59	    var1469    =	$2759
   1371  28000 ????		27 5a	    var1470    =	$275A
   1372  28000 ????		27 5b	    var1471    =	$275B
   1373  28000 ????		27 5c	    var1472    =	$275C
   1374  28000 ????		27 5d	    var1473    =	$275D
   1375  28000 ????		27 5e	    var1474    =	$275E
   1376  28000 ????		27 5f	    var1475    =	$275F
   1377  28000 ????		27 60	    var1476    =	$2760
   1378  28000 ????		27 61	    var1477    =	$2761
   1379  28000 ????		27 62	    var1478    =	$2762
   1380  28000 ????		27 63	    var1479    =	$2763
   1381  28000 ????		27 64	    var1480    =	$2764
   1382  28000 ????		27 65	    var1481    =	$2765
   1383  28000 ????		27 66	    var1482    =	$2766
   1384  28000 ????		27 67	    var1483    =	$2767
   1385  28000 ????		27 68	    var1484    =	$2768
   1386  28000 ????		27 69	    var1485    =	$2769
   1387  28000 ????		27 6a	    var1486    =	$276A
   1388  28000 ????		27 6b	    var1487    =	$276B
   1389  28000 ????		27 6c	    var1488    =	$276C
   1390  28000 ????		27 6d	    var1489    =	$276D
   1391  28000 ????		27 6e	    var1490    =	$276E
   1392  28000 ????		27 6f	    var1491    =	$276F
   1393  28000 ????		27 70	    var1492    =	$2770
   1394  28000 ????		27 71	    var1493    =	$2771
   1395  28000 ????		27 72	    var1494    =	$2772
   1396  28000 ????		27 73	    var1495    =	$2773
   1397  28000 ????		27 74	    var1496    =	$2774
   1398  28000 ????		27 75	    var1497    =	$2775
   1399  28000 ????		27 76	    var1498    =	$2776
   1400  28000 ????		27 77	    var1499    =	$2777
   1401  28000 ????		27 78	    var1500    =	$2778
   1402  28000 ????		27 79	    var1501    =	$2779
   1403  28000 ????		27 7a	    var1502    =	$277A
   1404  28000 ????		27 7b	    var1503    =	$277B
   1405  28000 ????		27 7c	    var1504    =	$277C
   1406  28000 ????		27 7d	    var1505    =	$277D
   1407  28000 ????		27 7e	    var1506    =	$277E
   1408  28000 ????		27 7f	    var1507    =	$277F
   1409  28000 ????		27 80	    var1508    =	$2780
   1410  28000 ????		27 81	    var1509    =	$2781
   1411  28000 ????		27 82	    var1510    =	$2782
   1412  28000 ????		27 83	    var1511    =	$2783
   1413  28000 ????		27 84	    var1512    =	$2784
   1414  28000 ????		27 85	    var1513    =	$2785
   1415  28000 ????		27 86	    var1514    =	$2786
   1416  28000 ????		27 87	    var1515    =	$2787
   1417  28000 ????		27 88	    var1516    =	$2788
   1418  28000 ????		27 89	    var1517    =	$2789
   1419  28000 ????		27 8a	    var1518    =	$278A
   1420  28000 ????		27 8b	    var1519    =	$278B
   1421  28000 ????		27 8c	    var1520    =	$278C
   1422  28000 ????		27 8d	    var1521    =	$278D
   1423  28000 ????		27 8e	    var1522    =	$278E
   1424  28000 ????		27 8f	    var1523    =	$278F
   1425  28000 ????		27 90	    var1524    =	$2790
   1426  28000 ????		27 91	    var1525    =	$2791
   1427  28000 ????		27 92	    var1526    =	$2792
   1428  28000 ????		27 93	    var1527    =	$2793
   1429  28000 ????		27 94	    var1528    =	$2794
   1430  28000 ????		27 95	    var1529    =	$2795
   1431  28000 ????		27 96	    var1530    =	$2796
   1432  28000 ????		27 97	    var1531    =	$2797
   1433  28000 ????		27 98	    var1532    =	$2798
   1434  28000 ????		27 99	    var1533    =	$2799
   1435  28000 ????		27 9a	    var1534    =	$279A
   1436  28000 ????		27 9b	    var1535    =	$279B
   1437  28000 ????		27 9c	    var1536    =	$279C
   1438  28000 ????		27 9d	    var1537    =	$279D
   1439  28000 ????		27 9e	    var1538    =	$279E
   1440  28000 ????		27 9f	    var1539    =	$279F
   1441  28000 ????		27 a0	    var1540    =	$27A0
   1442  28000 ????		27 a1	    var1541    =	$27A1
   1443  28000 ????		27 a2	    var1542    =	$27A2
   1444  28000 ????		27 a3	    var1543    =	$27A3
   1445  28000 ????		27 a4	    var1544    =	$27A4
   1446  28000 ????		27 a5	    var1545    =	$27A5
   1447  28000 ????		27 a6	    var1546    =	$27A6
   1448  28000 ????		27 a7	    var1547    =	$27A7
   1449  28000 ????		27 a8	    var1548    =	$27A8
   1450  28000 ????		27 a9	    var1549    =	$27A9
   1451  28000 ????		27 aa	    var1550    =	$27AA
   1452  28000 ????		27 ab	    var1551    =	$27AB
   1453  28000 ????		27 ac	    var1552    =	$27AC
   1454  28000 ????		27 ad	    var1553    =	$27AD
   1455  28000 ????		27 ae	    var1554    =	$27AE
   1456  28000 ????		27 af	    var1555    =	$27AF
   1457  28000 ????		27 b0	    var1556    =	$27B0
   1458  28000 ????		27 b1	    var1557    =	$27B1
   1459  28000 ????		27 b2	    var1558    =	$27B2
   1460  28000 ????		27 b3	    var1559    =	$27B3
   1461  28000 ????		27 b4	    var1560    =	$27B4
   1462  28000 ????		27 b5	    var1561    =	$27B5
   1463  28000 ????		27 b6	    var1562    =	$27B6
   1464  28000 ????		27 b7	    var1563    =	$27B7
   1465  28000 ????		27 b8	    var1564    =	$27B8
   1466  28000 ????		27 b9	    var1565    =	$27B9
   1467  28000 ????		27 ba	    var1566    =	$27BA
   1468  28000 ????		27 bb	    var1567    =	$27BB
   1469  28000 ????		27 bc	    var1568    =	$27BC
   1470  28000 ????		27 bd	    var1569    =	$27BD
   1471  28000 ????		27 be	    var1570    =	$27BE
   1472  28000 ????		27 bf	    var1571    =	$27BF
   1473  28000 ????		27 c0	    var1572    =	$27C0
   1474  28000 ????		27 c1	    var1573    =	$27C1
   1475  28000 ????		27 c2	    var1574    =	$27C2
   1476  28000 ????		27 c3	    var1575    =	$27C3
   1477  28000 ????		27 c4	    var1576    =	$27C4
   1478  28000 ????		27 c5	    var1577    =	$27C5
   1479  28000 ????		27 c6	    var1578    =	$27C6
   1480  28000 ????		27 c7	    var1579    =	$27C7
   1481  28000 ????		27 c8	    var1580    =	$27C8
   1482  28000 ????		27 c9	    var1581    =	$27C9
   1483  28000 ????		27 ca	    var1582    =	$27CA
   1484  28000 ????		27 cb	    var1583    =	$27CB
   1485  28000 ????		27 cc	    var1584    =	$27CC
   1486  28000 ????		27 cd	    var1585    =	$27CD
   1487  28000 ????		27 ce	    var1586    =	$27CE
   1488  28000 ????		27 cf	    var1587    =	$27CF
   1489  28000 ????		27 d0	    var1588    =	$27D0
   1490  28000 ????		27 d1	    var1589    =	$27D1
   1491  28000 ????		27 d2	    var1590    =	$27D2
   1492  28000 ????		27 d3	    var1591    =	$27D3
   1493  28000 ????		27 d4	    var1592    =	$27D4
   1494  28000 ????		27 d5	    var1593    =	$27D5
   1495  28000 ????		27 d6	    var1594    =	$27D6
   1496  28000 ????		27 d7	    var1595    =	$27D7
   1497  28000 ????		27 d8	    var1596    =	$27D8
   1498  28000 ????		27 d9	    var1597    =	$27D9
   1499  28000 ????		27 da	    var1598    =	$27DA
   1500  28000 ????		27 db	    var1599    =	$27DB
   1501  28000 ????		27 dc	    var1600    =	$27DC
   1502  28000 ????		27 dd	    var1601    =	$27DD
   1503  28000 ????		27 de	    var1602    =	$27DE
   1504  28000 ????		27 df	    var1603    =	$27DF
   1505  28000 ????		27 e0	    var1604    =	$27E0
   1506  28000 ????		27 e1	    var1605    =	$27E1
   1507  28000 ????		27 e2	    var1606    =	$27E2
   1508  28000 ????		27 e3	    var1607    =	$27E3
   1509  28000 ????		27 e4	    var1608    =	$27E4
   1510  28000 ????		27 e5	    var1609    =	$27E5
   1511  28000 ????		27 e6	    var1610    =	$27E6
   1512  28000 ????		27 e7	    var1611    =	$27E7
   1513  28000 ????		27 e8	    var1612    =	$27E8
   1514  28000 ????		27 e9	    var1613    =	$27E9
   1515  28000 ????		27 ea	    var1614    =	$27EA
   1516  28000 ????		27 eb	    var1615    =	$27EB
   1517  28000 ????		27 ec	    var1616    =	$27EC
   1518  28000 ????		27 ed	    var1617    =	$27ED
   1519  28000 ????		27 ee	    var1618    =	$27EE
   1520  28000 ????		27 ef	    var1619    =	$27EF
   1521  28000 ????		27 f0	    var1620    =	$27F0
   1522  28000 ????		27 f1	    var1621    =	$27F1
   1523  28000 ????		27 f2	    var1622    =	$27F2
   1524  28000 ????		27 f3	    var1623    =	$27F3
   1525  28000 ????		27 f4	    var1624    =	$27F4
   1526  28000 ????		27 f5	    var1625    =	$27F5
   1527  28000 ????		27 f6	    var1626    =	$27F6
   1528  28000 ????		27 f7	    var1627    =	$27F7
   1529  28000 ????		27 f8	    var1628    =	$27F8
   1530  28000 ????		27 f9	    var1629    =	$27F9
   1531  28000 ????		27 fa	    var1630    =	$27FA
   1532  28000 ????		27 fb	    var1631    =	$27FB
   1533  28000 ????		27 fc	    var1632    =	$27FC
   1534  28000 ????		27 fd	    var1633    =	$27FD
   1535  28000 ????		27 fe	    var1634    =	$27FE
   1536  28000 ????		27 ff	    var1635    =	$27FF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1474  28000 ????
   1475  28000 ????						; BEADHEADER... disabled for now
   1476  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
   1477  28000 ????						; For more BEAD executable info, check out the spec...
   1478  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
   1479  28000 ????
   1480  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
   1481  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
   1482  28000 ????
   1483  28000 ????
   1484  28000 ????		00 40	    BDHSC      =	%01000000
   1485  28000 ????		00 20	    BDYM       =	%00100000
   1486  28000 ????		00 10	    BDPOKEY    =	%00010000
   1487  28000 ????		00 08	    BDROF      =	%00001000
   1488  28000 ????		00 00	    BD16K      =	%00000000
   1489  28000 ????		00 01	    BD32K      =	%00000001
   1490  28000 ????		00 02	    BD48K      =	%00000010
   1491  28000 ????		00 05	    BD1800     =	%00000101
   1492  28000 ????		00 06	    BD4000     =	%00000110
   1493  28000 ????
   1494  28000 ????			   -	       ifconst	BEADHEADER
   1495  28000 ????			   -BEADHARDWARE SET	0
   1496  28000 ????			   -	       ifconst	ROM16K
   1497  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
   1498  28000 ????			   -	       endif
   1499  28000 ????			   -	       ifconst	ROM32K
   1500  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
   1501  28000 ????			   -	       endif
   1502  28000 ????			   -	       ifconst	ROM48K
   1503  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
   1504  28000 ????			   -	       endif
   1505  28000 ????			   -	       ifconst	pokeysupport
   1506  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
   1507  28000 ????			   -	       endif
   1508  28000 ????			   -	       ifconst	HSSUPPORT
   1509  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
   1510  28000 ????			   -	       endif
   1511  28000 ????				       endif
   1512  28000 ????
   1513  28000 ????						;start address of cart...
   1514  28000 ????
   1515  28000 ????			    BANK_WAS_SET SET	0
   1516  28000 ????
   1517  28000 ????			   -	       ifconst	ROM8K
   1518  28000 ????			   -	       ORG	$E000,0
   1519  28000 ????			   -BANK_WAS_SET SET	1
   1520  28000 ????				       endif		; ROM8K
   1521  28000 ????
   1522  28000 ????			   -	       ifconst	ROM16K
   1523  28000 ????			   -	       ORG	$C000,0
   1524  28000 ????			   -BANK_WAS_SET SET	1
   1525  28000 ????			   -	       ifconst	BEADHEADER
   1526  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1527  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1528  28000 ????			   -	       CLC
   1529  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1530  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1531  28000 ????			   -_SKIPDESCRIPTION
   1532  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1533  28000 ????			   -	       jmp	($FFFC)
   1534  28000 ????			   -	       endif		; BEADHEADER
   1535  28000 ????				       endif		; ROM16K
   1536  28000 ????
   1537  28000 ????			   -	       ifconst	ROM32K
   1538  28000 ????			   -	       ORG	$8000,0
   1539  28000 ????			   -BANK_WAS_SET SET	1
   1540  28000 ????			   -	       ifconst	BEADHEADER
   1541  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1542  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1543  28000 ????			   -	       CLC
   1544  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1545  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1546  28000 ????			   -_SKIPDESCRIPTION
   1547  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1548  28000 ????			   -	       jmp	($FFFC)
   1549  28000 ????			   -	       endif		; BEADHEADER
   1550  28000 ????				       endif		; ROM32K
   1551  28000 ????
   1552  28000 ????			   -	       ifconst	ROM48K
   1553  28000 ????			   -	       ORG	$4000,0
   1554  28000 ????			   -BANK_WAS_SET SET	1
   1555  28000 ????			   -	       ifconst	BEADHEADER
   1556  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1557  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
   1558  28000 ????			   -	       CLC
   1559  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1560  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1561  28000 ????			   -_SKIPDESCRIPTION
   1562  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
   1563  28000 ????			   -	       jmp	($FFFC)
   1564  28000 ????			   -	       endif		; BEADHEADER
   1565  28000 ????				       endif		; ROM48K
   1566  28000 ????
   1567  28000 ????			   -	       ifconst	ROM52K
   1568  28000 ????			   -BANK_WAS_SET SET	1
   1569  28000 ????			   -	       ORG	$3000,0
   1570  28000 ????				       endif		; ROM52K
   1571  28000 ????
   1572  28000 ????				       ifconst	bankswitchmode
   1573  28000 ????			   -	       ifconst	ROMAT4K
   1574  28000 ????			   -BANK_WAS_SET SET	1
   1575  28000 ????			   -	       ORG	$4000,0
   1576  28000 ????			   -	       RORG	$4000
   1577  28000 ????				       else		; ROMAT4K
   1578  28000 ????			    BANK_WAS_SET SET	1
   1579  8000					      ORG	$8000,0
   1580  8000					      RORG	$8000
   1581  8000					      endif
   1582  8000					      endif
   1583  8000
   1584  8000				  -	      if	BANK_WAS_SET = 0
   1585  8000				  -	      ORG	$8000,0	; default is 32K
   1586  8000					      endif
   1587  8000
   1588  8000				   START_OF_ROM SET	.
   1589  8000				   SPACEOVERFLOW SET	0
   1590  8000				  -	      ifnconst	SPACEOVERFLOWPASS
   1591  8000				  -SPACEOVERFLOWPASS SET	0
   1592  8000					      endif	SPACEOVERFLOWPASS
   1593  8000				   game
   1594  8000				   .
   1595  8000							;; 
   1596  8000
   1597  8000				   .L00 		;;  set 7800header 'Sakura^the^Shiny^Absol^Ninja^Warrior'
   1598  8000
   1599  8000				   .L01 		;;  set multibutton on
   1600  8000
   1601  8000				   .L02 		;;  set tv NTSC
   1602  8000
   1603  8000				   .
   1604  8000							;; 
   1605  8000
   1606  8000				   .
   1607  8000							;; 
   1608  8000
   1609  8000				   .
   1610  8000							;; 
   1611  8000
   1612  8000				   .
   1613  8000							;; 
   1614  8000
   1615  8000				   .L03 		;;  set zoneheight 16
   1616  8000
   1617  8000				   .L04 		;;  displaymode 160B
   1618  8000
   1619  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   1620  8002		       85 3c		      sta	CTRL
   1621  8004
   1622  8004		       8d 07 21 	      sta	sCTRL
   1623  8007
   1624  8007				   .L05 		;;  set plotvalueonscreen on
   1625  8007
   1626  8007				   .L06 		;;  set bankset on
   1627  8007
   1628  8007				   .
   1629  8007							;; 
   1630  8007
   1631  8007				   .L07 		;;  set romsize 128k
   1632  8007
   1633  8007				   .
   1634  8007							;; 
   1635  8007
   1636  8007				   .L08 		;;  incgraphic font.png 160A
   1637  8007
   1638  8007				   .L09 		;;  characterset font
   1639  8007
   1640  8007		       a9 a0		      lda	#>font
   1641  8009		       8d 0b 21 	      sta	sCHARBASE
   1642  800c
   1643  800c		       85 34		      sta	CHARBASE
   1644  800e		       a9 60		      lda	#(font_mode | %01100000)
   1645  8010		       8d 06 21 	      sta	charactermode
   1646  8013
   1647  8013				   .L010		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
   1648  8013
   1649  8013				   .
   1650  8013							;; 
   1651  8013
   1652  8013				   .L011		;;  rem pallette 0 text
   1653  8013
   1654  8013				   .L012		;;  P0C1 = $0F
   1655  8013
   1656  8013		       a9 0f		      lda	#$0F
   1657  8015		       85 21		      sta	P0C1
   1658  8017				   .L013		;;  P0C2 = $0C
   1659  8017
   1660  8017		       a9 0c		      lda	#$0C
   1661  8019		       85 22		      sta	P0C2
   1662  801b				   .L014		;;  P0C3 = $0A
   1663  801b
   1664  801b		       a9 0a		      lda	#$0A
   1665  801d		       85 23		      sta	P0C3
   1666  801f				   .
   1667  801f							;; 
   1668  801f
   1669  801f				   .L015		;;  BACKGRND  =  $00
   1670  801f
   1671  801f		       a9 00		      lda	#$00
   1672  8021		       85 20		      sta	BACKGRND
   1673  8023				   .
   1674  8023							;; 
   1675  8023
   1676  8023				   .L016		;;  dim bgColor  =  var1
   1677  8023
   1678  8023				   .L017		;;  dim wait  =  var2
   1679  8023
   1680  8023				   .
   1681  8023							;; 
   1682  8023
   1683  8023				   .L018		;;  bgColor  =  0
   1684  8023
   1685  8023		       a9 00		      lda	#0
   1686  8025		       8d 41 01 	      sta	bgColor
   1687  8028				   .L019		;;  wait  =  0
   1688  8028
   1689  8028		       a9 00		      lda	#0
   1690  802a		       8d 42 01 	      sta	wait
   1691  802d				   .
   1692  802d							;; 
   1693  802d
   1694  802d				   .
   1695  802d							;; 
   1696  802d
   1697  802d				   .
   1698  802d							;; 
   1699  802d
   1700  802d				   .gameloop
   1701  802d							;; gameloop
   1702  802d
   1703  802d				   .
   1704  802d							;; 
   1705  802d
   1706  802d				   .L020		;;  clearscreen
   1707  802d
   1708  802d		       20 48 f2 	      jsr	clearscreen
   1709  8030				   .
   1710  8030							;; 
   1711  8030
   1712  8030				   .L021		;;  wait  =  wait  +  1
   1713  8030
   1714  8030		       ad 42 01 	      lda	wait
   1715  8033		       18		      CLC
   1716  8034		       69 01		      ADC	#1
   1717  8036		       8d 42 01 	      sta	wait
   1718  8039				   .L022		;;  if wait  > 10 then wait =	0  :  bgColor  =  bgColor  + 1
   1719  8039
   1720  8039		       a9 0a		      lda	#10
   1721  803b		       cd 42 01 	      cmp	wait
   1722  803e		       b0 0e		      bcs	.skipL022
   1723  8040				   .condpart0
   1724  8040		       a9 00		      lda	#0
   1725  8042		       8d 42 01 	      sta	wait
   1726  8045		       ad 41 01 	      lda	bgColor
   1727  8048		       18		      CLC
   1728  8049		       69 01		      ADC	#1
   1729  804b		       8d 41 01 	      sta	bgColor
   1730  804e				   .skipL022
   1731  804e				   .L023		;;  if bgColor  >  127 then bgColor  =  0
   1732  804e
   1733  804e		       a9 7f		      lda	#127
   1734  8050		       cd 41 01 	      cmp	bgColor
   1735  8053		       b0 05		      bcs	.skipL023
   1736  8055				   .condpart1
   1737  8055		       a9 00		      lda	#0
   1738  8057		       8d 41 01 	      sta	bgColor
   1739  805a				   .skipL023
   1740  805a				   .L024		;;  BACKGRND  =  bgColor
   1741  805a
   1742  805a		       ad 41 01 	      lda	bgColor
   1743  805d		       85 20		      sta	BACKGRND
   1744  805f				   .
   1745  805f							;; 
   1746  805f
   1747  805f				   .L025		;;  plotchars 'tangle^is^one^rad^lemur!' 0 58 5
   1748  805f
   1749  805f		       a9 08		      lda	#8	; width in two's complement
   1750  8061		       09 00		      ora	#0	; palette left shifted 5 bits
   1751  8063		       85 44		      sta	temp3
   1752  8065		       a9 00		      lda	#<alphadata0
   1753  8067		       85 42		      sta	temp1
   1754  8069
   1755  8069		       a9 80		      lda	#>alphadata0
   1756  806b		       85 43		      sta	temp2
   1757  806d
   1758  806d		       a9 3a		      lda	#58
   1759  806f		       85 45		      sta	temp4
   1760  8071
   1761  8071		       a9 05		      lda	#5
   1762  8073
   1763  8073		       85 46		      sta	temp5
   1764  8075
   1765  8075		       20 a0 f5 	      jsr	plotcharacters
   1766  8078				   .
   1767  8078							;; 
   1768  8078
   1769  8078				   .
   1770  8078							;; 
   1771  8078
   1772  8078				   .
   1773  8078							;; 
   1774  8078
   1775  8078				   .L026		;;  drawscreen
   1776  8078
   1777  8078		       20 7c f2 	      jsr	drawscreen
   1778  807b				   .
   1779  807b							;; 
   1780  807b
   1781  807b				   .L027		;;  goto gameloop
   1782  807b		       4c 2d 80 	      jmp	.gameloop
   1783  807b				   DMAHOLEEND0 SET	.
   1784  807e				   gameend
   1785  807e				   DMAHOLEEND0 SET	.
   16257 bytes of ROM space left in the main area of bank 1.
   1786  807e					      echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 1."
   1787  807e				  -	      if	($BFFF - .) < 0
   1788  807e				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   1789  807e					      endif
   1790  807e				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   1791  807e				  -	      .byte	0
   1792  807e					      endif
   1793  807e				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   1794  807e
   1795  807e		       a0 00	   font       =	$A000
   1796  807e				  -	      if	SPACEOVERFLOW > 0
   1797  807e				  -	      echo	""
   1798  807e				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   1799  807e				  -	      echo	"######## look above for areas with negative ROM space left."
   1800  807e				  -	      echo	"######## Aborting assembly."
   1801  807e				  -SET	      SPACEOVERFLOWPASS	= (SPACEOVERFLOWPASS + 1)
   1802  807e				  -	      if	SPACEOVERFLOWPASS > 0
   1803  807e				  -	      ERR
   1804  807e				  -	      endif
   1805  807e					      endif
   1806  807e
   1807  807e
   1808  807e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1809  807e
   1810  807e				  -	      ifnconst	bankswitchmode
   1811  807e				  -	      if	( * < $f000 )
   1812  807e				  -	      ORG	$F000
   1813  807e				  -	      endif
   1814  807e					      else
   1815  807e					      ifconst	ROM128K
   1816  807e					      if	( * < $f000 )
   1817  27000					       ORG	$27000
   1818  27000					       RORG	$F000
   1819  27000					       endif
   1820  27000					       endif
   1821  27000				   -	       ifconst	ROM144K
   1822  27000				   -	       if	( * < $f000 )
   1823  27000				   -	       ORG	$27000
   1824  27000				   -	       RORG	$F000
   1825  27000				   -	       endif
   1826  27000					       endif
   1827  27000				   -	       ifconst	ROM256K
   1828  27000				   -	       if	( * < $f000 )
   1829  27000				   -	       ORG	$47000
   1830  27000				   -	       RORG	$F000
   1831  27000				   -	       endif
   1832  27000					       endif
   1833  27000				   -	       ifconst	ROM272K
   1834  27000				   -	       if	( * < $f000 )
   1835  27000				   -	       ORG	$47000
   1836  27000				   -	       RORG	$F000
   1837  27000				   -	       endif
   1838  27000					       endif
   1839  27000				   -	       ifconst	ROM512K
   1840  27000				   -	       if	( * < $f000 )
   1841  27000				   -	       ORG	$87000
   1842  27000				   -	       RORG	$F000
   1843  27000				   -	       endif
   1844  27000					       endif
   1845  27000				   -	       ifconst	ROM528K
   1846  27000				   -	       if	( * < $f000 )
   1847  27000				   -	       ORG	$87000
   1848  27000				   -	       RORG	$F000
   1849  27000				   -	       endif
   1850  27000					       endif
   1851  27000					       endif
   1852  27000
   1853  27000							; all of these "modules" have conditional clauses in them, so even though
   1854  27000							; they're always included here, they don't take up rom unless the user
   1855  27000							; explicitly enables support for the feature.
   1856  27000
   1857  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* More small changes were made to use this code with 7800basic, and
     15  27000				   -			;* comments by VinsCool on more recent versions were back-ported.
     16  27000				   -			;* --Mike Saarna.
     17  27000				   -			;*
     18  27000				   -			;* Warnings:
     19  27000				   -			;*
     20  27000				   -			;* 1. RMT player routine needs 19 dedicated zero page bytes, as well as cca
     21  27000				   -			;* 1KB of memory before the "PLAYER" address for frequency tables and
     22  27000				   -			;* functionary variables. It's:
     23  27000				   -			;* a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     24  27000				   -			;* b) from PLAYER-$380 to PLAYER for mono RMTplayer
     25  27000				   -			;*
     26  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER
     27  27000				   -			;* points to the start of the frequency tables. The player routines follows
     28  27000				   -			;* after that. The variables are now independent and can be located with
     29  27000				   -			;* PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     30  27000				   -			;*
     31  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled aligned to a memory page.
     32  27000				   -			;* i.e. "PLAYER" address can be $..00 only!
     33  27000				   -			;*
     34  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of
     35  27000				   -			;* CPU time.
     36  27000				   -			;*
     37  27000				   -			;*
     38  27000				   -			;* Define the following equates here or in your main code file.
     39  27000				   -			;* Set the values according to the system you compile for.
     40  27000				   -			;*
     41  27000				   -
     42  27000				   -POKEY_BASE equ	pokeyaddress
     43  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	;* player routine needs 19 bytes
     44  27000				   -			;* of zero page RAM
     45  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;* variables in main RAM - 173 bytes
     46  27000				   -			;* mono - 337 stereo
     47  27000				   -
     48  27000				   -ROM_BASED  equ	1	;* using a ROM based system - no self modifying code
     49  27000				   -STEREO8T   equ	0	;* 0 => compile RMTplayer for mono 4 tracks
     50  27000				   -			; ;1 => compile RMTplayer for stereo 8 tracks
     51  27000				   -
     52  27000				   -HARD_OF_HEARING equ	1	;* repeat output to pokey
     53  27000				   -
     54  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     55  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     56  27000				   -
     57  27000				   -			;*
     58  27000				   -
     59  27000				   -	       IF	STEREO8T
     60  27000				   -TRACKS     equ	8
     61  27000				   -	       ELSE
     62  27000				   -TRACKS     equ	4
     63  27000				   -	       ENDIF
     64  27000				   -
     65  27000				   -			;*
     66  27000				   -			;* RMT FEATures definitions
     67  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     68  27000				   -			;* --------BEGIN--------
     69  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     70  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page)
     71  27000				   -			;* and quicker whole RMT routine
     72  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     73  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     74  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     75  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     76  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     77  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     78  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     79  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     80  27000				   -			;* PORTAMENTO
     81  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     82  27000				   -			;* FILTER
     83  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     84  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     85  27000				   -FEAT_FILTERG1L equ	1
     86  27000				   -FEAT_FILTERG0R equ	1
     87  27000				   -FEAT_FILTERG1R equ	1
     88  27000				   -			;* BASS16B (i.e. distortion value 6)
     89  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and
     90  27000				   -			;* quicker whole RMT routine
     91  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     92  27000				   -FEAT_BASS16G3L equ	1
     93  27000				   -FEAT_BASS16G1R equ	1
     94  27000				   -FEAT_BASS16G3R equ	1
     95  27000				   -			;* VOLUME ONLY for particular generators
     96  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     97  27000				   -FEAT_VOLUMEONLYG2L equ	1
     98  27000				   -FEAT_VOLUMEONLYG3L equ	1
     99  27000				   -FEAT_VOLUMEONLYG0R equ	1
    100  27000				   -FEAT_VOLUMEONLYG2R equ	1
    101  27000				   -FEAT_VOLUMEONLYG3R equ	1
    102  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
    103  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
    104  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
    105  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
    106  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
    107  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
    108  27000				   -			;* --------END--------
    109  27000				   -			;*
    110  27000				   -			;*
    111  27000				   -			;* RMT ZeroPage addresses
    112  27000				   -
    113  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    114  27000				   -p_tis      =	MEMLOC
    115  27000				   -p_instrstable =	MEMLOC
    116  27000				   -MEMLOC     SET	(MEMLOC+2)
    117  27000				   -ptrTracksTblLo =	MEMLOC
    118  27000				   -MEMLOC     SET	(MEMLOC+2)
    119  27000				   -ptrTracksTblHi =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+2)
    121  27000				   -ptrSongLines =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+2)
    123  27000				   -
    124  27000				   -_ns        =	MEMLOC
    125  27000				   -MEMLOC     SET	(MEMLOC+2)
    126  27000				   -_nr        =	MEMLOC
    127  27000				   -MEMLOC     SET	(MEMLOC+2)
    128  27000				   -_nt        =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+2)
    130  27000				   -
    131  27000				   -rmtreg1    =	MEMLOC
    132  27000				   -MEMLOC     SET	(MEMLOC+1)
    133  27000				   -rmtreg2    =	MEMLOC
    134  27000				   -MEMLOC     SET	(MEMLOC+1)
    135  27000				   -rmtreg3    =	MEMLOC
    136  27000				   -MEMLOC     SET	(MEMLOC+1)
    137  27000				   -_tmp       =	MEMLOC
    138  27000				   -MEMLOC     SET	(MEMLOC+1)
    139  27000				   -	       IF	FEAT_COMMAND2
    140  27000				   -frqaddcmd2 =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+1)
    142  27000				   -	       ENDIF
    143  27000				   -
    144  27000				   -			;*
    145  27000				   -			;* Variables in main RAM used by player routine.
    146  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    147  27000				   -			;*
    148  27000				   -
    149  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    150  27000				   -track_variables =	MEMLOC
    151  27000				   -
    152  27000				   -trackn_TblLo =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_TblHi =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -trackn_idx =	MEMLOC
    157  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    158  27000				   -trackn_pause =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_note =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_volume =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_distor =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_shiftfrq =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -
    169  27000				   -	       IF	FEAT_PORTAMENTO
    170  27000				   -trackn_portafrqc =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_portafrqa =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_portaspeed =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_portaspeeda =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_portadepth =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -	       ENDIF
    181  27000				   -
    182  27000				   -trackn_instrx2 =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_instrdb =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_instrhb =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_instridx =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_instrlen =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_instrlop =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_instrreachend =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_volumeslidedepth =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_volumeslidevalue =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_volumemin =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -trackn_effdelay =	MEMLOC
    203  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    204  27000				   -trackn_effvibratoa =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -trackn_effvibratobeg =	MEMLOC
    207  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    208  27000				   -trackn_effvibratoend =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -trackn_effshift =	MEMLOC
    211  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    212  27000				   -trackn_tabletypespeed =	MEMLOC
    213  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    214  27000				   -
    215  27000				   -	       IF	FEAT_TABLEMODE
    216  27000				   -trackn_tablemode =	MEMLOC
    217  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    218  27000				   -	       ENDIF
    219  27000				   -
    220  27000				   -trackn_tablenote =	MEMLOC
    221  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    222  27000				   -
    223  27000				   -trackn_tablea =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -trackn_tableend =	MEMLOC
    226  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    227  27000				   -trackn_tablelop =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -trackn_tablespeeda =	MEMLOC
    230  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    231  27000				   -trackn_command =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -
    234  27000				   -	       IF	FEAT_BASS16
    235  27000				   -trackn_outnote =	MEMLOC
    236  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    237  27000				   -	       ENDIF
    238  27000				   -	       IF	FEAT_FILTER
    239  27000				   -trackn_filter =	MEMLOC
    240  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    241  27000				   -	       ENDIF
    242  27000				   -
    243  27000				   -trackn_audf =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    245  27000				   -trackn_audc =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    247  27000				   -
    248  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    249  27000				   -trackn_audctl =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    251  27000				   -	       ENDIF
    252  27000				   -
    253  27000				   -v_audctl   =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_audctl2  =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_speed    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -v_aspeed   =	MEMLOC
    260  27000				   -MEMLOC     SET	(MEMLOC+1)
    261  27000				   -v_bspeed   =	MEMLOC
    262  27000				   -MEMLOC     SET	(MEMLOC+1)
    263  27000				   -v_instrspeed =	MEMLOC
    264  27000				   -MEMLOC     SET	(MEMLOC+1)
    265  27000				   -smc_silence_instrspeed =	MEMLOC
    266  27000				   -MEMLOC     SET	(MEMLOC+1)
    267  27000				   -v_maxtracklen =	MEMLOC
    268  27000				   -MEMLOC     SET	(MEMLOC+1)
    269  27000				   -v_abeat    =	MEMLOC
    270  27000				   -MEMLOC     SET	(MEMLOC+1)
    271  27000				   -
    272  27000				   -track_endvariables =	MEMLOC
    273  27000				   -
    274  27000				   -			;*
    275  27000				   -			;* Data tables used by player routine.
    276  27000				   -			;*
    277  27000				   -	       ALIGN	256
    278  27000				   -PLAYER     =	.
    279  27000				   -
    280  27000				   -volumetab
    281  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    282  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    283  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    284  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    285  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    286  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    287  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    288  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    289  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    290  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    291  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    292  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    293  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    294  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    295  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    296  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    297  27000				   -
    298  27000				   -frqtab
    299  27000				   -			; ERT [<frqtab]!=0 ;* frqtab must begin at the memory page bound!
    300  27000				   -			;* (i.e. $..00 address)
    301  27000				   -frqtabbass1
    302  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    303  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    304  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    305  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    306  27000				   -frqtabbass2
    307  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    308  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    309  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    310  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    311  27000				   -frqtabpure
    312  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    313  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    314  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    315  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    316  27000				   -	       IF	FEAT_BASS16
    317  27000				   -frqtabbasshi
    318  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    319  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    320  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    321  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    322  27000				   -	       ENDIF
    323  27000				   -
    324  27000				   -	       IF	FEAT_BASS16
    325  27000				   -frqtabbasslo
    326  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    327  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    328  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    329  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    330  27000				   -	       ENDIF
    331  27000				   -
    332  27000				   -	       IF	ROM_BASED
    333  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    334  27000				   -	       ENDIF
    335  27000				   -INSTRPAR   equ	12
    336  27000				   -tabbeganddistor
    337  27000				   -	       dc.b	frqtabpure-frqtab,$00
    338  27000				   -	       dc.b	frqtabpure-frqtab,$20
    339  27000				   -	       dc.b	frqtabpure-frqtab,$40
    340  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    341  27000				   -	       dc.b	frqtabpure-frqtab,$80
    342  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    343  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    344  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    345  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    346  27000				   -vib0       dc.b	0
    347  27000				   -vib1       dc.b	1,-1,-1,1
    348  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    349  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    350  27000				   -vibx
    351  27000				   -emptytrack
    352  27000				   -	       dc.b	62,0
    353  27000				   -
    354  27000				   -			;*
    355  27000				   -			;* Set of RMT main vectors:
    356  27000				   -			;*
    357  27000				   -RASTERMUSICTRACKER
    358  27000				   -	       jmp	rmt_init	;* Must be run first, to clear memory and initialise
    359  27000				   -			;* the player... Once this is done, run rmt_play
    360  27000				   -			;* afterwards, or Set_Pokey if you want to manually
    361  27000				   -			;* time certain things.
    362  27000				   -
    363  27000				   -	       jmp	rmt_play	;* One play each subroutine call. SetPokey is
    364  27000				   -			;* executed first, then all the play code is ran
    365  27000				   -			;* once, until the RTS. rmt_play could be called
    366  27000				   -			;* multiple times per frame if wanted.
    367  27000				   -
    368  27000				   -	       jmp	rmt_p3	;* Similar to rmt_play, but will also skip SetPokey
    369  27000				   -			;* and the instruments/songlines/tracklines
    370  27000				   -			;* initialisation, very useful for playing simple
    371  27000				   -			;* things.
    372  27000				   -
    373  27000				   -	       jmp	rmt_silence	;* Run this to stop the driver, and reset all POKEY
    374  27000				   -			;* registers to 0. This is also part of rmt_init
    375  27000				   -			;* when it is executed first.
    376  27000				   -
    377  27000				   -	       jmp	SetPokey	;* Run to copy the contents of the Shadow POKEY
    378  27000				   -			;* registers (v_audctl, v_skctl, trackn_audf,x etc)
    379  27000				   -			;* into the real ones. Will be run first each time
    380  27000				   -			;* rmt_play is called.
    381  27000				   -rmt_init
    382  27000				   -	       stx	_ns
    383  27000				   -	       sty	_ns+1
    384  27000				   -	       pha
    385  27000				   -	       IF	track_endvariables-track_variables>255
    386  27000				   -	       ldy	#0
    387  27000				   -	       tya
    388  27000				   -ri_clear_loop
    389  27000				   -	       sta	track_variables,y
    390  27000				   -	       sta	track_endvariables-$100,y
    391  27000				   -	       iny
    392  27000				   -	       bne	ri_clear_loop
    393  27000				   -	       ELSE
    394  27000				   -	       ldy	#track_endvariables-track_variables
    395  27000				   -	       lda	#0
    396  27000				   -ri_clear_loop
    397  27000				   -	       sta	track_variables-1,y
    398  27000				   -	       dey
    399  27000				   -	       bne	ri_clear_loop
    400  27000				   -	       ENDIF
    401  27000				   -			;* Parse the RMT module data
    402  27000				   -			;* Track length: +4
    403  27000				   -	       ldy	#4
    404  27000				   -	       lda	(_ns),y
    405  27000				   -	       sta	v_maxtracklen	;* Change the code to store the track length
    406  27000				   -	       iny
    407  27000				   -	       lda	(_ns),y
    408  27000				   -	       sta	v_speed	;* Change the code to store the song speed
    409  27000				   -	       iny
    410  27000				   -	       lda	(_ns),y
    411  27000				   -	       sta	v_instrspeed	;* Change the code to store the instrument speed
    412  27000				   -	       sta	smc_silence_instrspeed
    413  27000				   -
    414  27000				   -			; Copy 4 pointers: +8
    415  27000				   -			; -> InstrumentPtrs[]	       2 bytes
    416  27000				   -			; -> TracksPtrsLow[]	       2 bytes
    417  27000				   -			; -> TracksPtrsHi	       2 bytes
    418  27000				   -			; -> SongData		       2 bytes
    419  27000				   -	       ldy	#8
    420  27000				   -ri_copy_loop
    421  27000				   -	       lda	(_ns),y
    422  27000				   -	       sta	p_tis-8,y
    423  27000				   -	       iny
    424  27000				   -	       cpy	#8+8	;* we started at 8, so loop until 16
    425  27000				   -	       bne	ri_copy_loop
    426  27000				   -
    427  27000				   -	       pla
    428  27000				   -	       pha
    429  27000				   -	       IF	STEREO8T
    430  27000				   -	       asl
    431  27000				   -	       asl
    432  27000				   -	       asl
    433  27000				   -	       clc
    434  27000				   -	       adc	ptrSongLines
    435  27000				   -	       sta	ptrSongLines
    436  27000				   -	       pla
    437  27000				   -	       and	#$e0
    438  27000				   -	       asl
    439  27000				   -	       rol
    440  27000				   -	       rol
    441  27000				   -	       rol
    442  27000				   -	       ELSE
    443  27000				   -	       asl
    444  27000				   -	       asl
    445  27000				   -	       clc
    446  27000				   -	       adc	ptrSongLines
    447  27000				   -	       sta	ptrSongLines
    448  27000				   -	       pla
    449  27000				   -	       and	#$c0
    450  27000				   -	       asl
    451  27000				   -	       rol
    452  27000				   -	       rol
    453  27000				   -	       ENDIF
    454  27000				   -	       adc	ptrSongLines+1
    455  27000				   -	       sta	ptrSongLines+1
    456  27000				   -
    457  27000				   -	       jsr	GetSongLine
    458  27000				   -
    459  27000				   -	       jsr	GetTrackLine
    460  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    461  27000				   -	       jsr	rmt_silence
    462  27000				   -	       lda	v_instrspeed
    463  27000				   -	       rts
    464  27000				   -
    465  27000				   -rmt_silence
    466  27000				   -	       IF	STEREO8T
    467  27000				   -	       lda	#0
    468  27000				   -	       sta	POKEY_BASE+$08
    469  27000				   -	       sta	POKEY_BASE_S+$08
    470  27000				   -	       ldy	#3
    471  27000				   -	       sty	POKEY_BASE+$0f
    472  27000				   -	       sty	POKEY_BASE_S+$0f
    473  27000				   -	       ldy	#8
    474  27000				   -rmt_silence_loop
    475  27000				   -	       sta	POKEY_BASE+$00,y
    476  27000				   -	       sta	POKEY_BASE_S+$00,y
    477  27000				   -	       dey
    478  27000				   -	       bpl	rmt_silence_loop
    479  27000				   -	       ELSE
    480  27000				   -	       lda	#0
    481  27000				   -	       sta	POKEY_BASE+$08
    482  27000				   -	       ldy	#3
    483  27000				   -	       sty	POKEY_BASE+$0f
    484  27000				   -	       ldy	#8
    485  27000				   -rmt_silence_loop
    486  27000				   -	       sta	POKEY_BASE+$00,y
    487  27000				   -	       dey
    488  27000				   -	       bpl	rmt_silence_loop
    489  27000				   -	       ENDIF
    490  27000				   -	       rts
    491  27000				   -
    492  27000				   -GetSongLine
    493  27000				   -	       ldx	#0
    494  27000				   -	       stx	v_abeat
    495  27000				   -gsl_loop
    496  27000				   -	       ldx	#0
    497  27000				   -gsl_nextSongLine
    498  27000				   -	       txa
    499  27000				   -	       tay
    500  27000				   -	       lda	(ptrSongLines),y
    501  27000				   -	       cmp	#$fe	;* check for "goto line"
    502  27000				   -	       bcs	gsl_GotoOrEmpty	;* and handle it.
    503  27000				   -			;* (A) = Real track #
    504  27000				   -			;* Get the ptr to the track data and store it in ptrTracksTblLo
    505  27000				   -	       tay
    506  27000				   -	       lda	(ptrTracksTblLo),y
    507  27000				   -	       sta	trackn_TblLo,x
    508  27000				   -	       lda	(ptrTracksTblHi),y
    509  27000				   -gsl_initTrack
    510  27000				   -	       sta	trackn_TblHi,x
    511  27000				   -
    512  27000				   -	       lda	#0	;* reset the track index to 0 trackn_idx[x] = 0
    513  27000				   -	       sta	trackn_idx,x
    514  27000				   -
    515  27000				   -	       lda	#1
    516  27000				   -	       sta	trackn_pause,x	;* #1 is a new track, #0 is no new track
    517  27000				   -
    518  27000				   -	       lda	#$80	;* mark that there is no new instrument
    519  27000				   -	       sta	trackn_instrx2,x	;* #$80 is negative, will BMI when encountered,
    520  27000				   -			;* meaning no new instrument initialisation
    521  27000				   -	       inx
    522  27000				   -	       cpx	#TRACKS	;* if x < TRACKS --> gsl_nextSongLine
    523  27000				   -	       bne	gsl_nextSongLine
    524  27000				   -
    525  27000				   -			;* Done with data points of a song line, move to the next line
    526  27000				   -	       lda	ptrSongLines
    527  27000				   -	       clc
    528  27000				   -	       adc	#TRACKS
    529  27000				   -	       sta	ptrSongLines
    530  27000				   -	       bcc	gsl_skipSongHiIncrement
    531  27000				   -	       inc	ptrSongLines+1
    532  27000				   -gsl_skipSongHiIncrement
    533  27000				   -	       rts
    534  27000				   -
    535  27000				   -gsl_GotoOrEmpty
    536  27000				   -			; "cmp #$FE" performed prior to getting here
    537  27000				   -	       beq	gsl_Goto
    538  27000				   -
    539  27000				   -gsl_Empty
    540  27000				   -	       lda	#<emptytrack
    541  27000				   -	       sta	trackn_TblLo,x
    542  27000				   -	       lda	#>emptytrack
    543  27000				   -	       jmp	gsl_initTrack
    544  27000				   -
    545  27000				   -gsl_Goto
    546  27000				   -			; Data format: 0xFE, ???, low, high bytes of ptr to next song line
    547  27000				   -	       ldy	#2
    548  27000				   -	       lda	(ptrSongLines),y
    549  27000				   -	       tax
    550  27000				   -	       iny
    551  27000				   -	       lda	(ptrSongLines),y
    552  27000				   -	       sta	ptrSongLines+1
    553  27000				   -	       stx	ptrSongLines
    554  27000				   -	       jmp	gsl_loop
    555  27000				   -
    556  27000				   -GetTrackLine
    557  27000				   -rmtoo0
    558  27000				   -rmtoo0a
    559  27000				   -	       lda	v_speed
    560  27000				   -	       sta	v_bspeed
    561  27000				   -	       ldx	#0
    562  27000				   -gtl_loopTracks
    563  27000				   -	       lda	trackn_pause,x
    564  27000				   -	       beq	gtl_checkEndOfLoop
    565  27000				   -	       dec	trackn_pause,x
    566  27000				   -	       bne	gtl_checkEndOfLoop
    567  27000				   -	       inc	trackn_pause,x
    568  27000				   -
    569  27000				   -	       lda	trackn_TblLo,x
    570  27000				   -	       sta	_ns
    571  27000				   -	       lda	trackn_TblHi,x
    572  27000				   -	       sta	_ns+1
    573  27000				   -
    574  27000				   -oo1i
    575  27000				   -	       ldy	trackn_idx,x
    576  27000				   -			;* Get a track data point
    577  27000				   -			;* 0 - 60 = Note, instr and volume data
    578  27000				   -			;* 61 - Volume only
    579  27000				   -			;* 62 = Pause/empty line
    580  27000				   -			;* 63 - Speed, go loop or end
    581  27000				   -	       lda	(_ns),y
    582  27000				   -	       sta	rmtreg1
    583  27000				   -	       iny
    584  27000				   -	       lda	(_ns),y
    585  27000				   -	       sta	rmtreg2
    586  27000				   -	       iny
    587  27000				   -	       tya
    588  27000				   -	       sta	trackn_idx,x
    589  27000				   -
    590  27000				   -	       lda	rmtreg1
    591  27000				   -	       and	#$3f
    592  27000				   -	       cmp	#61
    593  27000				   -	       beq	gtl_ProcessVolumeData
    594  27000				   -	       bcs	gtl_Is62or63
    595  27000				   -
    596  27000				   -			;* if we're here it's a note, so store it.
    597  27000				   -	       sta	trackn_note,x
    598  27000				   -	       IF	FEAT_BASS16
    599  27000				   -	       sta	trackn_outnote,x
    600  27000				   -	       ENDIF
    601  27000				   -
    602  27000				   -			;* Process the instrument #
    603  27000				   -	       lda	rmtreg2
    604  27000				   -	       lsr
    605  27000				   -	       and	#$3f*2
    606  27000				   -	       sta	trackn_instrx2,x
    607  27000				   -
    608  27000				   -gtl_ProcessVolumeData
    609  27000				   -	       lda	rmtreg2
    610  27000				   -	       lsr
    611  27000				   -	       ror	rmtreg1
    612  27000				   -	       lsr
    613  27000				   -	       ror	rmtreg1
    614  27000				   -	       lda	rmtreg1
    615  27000				   -	       and	#$f0
    616  27000				   -	       sta	trackn_volume,x
    617  27000				   -gtl_checkEndOfLoop
    618  27000				   -	       inx
    619  27000				   -	       cpx	#TRACKS
    620  27000				   -	       bne	gtl_loopTracks
    621  27000				   -	       lda	v_bspeed
    622  27000				   -	       sta	v_speed
    623  27000				   -	       sta	v_aspeed
    624  27000				   -	       rts
    625  27000				   -
    626  27000				   -gtl_Is62or63
    627  27000				   -	       cmp	#63
    628  27000				   -	       beq	rmtoo63
    629  27000				   -	       lda	rmtreg1
    630  27000				   -	       and	#$c0
    631  27000				   -	       beq	rmtoo62_b
    632  27000				   -	       asl
    633  27000				   -	       rol
    634  27000				   -	       rol
    635  27000				   -	       sta	trackn_pause,x
    636  27000				   -	       dec	trackn_idx,x
    637  27000				   -	       jmp	gtl_checkEndOfLoop
    638  27000				   -
    639  27000				   -rmtoo62_b
    640  27000				   -	       lda	rmtreg2
    641  27000				   -	       sta	trackn_pause,x
    642  27000				   -	       jmp	gtl_checkEndOfLoop
    643  27000				   -
    644  27000				   -rmtoo63
    645  27000				   -	       lda	rmtreg1
    646  27000				   -	       bmi	rmtoo63_1X
    647  27000				   -	       lda	rmtreg2
    648  27000				   -	       sta	v_bspeed
    649  27000				   -	       jmp	oo1i
    650  27000				   -rmtoo63_1X
    651  27000				   -	       cmp	#255
    652  27000				   -	       beq	rmtoo63_11
    653  27000				   -	       lda	rmtreg2
    654  27000				   -	       sta	trackn_idx,x
    655  27000				   -	       jmp	oo1i
    656  27000				   -
    657  27000				   -rmtoo63_11
    658  27000				   -	       jsr	GetSongLine
    659  27000				   -	       jmp	rmtoo0
    660  27000				   -
    661  27000				   -InitOfNewSetInstrumentsOnly
    662  27000				   -	       ldx	#0
    663  27000				   -p2x1       ldy	trackn_instrx2,x
    664  27000				   -	       bmi	p2x2	;* if negative, no new instrument to initialise for this channel
    665  27000				   -	       jsr	SetUpInstrumentY2
    666  27000				   -	       lda	#$80
    667  27000				   -	       sta	trackn_instrx2,x
    668  27000				   -p2x2
    669  27000				   -	       inx
    670  27000				   -	       cpx	#TRACKS
    671  27000				   -	       bne	p2x1
    672  27000				   -	       rts
    673  27000				   -
    674  27000				   -rmt_play
    675  27000				   -rmt_p0
    676  27000				   -	       jsr	SetPokey
    677  27000				   -rmt_p1
    678  27000				   -	       dec	smc_silence_instrspeed
    679  27000				   -	       beq	rmtp1a
    680  27000				   -	       jmp	rmt_p3
    681  27000				   -rmtp1a
    682  27000				   -	       lda	v_instrspeed
    683  27000				   -	       sta	smc_silence_instrspeed
    684  27000				   -rmt_p2
    685  27000				   -	       dec	v_aspeed
    686  27000				   -	       bne	rmt_p3
    687  27000				   -	       inc	v_abeat
    688  27000				   -	       lda	v_abeat
    689  27000				   -	       cmp	v_maxtracklen
    690  27000				   -	       bne	rmtp2o2
    691  27000				   -	       jsr	GetSongLine
    692  27000				   -rmtp2o2
    693  27000				   -	       jsr	GetTrackLine
    694  27000				   -	       jmp	rmt_p2X
    695  27000				   -go_ppnext
    696  27000				   -	       jmp	ppnext
    697  27000				   -rmt_p2X
    698  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    699  27000				   -rmt_p3
    700  27000				   -	       lda	#>frqtab
    701  27000				   -	       sta	_nr+1
    702  27000				   -
    703  27000				   -	       ldx	#0
    704  27000				   -rmtpp1
    705  27000				   -	       lda	trackn_instrhb,x
    706  27000				   -	       beq	go_ppnext
    707  27000				   -	       sta	_ns+1
    708  27000				   -	       lda	trackn_instrdb,x
    709  27000				   -	       sta	_ns
    710  27000				   -	       ldy	trackn_instridx,x
    711  27000				   -	       lda	(_ns),y
    712  27000				   -	       sta	rmtreg1
    713  27000				   -	       iny
    714  27000				   -	       lda	(_ns),y
    715  27000				   -	       sta	rmtreg2
    716  27000				   -	       iny
    717  27000				   -	       lda	(_ns),y
    718  27000				   -	       sta	rmtreg3
    719  27000				   -	       iny
    720  27000				   -	       tya
    721  27000				   -	       cmp	trackn_instrlen,x
    722  27000				   -	       bcc	rmtpp2
    723  27000				   -	       beq	rmtpp2
    724  27000				   -	       lda	#$80
    725  27000				   -	       sta	trackn_instrreachend,x
    726  27000				   -rmtpp1b
    727  27000				   -	       lda	trackn_instrlop,x
    728  27000				   -rmtpp2
    729  27000				   -	       sta	trackn_instridx,x
    730  27000				   -	       lda	rmtreg1
    731  27000				   -	       IF	STEREO8T
    732  27000				   -	       cpx	#4
    733  27000				   -	       bcc	rmtpp2s
    734  27000				   -	       lsr
    735  27000				   -	       lsr
    736  27000				   -	       lsr
    737  27000				   -	       lsr
    738  27000				   -rmtpp2s
    739  27000				   -	       ENDIF
    740  27000				   -	       and	#$0f
    741  27000				   -	       ora	trackn_volume,x
    742  27000				   -	       tay
    743  27000				   -	       lda	volumetab,y
    744  27000				   -	       pha
    745  27000				   -	       lda	rmtreg2
    746  27000				   -	       and	#$0e
    747  27000				   -	       tay
    748  27000				   -	       lda	tabbeganddistor,y
    749  27000				   -	       sta	_nr
    750  27000				   -	       pla
    751  27000				   -	       ora	tabbeganddistor+1,y
    752  27000				   -	       sta	trackn_audc,x
    753  27000				   -	       jmp	InstrumentsEffects
    754  27000				   -returnfromInstrumentsEffects
    755  27000				   -	       IF	FEAT_COMMAND2
    756  27000				   -	       lda	#0
    757  27000				   -	       sta	frqaddcmd2
    758  27000				   -	       ENDIF
    759  27000				   -	       lda	rmtreg2
    760  27000				   -	       sta	trackn_command,x
    761  27000				   -	       and	#$70
    762  27000				   -	       lsr
    763  27000				   -	       lsr
    764  27000				   -	       IF	ROM_BASED
    765  27000				   -	       lsr
    766  27000				   -	       tay
    767  27000				   -	       lda	rts_tab+1,y
    768  27000				   -	       pha
    769  27000				   -	       lda	rts_tab,y
    770  27000				   -	       pha
    771  27000				   -	       rts
    772  27000				   -	       ELSE
    773  27000				   -	       sta	jmx+1
    774  27000				   -jmx
    775  27000				   -	       bcc	*
    776  27000				   -	       jmp	cmd0
    777  27000				   -	       nop
    778  27000				   -	       jmp	cmd1
    779  27000				   -	       nop
    780  27000				   -	       jmp	cmd2
    781  27000				   -	       nop
    782  27000				   -	       jmp	cmd3
    783  27000				   -	       nop
    784  27000				   -	       jmp	cmd4
    785  27000				   -	       nop
    786  27000				   -	       jmp	cmd5
    787  27000				   -	       nop
    788  27000				   -	       jmp	cmd6
    789  27000				   -	       nop
    790  27000				   -	       jmp	cmd7
    791  27000				   -	       ENDIF
    792  27000				   -cmd0
    793  27000				   -	       lda	trackn_note,x
    794  27000				   -	       clc
    795  27000				   -	       adc	rmtreg3
    796  27000				   -cmd0a
    797  27000				   -	       IF	FEAT_TABLETYPE
    798  27000				   -	       ldy	trackn_tabletypespeed,x
    799  27000				   -	       bmi	cmd0b
    800  27000				   -	       ENDIF
    801  27000				   -	       clc
    802  27000				   -	       adc	trackn_tablenote,x
    803  27000				   -	       cmp	#61
    804  27000				   -	       bcc	cmd0a1
    805  27000				   -	       lda	#0
    806  27000				   -	       sta	trackn_audc,x
    807  27000				   -	       lda	#63
    808  27000				   -cmd0a1
    809  27000				   -	       IF	FEAT_BASS16
    810  27000				   -	       sta	trackn_outnote,x
    811  27000				   -	       ENDIF
    812  27000				   -	       tay
    813  27000				   -	       lda	(_nr),y
    814  27000				   -	       clc
    815  27000				   -	       adc	trackn_shiftfrq,x
    816  27000				   -	       IF	FEAT_COMMAND2
    817  27000				   -	       clc
    818  27000				   -	       adc	frqaddcmd2
    819  27000				   -	       ENDIF
    820  27000				   -	       sta	trackn_audf,x
    821  27000				   -	       jmp	rmtpp9
    822  27000				   -	       IF	FEAT_TABLETYPE
    823  27000				   -cmd0b
    824  27000				   -	       cmp	#61
    825  27000				   -	       bcc	cmd0b1
    826  27000				   -	       lda	#0
    827  27000				   -	       sta	trackn_audc,x
    828  27000				   -	       lda	#63
    829  27000				   -cmd0b1
    830  27000				   -	       tay
    831  27000				   -	       lda	trackn_shiftfrq,x
    832  27000				   -	       clc
    833  27000				   -	       adc	trackn_tablenote,x
    834  27000				   -	       clc
    835  27000				   -	       adc	(_nr),y
    836  27000				   -	       IF	FEAT_COMMAND2
    837  27000				   -	       clc
    838  27000				   -	       adc	frqaddcmd2
    839  27000				   -	       ENDIF
    840  27000				   -	       sta	trackn_audf,x
    841  27000				   -	       jmp	rmtpp9
    842  27000				   -	       ENDIF
    843  27000				   -cmd1
    844  27000				   -	       IF	FEAT_COMMAND1
    845  27000				   -	       lda	rmtreg3
    846  27000				   -	       sta	trackn_audf,x
    847  27000				   -	       jmp	rmtpp9
    848  27000				   -	       ENDIF
    849  27000				   -cmd2
    850  27000				   -	       IF	FEAT_COMMAND2
    851  27000				   -	       lda	rmtreg3
    852  27000				   -	       sta	frqaddcmd2
    853  27000				   -	       lda	trackn_note,x
    854  27000				   -	       jmp	cmd0a
    855  27000				   -	       ENDIF
    856  27000				   -cmd3
    857  27000				   -	       IF	FEAT_COMMAND3
    858  27000				   -	       lda	trackn_note,x
    859  27000				   -	       clc
    860  27000				   -	       adc	rmtreg3
    861  27000				   -	       sta	trackn_note,x
    862  27000				   -	       jmp	cmd0a
    863  27000				   -	       ENDIF
    864  27000				   -cmd4
    865  27000				   -	       IF	FEAT_COMMAND4
    866  27000				   -	       lda	trackn_shiftfrq,x
    867  27000				   -	       clc
    868  27000				   -	       adc	rmtreg3
    869  27000				   -	       sta	trackn_shiftfrq,x
    870  27000				   -	       lda	trackn_note,x
    871  27000				   -	       jmp	cmd0a
    872  27000				   -	       ENDIF
    873  27000				   -cmd5
    874  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    875  27000				   -	       IF	FEAT_TABLETYPE
    876  27000				   -	       lda	trackn_tabletypespeed,x
    877  27000				   -	       bpl	cmd5a1
    878  27000				   -	       ldy	trackn_note,x
    879  27000				   -	       lda	(_nr),y
    880  27000				   -	       clc
    881  27000				   -	       adc	trackn_tablenote,x
    882  27000				   -	       jmp	cmd5ax
    883  27000				   -	       ENDIF
    884  27000				   -cmd5a1
    885  27000				   -	       lda	trackn_note,x
    886  27000				   -	       clc
    887  27000				   -	       adc	trackn_tablenote,x
    888  27000				   -	       cmp	#61
    889  27000				   -	       bcc	cmd5a2
    890  27000				   -	       lda	#63
    891  27000				   -cmd5a2
    892  27000				   -	       tay
    893  27000				   -	       lda	(_nr),y
    894  27000				   -cmd5ax
    895  27000				   -	       sta	trackn_portafrqc,x
    896  27000				   -	       ldy	rmtreg3
    897  27000				   -	       bne	cmd5a
    898  27000				   -	       sta	trackn_portafrqa,x
    899  27000				   -cmd5a
    900  27000				   -	       tya
    901  27000				   -	       lsr
    902  27000				   -	       lsr
    903  27000				   -	       lsr
    904  27000				   -	       lsr
    905  27000				   -	       sta	trackn_portaspeed,x
    906  27000				   -	       sta	trackn_portaspeeda,x
    907  27000				   -	       lda	rmtreg3
    908  27000				   -	       and	#$0f
    909  27000				   -	       sta	trackn_portadepth,x
    910  27000				   -	       lda	trackn_note,x
    911  27000				   -	       jmp	cmd0a
    912  27000				   -	       ELSE
    913  27000				   -	       IF	FEAT_COMMAND5
    914  27000				   -	       jmp	rmtpp9
    915  27000				   -	       ENDIF
    916  27000				   -	       ENDIF
    917  27000				   -cmd6
    918  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    919  27000				   -	       lda	rmtreg3
    920  27000				   -	       clc
    921  27000				   -	       adc	trackn_filter,x
    922  27000				   -	       sta	trackn_filter,x
    923  27000				   -	       lda	trackn_note,x
    924  27000				   -	       jmp	cmd0a
    925  27000				   -	       ELSE
    926  27000				   -	       IF	FEAT_COMMAND6
    927  27000				   -	       jmp	rmtpp9
    928  27000				   -	       ENDIF
    929  27000				   -	       ENDIF
    930  27000				   -cmd7
    931  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    932  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    933  27000				   -	       lda	rmtreg3
    934  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    935  27000				   -	       cmp	#$80
    936  27000				   -	       beq	cmd7a
    937  27000				   -	       ENDIF
    938  27000				   -	       sta	trackn_note,x
    939  27000				   -	       jmp	cmd0a
    940  27000				   -	       ENDIF
    941  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    942  27000				   -cmd7a
    943  27000				   -	       lda	trackn_audc,x
    944  27000				   -	       ora	#$f0
    945  27000				   -	       sta	trackn_audc,x
    946  27000				   -	       lda	trackn_note,x
    947  27000				   -	       jmp	cmd0a
    948  27000				   -	       ENDIF
    949  27000				   -	       ENDIF
    950  27000				   -rmtpp9
    951  27000				   -	       IF	FEAT_PORTAMENTO
    952  27000				   -	       lda	trackn_portaspeeda,x
    953  27000				   -	       beq	rmtpp10
    954  27000				   -	       sec
    955  27000				   -	       sbc	#1
    956  27000				   -	       sta	trackn_portaspeeda,x
    957  27000				   -	       bne	rmtpp10
    958  27000				   -	       lda	trackn_portaspeed,x
    959  27000				   -	       sta	trackn_portaspeeda,x
    960  27000				   -	       lda	trackn_portafrqa,x
    961  27000				   -	       cmp	trackn_portafrqc,x
    962  27000				   -	       beq	rmtpp10
    963  27000				   -	       bcs	pps1
    964  27000				   -	       adc	trackn_portadepth,x
    965  27000				   -	       bcs	pps8
    966  27000				   -	       cmp	trackn_portafrqc,x
    967  27000				   -	       bcs	pps8
    968  27000				   -	       jmp	pps9
    969  27000				   -pps1
    970  27000				   -	       sbc	trackn_portadepth,x
    971  27000				   -	       bcc	pps8
    972  27000				   -	       cmp	trackn_portafrqc,x
    973  27000				   -	       bcs	pps9
    974  27000				   -pps8
    975  27000				   -	       lda	trackn_portafrqc,x
    976  27000				   -pps9
    977  27000				   -	       sta	trackn_portafrqa,x
    978  27000				   -rmtpp10
    979  27000				   -	       lda	rmtreg2
    980  27000				   -	       and	#$01
    981  27000				   -	       beq	rmtpp11
    982  27000				   -	       lda	trackn_portafrqa,x
    983  27000				   -	       clc
    984  27000				   -	       adc	trackn_shiftfrq,x
    985  27000				   -	       sta	trackn_audf,x
    986  27000				   -rmtpp11
    987  27000				   -	       ENDIF
    988  27000				   -ppnext
    989  27000				   -	       inx
    990  27000				   -	       cpx	#TRACKS
    991  27000				   -	       beq	rmt_p4
    992  27000				   -	       jmp	rmtpp1
    993  27000				   -rmt_p4
    994  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    995  27000				   -	       ldx	#3
    996  27000				   -	       lda	#0
    997  27000				   -qq0        ora	trackn_audctl,x
    998  27000				   -	       dex
    999  27000				   -	       bpl	qq0
   1000  27000				   -	       sta	v_audctl
   1001  27000				   -qq1
   1002  27000				   -	       ldx	v_audctl
   1003  27000				   -	       ELSE
   1004  27000				   -	       ldx	#0
   1005  27000				   -	       stx	v_audctl
   1006  27000				   -	       ENDIF
   1007  27000				   -	       IF	FEAT_FILTER
   1008  27000				   -	       IF	FEAT_FILTERG0L
   1009  27000				   -	       lda	trackn_command+0
   1010  27000				   -	       bpl	qq2
   1011  27000				   -	       lda	trackn_audc+0
   1012  27000				   -	       and	#$0f
   1013  27000				   -	       beq	qq2
   1014  27000				   -	       lda	trackn_audf+0
   1015  27000				   -	       clc
   1016  27000				   -	       adc	trackn_filter+0
   1017  27000				   -	       sta	trackn_audf+2
   1018  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1019  27000				   -	       lda	trackn_audc+2
   1020  27000				   -	       and	#$10
   1021  27000				   -	       bne	qq1a
   1022  27000				   -	       ENDIF
   1023  27000				   -	       lda	#0
   1024  27000				   -	       sta	trackn_audc+2
   1025  27000				   -qq1a
   1026  27000				   -	       txa
   1027  27000				   -	       ora	#4
   1028  27000				   -	       tax
   1029  27000				   -	       ENDIF
   1030  27000				   -qq2
   1031  27000				   -	       IF	FEAT_FILTERG1L
   1032  27000				   -	       lda	trackn_command+1
   1033  27000				   -	       bpl	qq3
   1034  27000				   -	       lda	trackn_audc+1
   1035  27000				   -	       and	#$0f
   1036  27000				   -	       beq	qq3
   1037  27000				   -	       lda	trackn_audf+1
   1038  27000				   -	       clc
   1039  27000				   -	       adc	trackn_filter+1
   1040  27000				   -	       sta	trackn_audf+3
   1041  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
   1042  27000				   -	       lda	trackn_audc+3
   1043  27000				   -	       and	#$10
   1044  27000				   -	       bne	qq2a
   1045  27000				   -	       ENDIF
   1046  27000				   -	       lda	#0
   1047  27000				   -	       sta	trackn_audc+3
   1048  27000				   -qq2a
   1049  27000				   -	       txa
   1050  27000				   -	       ora	#2
   1051  27000				   -	       tax
   1052  27000				   -	       ENDIF
   1053  27000				   -qq3
   1054  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
   1055  27000				   -	       cpx	v_audctl
   1056  27000				   -	       bne	qq5
   1057  27000				   -	       ENDIF
   1058  27000				   -	       ENDIF
   1059  27000				   -	       IF	FEAT_BASS16
   1060  27000				   -	       IF	FEAT_BASS16G1L
   1061  27000				   -	       lda	trackn_command+1
   1062  27000				   -	       and	#$0e
   1063  27000				   -	       cmp	#6
   1064  27000				   -	       bne	qq4
   1065  27000				   -	       lda	trackn_audc+1
   1066  27000				   -	       and	#$0f
   1067  27000				   -	       beq	qq4
   1068  27000				   -	       ldy	trackn_outnote+1
   1069  27000				   -	       lda	frqtabbasslo,y
   1070  27000				   -	       sta	trackn_audf+0
   1071  27000				   -	       lda	frqtabbasshi,y
   1072  27000				   -	       sta	trackn_audf+1
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
   1074  27000				   -	       lda	trackn_audc+0
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qq3a
   1077  27000				   -	       ENDIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+0
   1080  27000				   -qq3a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#$50
   1083  27000				   -	       tax
   1084  27000				   -	       ENDIF
   1085  27000				   -qq4
   1086  27000				   -	       IF	FEAT_BASS16G3L
   1087  27000				   -	       lda	trackn_command+3
   1088  27000				   -	       and	#$0e
   1089  27000				   -	       cmp	#6
   1090  27000				   -	       bne	qq5
   1091  27000				   -	       lda	trackn_audc+3
   1092  27000				   -	       and	#$0f
   1093  27000				   -	       beq	qq5
   1094  27000				   -	       ldy	trackn_outnote+3
   1095  27000				   -	       lda	frqtabbasslo,y
   1096  27000				   -	       sta	trackn_audf+2
   1097  27000				   -	       lda	frqtabbasshi,y
   1098  27000				   -	       sta	trackn_audf+3
   1099  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1100  27000				   -	       lda	trackn_audc+2
   1101  27000				   -	       and	#$10
   1102  27000				   -	       bne	qq4a
   1103  27000				   -	       ENDIF
   1104  27000				   -	       lda	#0
   1105  27000				   -	       sta	trackn_audc+2
   1106  27000				   -qq4a
   1107  27000				   -	       txa
   1108  27000				   -	       ora	#$28
   1109  27000				   -	       tax
   1110  27000				   -	       ENDIF
   1111  27000				   -	       ENDIF
   1112  27000				   -qq5
   1113  27000				   -	       stx	v_audctl
   1114  27000				   -	       IF	STEREO8T
   1115  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1116  27000				   -	       ldx	#3
   1117  27000				   -	       lda	#0
   1118  27000				   -qs0        ora	trackn_audctl+4,x
   1119  27000				   -	       dex
   1120  27000				   -	       bpl	qs0
   1121  27000				   -	       sta	v_audctl2
   1122  27000				   -qs1
   1123  27000				   -	       ldx	v_audctl2
   1124  27000				   -	       ELSE
   1125  27000				   -	       ldx	#0
   1126  27000				   -	       stx	v_audctl2
   1127  27000				   -	       ENDIF
   1128  27000				   -	       IF	FEAT_FILTER
   1129  27000				   -	       IF	FEAT_FILTERG0R
   1130  27000				   -	       lda	trackn_command+0+4
   1131  27000				   -	       bpl	qs2
   1132  27000				   -	       lda	trackn_audc+0+4
   1133  27000				   -	       and	#$0f
   1134  27000				   -	       beq	qs2
   1135  27000				   -	       lda	trackn_audf+0+4
   1136  27000				   -	       clc
   1137  27000				   -	       adc	trackn_filter+0+4
   1138  27000				   -	       sta	trackn_audf+2+4
   1139  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1140  27000				   -	       lda	trackn_audc+2+4
   1141  27000				   -	       and	#$10
   1142  27000				   -	       bne	qs1a
   1143  27000				   -	       ENDIF
   1144  27000				   -	       lda	#0
   1145  27000				   -	       sta	trackn_audc+2+4
   1146  27000				   -qs1a
   1147  27000				   -	       txa
   1148  27000				   -	       ora	#4
   1149  27000				   -	       tax
   1150  27000				   -	       ENDIF
   1151  27000				   -qs2
   1152  27000				   -	       IF	FEAT_FILTERG1R
   1153  27000				   -	       lda	trackn_command+1+4
   1154  27000				   -	       bpl	qs3
   1155  27000				   -	       lda	trackn_audc+1+4
   1156  27000				   -	       and	#$0f
   1157  27000				   -	       beq	qs3
   1158  27000				   -	       lda	trackn_audf+1+4
   1159  27000				   -	       clc
   1160  27000				   -	       adc	trackn_filter+1+4
   1161  27000				   -	       sta	trackn_audf+3+4
   1162  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1163  27000				   -	       lda	trackn_audc+3+4
   1164  27000				   -	       and	#$10
   1165  27000				   -	       bne	qs2a
   1166  27000				   -	       ENDIF
   1167  27000				   -	       lda	#0
   1168  27000				   -	       sta	trackn_audc+3+4
   1169  27000				   -qs2a
   1170  27000				   -	       txa
   1171  27000				   -	       ora	#2
   1172  27000				   -	       tax
   1173  27000				   -	       ENDIF
   1174  27000				   -qs3
   1175  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1176  27000				   -	       cpx	v_audctl2
   1177  27000				   -	       bne	qs5
   1178  27000				   -	       ENDIF
   1179  27000				   -	       ENDIF
   1180  27000				   -	       IF	FEAT_BASS16
   1181  27000				   -	       IF	FEAT_BASS16G1R
   1182  27000				   -	       lda	trackn_command+1+4
   1183  27000				   -	       and	#$0e
   1184  27000				   -	       cmp	#6
   1185  27000				   -	       bne	qs4
   1186  27000				   -	       lda	trackn_audc+1+4
   1187  27000				   -	       and	#$0f
   1188  27000				   -	       beq	qs4
   1189  27000				   -	       ldy	trackn_outnote+1+4
   1190  27000				   -	       lda	frqtabbasslo,y
   1191  27000				   -	       sta	trackn_audf+0+4
   1192  27000				   -	       lda	frqtabbasshi,y
   1193  27000				   -	       sta	trackn_audf+1+4
   1194  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1195  27000				   -	       lda	trackn_audc+0+4
   1196  27000				   -	       and	#$10
   1197  27000				   -	       bne	qs3a
   1198  27000				   -	       ENDIF
   1199  27000				   -	       lda	#0
   1200  27000				   -	       sta	trackn_audc+0+4
   1201  27000				   -qs3a
   1202  27000				   -	       txa
   1203  27000				   -	       ora	#$50
   1204  27000				   -	       tax
   1205  27000				   -	       ENDIF
   1206  27000				   -qs4
   1207  27000				   -	       IF	FEAT_BASS16G3R
   1208  27000				   -	       lda	trackn_command+3+4
   1209  27000				   -	       and	#$0e
   1210  27000				   -	       cmp	#6
   1211  27000				   -	       bne	qs5
   1212  27000				   -	       lda	trackn_audc+3+4
   1213  27000				   -	       and	#$0f
   1214  27000				   -	       beq	qs5
   1215  27000				   -	       ldy	trackn_outnote+3+4
   1216  27000				   -	       lda	frqtabbasslo,y
   1217  27000				   -	       sta	trackn_audf+2+4
   1218  27000				   -	       lda	frqtabbasshi,y
   1219  27000				   -	       sta	trackn_audf+3+4
   1220  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1221  27000				   -	       lda	trackn_audc+2+4
   1222  27000				   -	       and	#$10
   1223  27000				   -	       bne	qs4a
   1224  27000				   -	       ENDIF
   1225  27000				   -	       lda	#0
   1226  27000				   -	       sta	trackn_audc+2+4
   1227  27000				   -qs4a
   1228  27000				   -	       txa
   1229  27000				   -	       ora	#$28
   1230  27000				   -	       tax
   1231  27000				   -	       ENDIF
   1232  27000				   -	       ENDIF
   1233  27000				   -qs5
   1234  27000				   -	       stx	v_audctl2
   1235  27000				   -	       ENDIF
   1236  27000				   -rmt_p5
   1237  27000				   -	       lda	smc_silence_instrspeed
   1238  27000				   -	       rts
   1239  27000				   -SetPokey
   1240  27000				   -	       IF	STEREO8T
   1241  27000				   -	       ldy	v_audctl2
   1242  27000				   -	       lda	trackn_audf+0+4
   1243  27000				   -	       ldx	trackn_audf+0
   1244  27000				   -	       sta	POKEY_BASE_S+$00
   1245  27000				   -	       stx	POKEY_BASE+$00
   1246  27000				   -	       lda	trackn_audc+0+4
   1247  27000				   -	       ldx	trackn_audc+0
   1248  27000				   -	       sta	POKEY_BASE_S+$01
   1249  27000				   -	       stx	POKEY_BASE+$01
   1250  27000				   -	       lda	trackn_audf+1+4
   1251  27000				   -	       ldx	trackn_audf+1
   1252  27000				   -	       sta	POKEY_BASE_S+$02
   1253  27000				   -	       stx	POKEY_BASE+$02
   1254  27000				   -	       lda	trackn_audc+1+4
   1255  27000				   -	       ldx	trackn_audc+1
   1256  27000				   -	       sta	POKEY_BASE_S+$03
   1257  27000				   -	       stx	POKEY_BASE+$03
   1258  27000				   -	       lda	trackn_audf+2+4
   1259  27000				   -	       ldx	trackn_audf+2
   1260  27000				   -	       sta	POKEY_BASE_S+$04
   1261  27000				   -	       stx	POKEY_BASE+$04
   1262  27000				   -	       lda	trackn_audc+2+4
   1263  27000				   -	       ldx	trackn_audc+2
   1264  27000				   -	       sta	POKEY_BASE_S+$05
   1265  27000				   -	       stx	POKEY_BASE+$05
   1266  27000				   -	       lda	trackn_audf+3+4
   1267  27000				   -	       ldx	trackn_audf+3
   1268  27000				   -	       sta	POKEY_BASE_S+$06
   1269  27000				   -	       stx	POKEY_BASE+$06
   1270  27000				   -	       lda	trackn_audc+3+4
   1271  27000				   -	       ldx	trackn_audc+3
   1272  27000				   -	       sta	POKEY_BASE_S+$07
   1273  27000				   -	       stx	POKEY_BASE+$07
   1274  27000				   -	       lda	v_audctl
   1275  27000				   -	       sty	POKEY_BASE_S+$08
   1276  27000				   -	       sta	POKEY_BASE+$08
   1277  27000				   -	       ELSE
   1278  27000				   -
   1279  27000				   -	       ifconst	RMTVOLUME
   1280  27000				   -	       lda	rmtvolume
   1281  27000				   -	       sta	fourbitfadevalueint
   1282  27000				   -	       endif
   1283  27000				   -	       ldy	v_audctl
   1284  27000				   -	       ldx	trackn_audf+0
   1285  27000				   -	       lda	trackn_audc+0
   1286  27000				   -	       ifconst	RMTVOLUME
   1287  27000				   -	       jsr	fourbitfadeint
   1288  27000				   -	       endif
   1289  27000				   -	       stx	POKEY_BASE+$00+0
   1290  27000				   -	       if	HARD_OF_HEARING
   1291  27000				   -	       stx	POKEY_BASE+$00+0
   1292  27000				   -	       endif
   1293  27000				   -	       sta	POKEY_BASE+$01+0
   1294  27000				   -	       if	HARD_OF_HEARING
   1295  27000				   -	       sta	POKEY_BASE+$01+0
   1296  27000				   -	       endif
   1297  27000				   -
   1298  27000				   -	       ldx	trackn_audf+1
   1299  27000				   -	       lda	trackn_audc+1
   1300  27000				   -	       ifconst	RMTVOLUME
   1301  27000				   -	       jsr	fourbitfadeint
   1302  27000				   -	       endif
   1303  27000				   -	       stx	POKEY_BASE+$00+2
   1304  27000				   -	       if	HARD_OF_HEARING
   1305  27000				   -	       stx	POKEY_BASE+$00+2
   1306  27000				   -	       endif
   1307  27000				   -	       sta	POKEY_BASE+$01+2
   1308  27000				   -	       if	HARD_OF_HEARING
   1309  27000				   -	       sta	POKEY_BASE+$01+2
   1310  27000				   -	       endif
   1311  27000				   -
   1312  27000				   -	       ldx	trackn_audf+2
   1313  27000				   -	       lda	trackn_audc+2
   1314  27000				   -	       ifconst	RMTVOLUME
   1315  27000				   -	       jsr	fourbitfadeint
   1316  27000				   -	       endif
   1317  27000				   -	       stx	POKEY_BASE+$00+4
   1318  27000				   -	       if	HARD_OF_HEARING
   1319  27000				   -	       stx	POKEY_BASE+$00+4
   1320  27000				   -	       endif
   1321  27000				   -	       sta	POKEY_BASE+$01+4
   1322  27000				   -	       if	HARD_OF_HEARING
   1323  27000				   -	       sta	POKEY_BASE+$01+4
   1324  27000				   -	       endif
   1325  27000				   -
   1326  27000				   -	       ldx	trackn_audf+3
   1327  27000				   -	       lda	trackn_audc+3
   1328  27000				   -	       ifconst	RMTVOLUME
   1329  27000				   -	       jsr	fourbitfadeint
   1330  27000				   -	       endif
   1331  27000				   -	       stx	POKEY_BASE+$00+6
   1332  27000				   -	       if	HARD_OF_HEARING
   1333  27000				   -	       stx	POKEY_BASE+$00+6
   1334  27000				   -	       endif
   1335  27000				   -	       sta	POKEY_BASE+$01+6
   1336  27000				   -	       if	HARD_OF_HEARING
   1337  27000				   -	       sta	POKEY_BASE+$01+6
   1338  27000				   -	       endif
   1339  27000				   -
   1340  27000				   -	       sty	POKEY_BASE+$08
   1341  27000				   -	       if	HARD_OF_HEARING
   1342  27000				   -	       sty	POKEY_BASE+$08
   1343  27000				   -	       endif
   1344  27000				   -
   1345  27000				   -	       ENDIF
   1346  27000				   -	       rts
   1347  27000				   -SetUpInstrumentY2
   1348  27000				   -	       lda	(p_instrstable),y
   1349  27000				   -	       sta	trackn_instrdb,x
   1350  27000				   -	       sta	_nt
   1351  27000				   -	       iny
   1352  27000				   -	       lda	(p_instrstable),y
   1353  27000				   -	       sta	trackn_instrhb,x
   1354  27000				   -	       sta	_nt+1
   1355  27000				   -	       ldy	#0
   1356  27000				   -	       lda	(_nt),y
   1357  27000				   -	       sta	trackn_tableend,x
   1358  27000				   -	       clc
   1359  27000				   -	       adc	#1
   1360  27000				   -	       sta	trackn_instridx,x
   1361  27000				   -	       iny
   1362  27000				   -	       lda	(_nt),y
   1363  27000				   -	       sta	trackn_tablelop,x
   1364  27000				   -	       iny
   1365  27000				   -	       lda	(_nt),y
   1366  27000				   -	       sta	trackn_instrlen,x
   1367  27000				   -	       iny
   1368  27000				   -	       lda	(_nt),y
   1369  27000				   -	       sta	trackn_instrlop,x
   1370  27000				   -	       iny
   1371  27000				   -	       lda	(_nt),y
   1372  27000				   -	       sta	trackn_tabletypespeed,x
   1373  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1374  27000				   -	       and	#$3f
   1375  27000				   -	       ENDIF
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -	       IF	FEAT_TABLEMODE
   1378  27000				   -	       lda	(_nt),y
   1379  27000				   -	       and	#$40
   1380  27000				   -	       sta	trackn_tablemode,x
   1381  27000				   -	       ENDIF
   1382  27000				   -	       iny
   1383  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1384  27000				   -	       lda	(_nt),y
   1385  27000				   -	       sta	trackn_audctl,x
   1386  27000				   -	       ENDIF
   1387  27000				   -	       iny
   1388  27000				   -	       lda	(_nt),y
   1389  27000				   -	       sta	trackn_volumeslidedepth,x
   1390  27000				   -	       iny
   1391  27000				   -	       lda	(_nt),y
   1392  27000				   -	       sta	trackn_volumemin,x
   1393  27000				   -	       iny
   1394  27000				   -	       lda	(_nt),y
   1395  27000				   -	       sta	trackn_effdelay,x
   1396  27000				   -	       iny
   1397  27000				   -	       lda	(_nt),y
   1398  27000				   -	       tay
   1399  27000				   -	       lda	vibtabbeg,y
   1400  27000				   -	       sta	trackn_effvibratoa,x
   1401  27000				   -	       sta	trackn_effvibratobeg,x
   1402  27000				   -	       lda	vibtabbeg+1,y
   1403  27000				   -	       sta	trackn_effvibratoend,x
   1404  27000				   -	       ldy	#10
   1405  27000				   -	       lda	(_nt),y
   1406  27000				   -	       sta	trackn_effshift,x
   1407  27000				   -	       lda	#128
   1408  27000				   -	       sta	trackn_volumeslidevalue,x
   1409  27000				   -	       lda	#0
   1410  27000				   -	       sta	trackn_instrreachend,x
   1411  27000				   -	       sta	trackn_shiftfrq,x
   1412  27000				   -	       lda	#INSTRPAR
   1413  27000				   -	       sta	trackn_tablea,x
   1414  27000				   -	       tay
   1415  27000				   -	       lda	(_nt),y
   1416  27000				   -	       sta	trackn_tablenote,x
   1417  27000				   -	       IF	FEAT_FILTER
   1418  27000				   -	       lda	#1
   1419  27000				   -	       sta	trackn_filter,x
   1420  27000				   -	       ENDIF
   1421  27000				   -	       rts
   1422  27000				   -InstrumentsEffects
   1423  27000				   -	       lda	trackn_effdelay,x
   1424  27000				   -	       beq	ei2
   1425  27000				   -	       tay
   1426  27000				   -	       dey
   1427  27000				   -	       bne	ei1
   1428  27000				   -	       lda	trackn_shiftfrq,x
   1429  27000				   -	       clc
   1430  27000				   -	       adc	trackn_effshift,x
   1431  27000				   -	       clc
   1432  27000				   -	       ldy	trackn_effvibratoa,x
   1433  27000				   -	       adc	vib0,y
   1434  27000				   -	       sta	trackn_shiftfrq,x
   1435  27000				   -	       iny
   1436  27000				   -	       tya
   1437  27000				   -	       cmp	trackn_effvibratoend,x
   1438  27000				   -	       bne	ei1a
   1439  27000				   -	       lda	trackn_effvibratobeg,x
   1440  27000				   -ei1a
   1441  27000				   -	       sta	trackn_effvibratoa,x
   1442  27000				   -	       jmp	ei2
   1443  27000				   -ei1
   1444  27000				   -	       tya
   1445  27000				   -	       sta	trackn_effdelay,x
   1446  27000				   -ei2
   1447  27000				   -	       lda	trackn_tableend,x
   1448  27000				   -	       cmp	#INSTRPAR
   1449  27000				   -	       beq	ei3
   1450  27000				   -	       lda	trackn_tablespeeda,x
   1451  27000				   -	       bpl	ei2f
   1452  27000				   -ei2c
   1453  27000				   -	       lda	trackn_tablea,x
   1454  27000				   -	       clc
   1455  27000				   -	       adc	#1
   1456  27000				   -	       cmp	trackn_tableend,x
   1457  27000				   -	       bcc	ei2a
   1458  27000				   -	       beq	ei2a
   1459  27000				   -	       lda	trackn_tablelop,x
   1460  27000				   -ei2a
   1461  27000				   -	       sta	trackn_tablea,x
   1462  27000				   -	       lda	trackn_instrdb,x
   1463  27000				   -	       sta	_nt
   1464  27000				   -	       lda	trackn_instrhb,x
   1465  27000				   -	       sta	_nt+1
   1466  27000				   -	       ldy	trackn_tablea,x
   1467  27000				   -	       lda	(_nt),y
   1468  27000				   -	       IF	FEAT_TABLEMODE
   1469  27000				   -	       ldy	trackn_tablemode,x
   1470  27000				   -	       beq	ei2e
   1471  27000				   -	       clc
   1472  27000				   -	       adc	trackn_tablenote,x
   1473  27000				   -ei2e
   1474  27000				   -	       ENDIF
   1475  27000				   -	       sta	trackn_tablenote,x
   1476  27000				   -	       lda	trackn_tabletypespeed,x
   1477  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1478  27000				   -	       and	#$3f
   1479  27000				   -	       ENDIF
   1480  27000				   -ei2f
   1481  27000				   -	       sec
   1482  27000				   -	       sbc	#1
   1483  27000				   -	       sta	trackn_tablespeeda,x
   1484  27000				   -ei3
   1485  27000				   -	       lda	trackn_instrreachend,x
   1486  27000				   -	       bpl	ei4
   1487  27000				   -	       lda	trackn_volume,x
   1488  27000				   -	       beq	ei4
   1489  27000				   -	       cmp	trackn_volumemin,x
   1490  27000				   -	       beq	ei4
   1491  27000				   -	       bcc	ei4
   1492  27000				   -	       tay
   1493  27000				   -	       lda	trackn_volumeslidevalue,x
   1494  27000				   -	       clc
   1495  27000				   -	       adc	trackn_volumeslidedepth,x
   1496  27000				   -	       sta	trackn_volumeslidevalue,x
   1497  27000				   -	       bcc	ei4
   1498  27000				   -	       tya
   1499  27000				   -	       sbc	#16
   1500  27000				   -	       sta	trackn_volume,x
   1501  27000				   -ei4
   1502  27000				   -	       jmp	returnfromInstrumentsEffects
   1503  27000				   -
   1504  27000				   -rmtmoduleend
   1505  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1506  27000				   -	       echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1507  27000				   -
   1508  27000					       endif		; RMT
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1859  27000					       endif
   1860  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1862  27000					       endif
   1863  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -	       ifconst	pokeysfxsupport
     19  27000				   -
     20  27000				   -checkpokeyplaying
     21  27000				   -	       ldx	#6
     22  27000				   -checkpokeyplayingloop
     23  27000				   -	       lda	pokey1pointlo,x
     24  27000				   -	       ora	pokey1pointhi,x
     25  27000				   -	       beq	pokeychannelinactive
     26  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     27  27000				   -pokeychannelinactive
     28  27000				   -	       dex
     29  27000				   -	       dex
     30  27000				   -	       bpl	checkpokeyplayingloop
     31  27000				   -	       rts
     32  27000				   -
     33  27000				   -playpokeysfxA
     34  27000				   -	       txa
     35  27000				   -	       tay
     36  27000				   -	       lda	pokey1tick,x
     37  27000				   -	       beq	playpokeysfxAcont
     38  27000				   -	       sec
     39  27000				   -	       sbc	#1
     40  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     41  27000				   -	       rts
     42  27000				   -
     43  27000				   -playpokeysfxAcont
     44  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     45  27000				   -	       sta	pokey1tick,x
     46  27000				   -
     47  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     48  27000				   -	       beq	playpokeysfxAcont2
     49  27000				   -	       sec
     50  27000				   -	       sbc	#1
     51  27000				   -	       sta	pokey1priority,x
     52  27000				   -playpokeysfxAcont2
     53  27000				   -
     54  27000				   -			; *** FREQUENCY
     55  27000				   -	       lda	(pokey1pointlo,x)
     56  27000				   -	       sta	inttemp1
     57  27000				   -	       clc
     58  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     59  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     60  27000				   -
     61  27000				   -			;advance the data pointer +1
     62  27000				   -	       inc	pokey1pointlo,x
     63  27000				   -	       bne	skippokeyhiinc1
     64  27000				   -	       inc	pokey1pointhi,x
     65  27000				   -skippokeyhiinc1
     66  27000				   -
     67  27000				   -			; *** WAVE
     68  27000				   -	       lda	(pokey1pointlo,x)
     69  27000				   -	       asl
     70  27000				   -	       asl
     71  27000				   -	       asl
     72  27000				   -	       asl		; x16
     73  27000				   -
     74  27000				   -			;advance the data pointer +1
     75  27000				   -	       inc	pokey1pointlo,x
     76  27000				   -	       bne	skippokeyhiinc2
     77  27000				   -	       inc	pokey1pointhi,x
     78  27000				   -skippokeyhiinc2
     79  27000				   -
     80  27000				   -	       ora	(pokey1pointlo,x)
     81  27000				   -	       iny
     82  27000				   -	       sta	(pokeybaselo),y
     83  27000				   -
     84  27000				   -	       ora	inttemp1	; check if F|C|V=0
     85  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     86  27000				   -
     87  27000				   -			; advance the pointer +1, on to the next sound chunk
     88  27000				   -	       inc	pokey1pointlo,x
     89  27000				   -	       bne	skippokeyhiinc3
     90  27000				   -	       inc	pokey1pointhi,x
     91  27000				   -skippokeyhiinc3
     92  27000				   -	       rts
     93  27000				   -
     94  27000				   -zeropokeypoint
     95  27000				   -	       sta	pokey1pointlo,x
     96  27000				   -	       sta	pokey1pointhi,x
     97  27000				   -	       sta	pokey1priority,x
     98  27000				   -	       rts
     99  27000				   -
    100  27000				   -schedulepokeysfx
    101  27000				   -	       ldx	#6
    102  27000				   -schedulepokeysfxloop
    103  27000				   -	       lda	pokey1pointlo,x
    104  27000				   -	       ora	pokey1pointhi,x
    105  27000				   -	       bne	schedulespokeysearch
    106  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    107  27000				   -schedulespokeysearch
    108  27000				   -	       dex
    109  27000				   -	       dex
    110  27000				   -	       bpl	schedulepokeysfxloop
    111  27000				   -
    112  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    113  27000				   -	       ldy	#1
    114  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    115  27000				   -	       bne	schedulepokeysfxcont1
    116  27000				   -	       rts		; ...and skip it if it's 0 priority
    117  27000				   -schedulepokeysfxcont1
    118  27000				   -
    119  27000				   -			; figure out which current sound has the lowest priority...
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	temp8
    122  27000				   -	       lda	pokey1priority
    123  27000				   -	       sta	temp9
    124  27000				   -	       ldx	#6
    125  27000				   -findlowprioritypokeyloop
    126  27000				   -	       lda	pokey1priority,x
    127  27000				   -	       cmp	temp9
    128  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    129  27000				   -	       sta	temp9
    130  27000				   -	       stx	temp8
    131  27000				   -findlowprioritypokeyloopcontinue
    132  27000				   -	       dex
    133  27000				   -	       dex
    134  27000				   -	       bne	findlowprioritypokeyloop
    135  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    136  27000				   -
    137  27000				   -schedulepokeyX
    138  27000				   -			;called with X=2*pokey channel to play on...
    139  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    140  27000				   -	       lda	(sfxinstrumentlo),y
    141  27000				   -	       sta	pokey1priority,x
    142  27000				   -	       iny
    143  27000				   -	       lda	(sfxinstrumentlo),y
    144  27000				   -	       sta	pokey1frames,x
    145  27000				   -
    146  27000				   -	       lda	sfxinstrumentlo
    147  27000				   -	       clc
    148  27000				   -	       adc	#3
    149  27000				   -	       sta	pokey1pointlo,x
    150  27000				   -	       lda	sfxinstrumenthi
    151  27000				   -	       adc	#0
    152  27000				   -	       sta	pokey1pointhi,x
    153  27000				   -	       lda	sfxpitchoffset
    154  27000				   -	       sta	pokey1offset,x
    155  27000				   -	       lda	#0
    156  27000				   -	       sta	pokey1tick,x
    157  27000				   -	       rts
    158  27000				   -	       else
    159  27000				   -schedulepokeysfx		; just some stubs
    160  27000				   -checkpokeyplaying
    161  27000				   -	       rts
    162  27000				   -	       endif		; pokeysfxsupport
    163  27000				   -
    164  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    165  27000				   -			; and the standard $4000 location.
    166  27000				   -			; if pokey the pokey is present, this routine will reset it.
    167  27000				   -	       ifconst	pokeyaddress
    168  27000				   -detectpokeylocation
    169  27000				   -	       lda	#<pokeyaddress
    170  27000				   -	       sta	pokeybaselo
    171  27000				   -	       lda	#>pokeyaddress
    172  27000				   -	       sta	pokeybasehi
    173  27000				   -	       lda	#$ff
    174  27000				   -	       sta	pokeydetected
    175  27000				   -
    176  27000				   -	       if	pokeyaddress = $450
    177  27000				   -	       lda	XCTRL1s
    178  27000				   -	       ora	#%00010100
    179  27000				   -	       sta	XCTRL1s
    180  27000				   -	       sta	XCTRL1
    181  27000				   -	       endif
    182  27000				   -
    183  27000				   -
    184  27000				   -	       lda	#0
    185  27000				   -	       ldy	#15
    186  27000				   -clearpokeyloop
    187  27000				   -	       sta	(pokeybase),y
    188  27000				   -	       dey
    189  27000				   -	       bpl	clearpokeyloop
    190  27000				   -			; take pokey out of reset...
    191  27000				   -	       ldy	#PSKCTL
    192  27000				   -	       lda	#3
    193  27000				   -	       sta	(pokeybase),y
    194  27000				   -	       ldy	#PAUDCTL
    195  27000				   -	       lda	#0
    196  27000				   -	       sta	(pokeybase),y
    197  27000				   -	       rts
    198  27000				   -	       else		; !pokeyaddress
    199  27000				   -detectpokeylocation
    200  27000				   -			;XBoard/XM...
    201  27000				   -	       ldx	#2
    202  27000				   -detectpokeyloop
    203  27000				   -	       lda	XCTRL1s
    204  27000				   -	       ora	#%00010100
    205  27000				   -	       and	POKEYXMMASK,x
    206  27000				   -	       sta	XCTRL1s
    207  27000				   -	       sta	XCTRL1
    208  27000				   -
    209  27000				   -	       lda	POKEYCHECKLO,x
    210  27000				   -	       sta	pokeybaselo
    211  27000				   -	       lda	POKEYCHECKHI,x
    212  27000				   -	       sta	pokeybasehi
    213  27000				   -	       jsr	checkforpokey
    214  27000				   -	       lda	pokeydetected
    215  27000				   -	       beq	foundpokeychip
    216  27000				   -	       dex
    217  27000				   -	       bpl	detectpokeyloop
    218  27000				   -foundpokeychip
    219  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    220  27000				   -	       sta	pokeydetected
    221  27000				   -	       rts
    222  27000				   -
    223  27000				   -POKEYXMMASK
    224  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    225  27000				   -	       .byte	%11111111, %11101111, %11101111
    226  27000				   -
    227  27000				   -POKEYCHECKLO
    228  27000				   -	       .byte	<$0450, <$0450, <$4000
    229  27000				   -POKEYCHECKHI
    230  27000				   -	       .byte	>$0450, >$0450, >$4000
    231  27000				   -
    232  27000				   -checkforpokey
    233  27000				   -	       ldy	#$0f
    234  27000				   -	       lda	#$00
    235  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    236  27000				   -resetpokeyregistersloop
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -	       dey
    239  27000				   -	       bpl	resetpokeyregistersloop
    240  27000				   -
    241  27000				   -	       ldy	#PAUDCTL
    242  27000				   -	       sta	(pokeybase),y
    243  27000				   -	       ldy	#PSKCTL
    244  27000				   -	       sta	(pokeybase),y
    245  27000				   -
    246  27000				   -			; let the dust settle...
    247  27000				   -	       nop
    248  27000				   -	       nop
    249  27000				   -	       nop
    250  27000				   -
    251  27000				   -	       lda	#4
    252  27000				   -	       sta	temp9
    253  27000				   -pokeycheckloop1
    254  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    255  27000				   -	       ldy	#PRANDOM
    256  27000				   -	       lda	(pokeybase),y
    257  27000				   -	       cmp	#$ff
    258  27000				   -	       bne	nopokeydetected
    259  27000				   -	       dec	temp9
    260  27000				   -	       bne	pokeycheckloop1
    261  27000				   -
    262  27000				   -			; take pokey out of reset...
    263  27000				   -	       ldy	#PSKCTL
    264  27000				   -	       lda	#3
    265  27000				   -	       sta	(pokeybase),y
    266  27000				   -	       ldy	#PAUDCTL
    267  27000				   -	       lda	#0
    268  27000				   -	       sta	(pokeybase),y
    269  27000				   -
    270  27000				   -			; let the dust settle again...
    271  27000				   -	       nop
    272  27000				   -	       nop
    273  27000				   -	       nop
    274  27000				   -
    275  27000				   -	       lda	#4
    276  27000				   -	       sta	temp9
    277  27000				   -pokeycheckloop2
    278  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    279  27000				   -	       ldy	#PRANDOM
    280  27000				   -	       lda	(pokeybase),y
    281  27000				   -	       cmp	#$ff
    282  27000				   -	       beq	skippokeycheckreturn
    283  27000				   -	       rts
    284  27000				   -skippokeycheckreturn
    285  27000				   -	       dec	temp9
    286  27000				   -	       bne	pokeycheckloop2
    287  27000				   -nopokeydetected
    288  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    289  27000				   -	       rts
    290  27000				   -
    291  27000				   -	       endif		; !pokeyaddress
    292  27000				   -
    293  27000				   -pokeysoundmoduleend
    294  27000				   -
    295  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes of rom)"
    296  27000				   -
    297  27000					       endif		; pokeysupport
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1865  27000					       endif
   1866  27000					       ifnconst	included.snes2atari.asm
------- FILE snes2atari.asm LEVEL 2 PASS 3
      0  27000					       include	snes2atari.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000					       ifconst	SNES2ATARISUPPORT
      4  27000				    snes2atarimodulestart
      5  27000
      6  27000				    SNES_CLOCK_PORT_BIT
      7  27000			10 01		       .byte.b	$10,$01
      8  27002				    SNES_CTLSWA_MASK
      9  27002			30 03		       .byte.b	$30,$03
     10  27004				    SNES_CTLSWA_SIGNAL
     11  27004			c0 0c		       .byte.b	$C0,$0C
     12  27006
     13  27006							; Probe each port for SNES, and see if autodetection succeeds anywhere.
     14  27006				    SNES_AUTODETECT
     15  27006				   -	       ifconst	HSSUPPORT
     16  27006				   -			; ** an atarivox might be plugged in, so we skip scanning the second
     17  27006				   -			; ** port for a snes if vox was detected...
     18  27006				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
     19  27006				   -	       lsr
     20  27006				   -	       and	#1
     21  27006				   -	       eor	#1
     22  27006				   -	       tax
     23  27006					       else
     24  27006			a2 01		       ldx	#1
     25  27008					       endif		; HSSUPPORT
     26  27008
     27  27008				    SNES_AUTODETECT_LOOP
     28  27008				   -	       ifnconst	MULTIBUTTON	; snesdetect shouldn't be used in multibutton mode
     29  27008				   -	       lda	#1	; proline
     30  27008				   -	       sta	port0control,x
     31  27008				   -	       jsr	setportforinput
     32  27008				   -	       jsr	setonebuttonmode
     33  27008				   -	       jsr	SNES_READ
     34  27008				   -	       lda	snesdetected0,x
     35  27008				   -	       bne	SNES_AUTODETECT_FOUND
     36  27008				   -			; detection failed
     37  27008				   -	       jsr	setportforinput
     38  27008				   -	       jsr	settwobuttonmode
     39  27008				   -	       dex
     40  27008				   -	       bpl	SNES_AUTODETECT_LOOP
     41  27008				   -	       rts
     42  27008				   -SNES_AUTODETECT_FOUND
     43  27008				   -	       lda	#11	; formally set the snes controller
     44  27008				   -	       sta	port0control,x
     45  27008				   -	       stx	snesport
     46  27008					       endif		; !MULTIBUTTON
     47  27008			60		       rts
     48  27009					       endif		; SNES2ATARISUPPORT
     49  27009
     50  27009				    snes2atarihandler
     51  27009					       ifconst	SNES2ATARISUPPORT
     52  27009				    SNES2ATARI
     53  27009			20 0f f0	       jsr	SNES_READ
     54  2700c			4c 20 f2	       jmp	buttonreadloopreturn
     55  2700f
     56  2700f				    SNES_READ
     57  2700f							; x=0 for left port, x=1 for right
     58  2700f			bd b8 01	       lda	port0control,x
     59  27012			c9 0b		       cmp	#11	; snes
     60  27014			d0 05		       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
     61  27016			bd be 01	       lda	snesdetected0,x
     62  27019			d0 03		       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
     63  2701b				    snes2atari_signal_go
     64  2701b			20 eb f0	       jsr	SNES2ATARI_SIGNAL
     65  2701e				    snes2atari_signal_skip
     66  2701e
     67  2701e			ad 81 02	       lda	CTLSWA
     68  27021			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     69  27024			1d 02 f0	       ora	SNES_CTLSWA_MASK,x
     70  27027			8d 81 02	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     71  2702a
     72  2702a			ad 80 02	       lda	SWCHA
     73  2702d			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     74  27030			1d 02 f0	       ora	SNES_CTLSWA_MASK,x
     75  27033
     76  27033			8d 80 02	       sta	SWCHA	; latch+clock high
     77  27036			ea		       nop
     78  27037			ea		       nop
     79  27038			ea		       nop
     80  27039			ea		       nop
     81  2703a			ea		       nop
     82  2703b			ea		       nop
     83  2703c			ea		       nop
     84  2703d			ad 80 02	       lda	SWCHA
     85  27040			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     86  27043			8d 80 02	       sta	SWCHA	; latch and clock low
     87  27046			a0 10		       ldy	#16	; 16 bits
     88  27048				    SNES2ATARILOOP
     89  27048			36 0c		       rol	INPT4,x	; sample data into carry
     90  2704a			ad 80 02	       lda	SWCHA
     91  2704d			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     92  27050			1d 00 f0	       ora	SNES_CLOCK_PORT_BIT,x
     93  27053			8d 80 02	       sta	SWCHA	; clock low
     94  27056			3e ba 01	       rol	snes2atari0lo,x
     95  27059			3e bc 01	       rol	snes2atari0hi,x
     96  2705c			ad 80 02	       lda	SWCHA
     97  2705f			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     98  27062			8d 80 02	       sta	SWCHA	; latch and clock low
     99  27065			88		       dey		; next bit
    100  27066			d0 e0		       bne	SNES2ATARILOOP
    101  27068			36 0c		       rol	INPT4,x	; 17th bit should be lo if controller is there.
    102  2706a			2a		       rol		; 17th snes bit into A low bit
    103  2706b			5d ba 01	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
    104  2706e			29 01		       and	#1
    105  27070			9d be 01	       sta	snesdetected0,x
    106  27073			f0 0f		       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
    107  27075			8e c2 01	       stx	snesport	; snesport keeps the index of the latest autodetected controller
    108  27078			ad 80 02	       lda	SWCHA
    109  2707b			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    110  2707e			1d 00 f0	       ora	SNES_CLOCK_PORT_BIT,x
    111  27081			4c 84 f0	       jmp	SNES_STOP_CLOCK
    112  27084				    SNES_STOP_CLOCK
    113  27084			8d 80 02	       sta	SWCHA	; clock low
    114  27087			ad 81 02	       lda	CTLSWA
    115  2708a			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    116  2708d							;ora SNES_CLOCK_PORT_BIT,x
    117  2708d			8d 81 02	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
    118  27090					       ifconst	MULTIBUTTON
    119  27090			bd be 01	       lda	snesdetected0,x
    120  27093			d0 08		       bne	snesexit
    121  27095			a9 01		       lda	#1	; proline
    122  27097			9d b8 01	       sta	port0control,x
    123  2709a			4c b9 f6	       jmp	settwobuttonmode
    124  2709d				    snesexit
    125  2709d			a9 06		       lda	#6
    126  2709f			9d c3 01	       sta	multibuttoncount0,x
    127  270a2							; stuff directions into sSWCHA nibble and buttons into sINPT1,x...
    128  270a2			bd 0f f1	       lda	s2a_joyshiftcount,x
    129  270a5			a8		       tay
    130  270a6			bd bc 01	       lda	snes2atari0hi,x
    131  270a9				    snesjoypadloop
    132  270a9			4a		       lsr
    133  270aa			26 dd		       rol	inttemp6
    134  270ac			88		       dey
    135  270ad			10 fa		       bpl	snesjoypadloop
    136  270af			ad 31 21	       lda	sSWCHA
    137  270b2			1d ce f3	       ora	SWCHA_DIRMASK,x	; turn off the bits for this port
    138  270b5			8d 31 21	       sta	sSWCHA
    139  270b8			a5 dd		       lda	inttemp6
    140  270ba			1d cf f3	       ora	SWCHA_DIRMASK+1,x	; don't change the other port
    141  270bd			2d 31 21	       and	sSWCHA
    142  270c0			8d 31 21	       sta	sSWCHA
    143  270c3
    144  270c3							; snes2atari0hi = B  Y  Se St *  *  *	*
    145  270c3							; snes2atari0lo = A  X  Ls Rs
    146  270c3							; sINPT1	 = B  A  Y  X  Ls Rs Se St
    147  270c3			bd ba 01	       lda	snes2atari0lo,x
    148  270c6			85 dc		       sta	inttemp5
    149  270c8			bd bc 01	       lda	snes2atari0hi,x
    150  270cb			85 dd		       sta	inttemp6
    151  270cd			06 dc		       asl	inttemp5	; A
    152  270cf			2a		       rol
    153  270d0			06 dd		       asl	inttemp6	; B
    154  270d2			2a		       rol
    155  270d3			06 dd		       asl	inttemp6	; Y
    156  270d5			2a		       rol
    157  270d6			06 dc		       asl	inttemp5	; X
    158  270d8			2a		       rol
    159  270d9			06 dc		       asl	inttemp5	; Ls
    160  270db			2a		       rol
    161  270dc			06 dc		       asl	inttemp5	; Rs
    162  270de			2a		       rol
    163  270df			06 dd		       asl	inttemp6	; Ls
    164  270e1			2a		       rol
    165  270e2			06 dd		       asl	inttemp6	; Rs
    166  270e4			2a		       rol
    167  270e5			49 c0		       eor	#%11000000	; invert to match proline
    168  270e7			9d 02 21	       sta	sINPT1,x
    169  270ea					       endif		; MULTIBUTTON
    170  270ea			60		       rts
    171  270eb				    SNES2ATARI_SIGNAL
    172  270eb							; signal to SNES2ATARI++ that we want SNES mode...
    173  270eb			ad 81 02	       lda	CTLSWA
    174  270ee			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    175  270f1			1d 04 f0	       ora	SNES_CTLSWA_SIGNAL,x
    176  270f4			8d 81 02	       sta	CTLSWA
    177  270f7			ad 80 02	       lda	SWCHA
    178  270fa			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    179  270fd			8d 80 02	       sta	SWCHA
    180  27100			a0 10		       ldy	#16
    181  27102				    SNES_SIGNAL_LOOP
    182  27102			88		       dey
    183  27103			d0 fd		       bne	SNES_SIGNAL_LOOP
    184  27105			ad 80 02	       lda	SWCHA
    185  27108			1d ce f3	       ora	SWCHA_DIRMASK,x
    186  2710b			8d 80 02	       sta	SWCHA
    187  2710e			60		       rts
    188  2710f				    s2a_joyshiftcount
    189  2710f			07 03		       .byte.b	7,3
    190  27111				    snes2atarimoduleend
   (snes2atari module is using  273  bytes of rom)
    191  27111					       echo	"  (snes2atari module is using ",[(snes2atarimoduleend-snes2atarimodulestart)]d," bytes of rom)"
    192  27111					       endif		; SNES2ATARISUPPORT
    193  27111
    194  27111
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1868  27111					       endif
   1869  27111					       ifnconst	included.mega7800.asm
------- FILE mega7800.asm LEVEL 2 PASS 3
      0  27111					       include	mega7800.asm
      1  27111							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27111
      3  27111				    mega7800handlerstart
      4  27111				    mega7800handler
      5  27111					       ifconst	MEGA7800SUPPORT
      6  27111
      7  27111							; ** stuff the joyick directions into the shadow register
      8  27111			ad 31 21	       lda	sSWCHA	; clear previous dirs for this pad, from
      9  27114			1d ce f3	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
     10  27117			8d 31 21	       sta	sSWCHA
     11  2711a			ad 80 02	       lda	SWCHA	; load the actual joystick dirs, ensuring
     12  2711d			1d cf f3	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
     13  27120			2d 31 21	       and	sSWCHA
     14  27123			8d 31 21	       sta	sSWCHA
     15  27126
     16  27126							; x=0 for left port, x=1 for right
     17  27126
     18  27126			a9 00		       lda	#0
     19  27128			85 dc		       sta	inttemp5	; temporary button-state storage
     20  2712a			85 dd		       sta	inttemp6	; temporary button-state storage
     21  2712c
     22  2712c			ad 81 02	       lda	CTLSWA
     23  2712f			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     24  27132			1d c5 f1	       ora	MEGA_INIT,x
     25  27135			8d 81 02	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     26  27138
     27  27138							; the controller type bits take a few cycles to get set after we start
     28  27138							; an extended read, so we'll start the first extended read early...
     29  27138			ad 80 02	       lda	SWCHA
     30  2713b			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     31  2713e			8d 80 02	       sta	SWCHA	; all bits are low, which STARTS the extended read
     32  27141			ea		       nop
     33  27142			ea		       nop
     34  27143
     35  27143							; first read  will be pad state (mega7800 connect and controller type)
     36  27143							; second read will be 3 button support (SACB)
     37  27143							; third read  will be 6 button support (MXYZ)
     38  27143
     39  27143			a0 05		       ldy	#5	; read 6x states, with the first 2x being the controller type
     40  27145				    m7readloop
     41  27145			ad 80 02	       lda	SWCHA
     42  27148			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     43  2714b			8d 80 02	       sta	SWCHA	; all bits are low, which STARTS the read
     44  2714e
     45  2714e			ad 80 02	       lda	SWCHA
     46  27151			e0 01		       cpx	#1
     47  27153			d0 04		       bne	m7skipp1shift
     48  27155			0a		       asl
     49  27156			0a		       asl
     50  27157			0a		       asl
     51  27158			0a		       asl
     52  27159				    m7skipp1shift
     53  27159			0a		       asl		; button bit 1 into carry
     54  2715a			26 dd		       rol	inttemp6
     55  2715c			26 dc		       rol	inttemp5
     56  2715e			0a		       asl		; button bit 0 into carry
     57  2715f			26 dd		       rol	inttemp6
     58  27161			26 dc		       rol	inttemp5
     59  27163
     60  27163			ad 80 02	       lda	SWCHA
     61  27166			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     62  27169			1d c7 f1	       ora	MEGA_NEXT,x
     63  2716c			8d 80 02	       sta	SWCHA
     64  2716f
     65  2716f			88		       dey
     66  27170			10 d3		       bpl	m7readloop
     67  27172
     68  27172			ad 81 02	       lda	CTLSWA
     69  27175			3d cf f3	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     70  27178			8d 81 02	       sta	CTLSWA	; set this port back to input
     71  2717b
     72  2717b							; if mega7800 isn't detected this frame, unpress any buttons...
     73  2717b			a5 dc		       lda	inttemp5
     74  2717d			29 03		       and	#%00000011
     75  2717f			f0 0a		       beq	m7skipscuttle
     76  27181			a9 ff		       lda	#$ff
     77  27183			85 dd		       sta	inttemp6
     78  27185					       ifconst	MULTIBUTTON
     79  27185							; the controller isn't present... revert to proline
     80  27185			a9 01		       lda	#1	; proline
     81  27187			9d b8 01	       sta	port0control,x
     82  2718a			60		       rts
     83  2718b					       endif		; MULTIBUTTON
     84  2718b				    m7skipscuttle
     85  2718b					       ifconst	MULTIBUTTON
     86  2718b			a5 dc		       lda	inttemp5
     87  2718d			4a		       lsr
     88  2718e			4a		       lsr
     89  2718f			29 03		       and	#3
     90  27191			a8		       tay
     91  27192			b9 b9 f1	       lda	megabuttons,y
     92  27195			9d c3 01	       sta	multibuttoncount0,x
     93  27198					       endif		; MULTIBUTTON
     94  27198
     95  27198			a5 dc		       lda	inttemp5
     96  2719a			9d bc 01	       sta	mega7800state0,x
     97  2719d			a5 dd		       lda	inttemp6
     98  2719f			9d ba 01	       sta	mega7800data0,x
     99  271a2
    100  271a2					       ifconst	MULTIBUTTON
    101  271a2							; now update the genric multi-button bits...
    102  271a2			a0 07		       ldy	#7
    103  271a4				    m7shuffleloop
    104  271a4			a5 dd		       lda	inttemp6
    105  271a6			39 bd f1	       and	m7reorder,y
    106  271a9			18		       clc
    107  271aa			69 ff		       adc	#$FF	; bit value in carry
    108  271ac			26 dc		       rol	inttemp5
    109  271ae			88		       dey
    110  271af			10 f3		       bpl	m7shuffleloop
    111  271b1			a5 dc		       lda	inttemp5
    112  271b3			49 c0		       eor	#%11000000
    113  271b5			9d 02 21	       sta	sINPT1,x
    114  271b8			60		       rts
    115  271b9
    116  271b9				    megabuttons
    117  271b9			06 02 03 02	       .byte.b	6,2,3,2
    118  271bd				    m7reorder
    119  271bd							;	  S	     M	       Z	 Y
    120  271bd			20 02 04 08	       .byte.b	%00100000,%00000010,%00000100,%00001000
    121  271c1							;	  X	     C	       A	 B
    122  271c1			01 80 10 40	       .byte.b	%00000001,%10000000,%00010000,%01000000
    123  271c5				   -	       else		;  !MULTIBUTTON
    124  271c5				   -	       rts
    125  271c5					       endif		; !MULTIBUTTON
    126  271c5
    127  271c5				    MEGA_INIT
    128  271c5			30 03		       .byte.b	%00110000,%00000011
    129  271c7				    MEGA_NEXT
    130  271c7			20 02		       .byte.b	%00100000,%00000010
    131  271c9
    132  271c9				    mega7800handlerend
   (mega7800 module is using  184  bytes of rom)
    133  271c9					       echo	"  (mega7800 module is using ",[(mega7800handlerend-mega7800handlerstart)]d," bytes of rom)"
    134  271c9
    135  271c9					       endif		; MEGA7800SUPPORT
    136  271c9
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1871  271c9					       endif
   1872  271c9					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  271c9					       include	tracker.asm
      1  271c9							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  271c9
      3  271c9
      4  271c9				   -	       ifconst	MUSICTRACKER
      5  271c9				   -
      6  271c9				   -trackerstart
      7  271c9				   -
      8  271c9				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  271c9				   -			; ** the player operates on a 16th note grid.
     10  271c9				   -
     11  271c9				   -servicesongover
     12  271c9				   -	       rts
     13  271c9				   -servicesong
     14  271c9				   -	       ifconst	PAUSESILENT
     15  271c9				   -	       lda	pausestate
     16  271c9				   -	       bne	servicesongover
     17  271c9				   -	       endif
     18  271c9				   -	       lda	songtempo
     19  271c9				   -	       beq	servicesongover	; ** if song is off/paused then return
     20  271c9				   -servicesongcontinue
     21  271c9				   -	       lda	sfxschedulelock
     22  271c9				   -	       sta	sfxschedulemissed
     23  271c9				   -	       bne	servicesongover
     24  271c9				   -	       lda	songtempo
     25  271c9				   -	       clc
     26  271c9				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     27  271c9				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     28  271c9				   -	       bcc	servicesongover
     29  271c9				   -			; ** if we're here a new 16th note has passed
     30  271c9				   -			; ** check if a new note is due on any of the 4 channels
     31  271c9				   -servicesongredo
     32  271c9				   -	       ldx	#3
     33  271c9				   -checkchannelloop
     34  271c9				   -	       dec	songchannel1busywait,x
     35  271c9				   -	       bpl	carryoncheckingchannel
     36  271c9				   -	       txa
     37  271c9				   -	       pha		; save X for the loop
     38  271c9				   -	       jsr	processsongdata
     39  271c9				   -	       pla		; restore X for the loop
     40  271c9				   -	       tax
     41  271c9				   -carryoncheckingchannel
     42  271c9				   -	       dex
     43  271c9				   -	       bpl	checkchannelloop
     44  271c9				   -	       lda	inactivechannelcount
     45  271c9				   -	       cmp	#15
     46  271c9				   -	       bne	skipstopsong
     47  271c9				   -	       lda	songloops
     48  271c9				   -	       bne	doasongloop
     49  271c9				   -			;lda #0
     50  271c9				   -	       sta	songtempo	; all channels are done. stop the song
     51  271c9				   -	       rts
     52  271c9				   -doasongloop
     53  271c9				   -	       bmi	skipsongloopadjust
     54  271c9				   -	       dec	songloops
     55  271c9				   -skipsongloopadjust
     56  271c9				   -	       jsr	setsongchannels
     57  271c9				   -	       jmp	servicesongredo
     58  271c9				   -skipstopsong
     59  271c9				   -	       rts
     60  271c9				   -
     61  271c9				   -processsongdata
     62  271c9				   -			; channel needs processing
     63  271c9				   -			; X=channel #
     64  271c9				   -
     65  271c9				   -	       txa
     66  271c9				   -	       clc
     67  271c9				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     68  271c9				   -	       tay
     69  271c9				   -
     70  271c9				   -
     71  271c9				   -			; ** indirect x is cumbersome with mult-byte commands.
     72  271c9				   -			; ** setup a pointer to the song data for indirect y addressing.
     73  271c9				   -	       lda	songchannel1layer1lo,y
     74  271c9				   -	       sta	songdatalo
     75  271c9				   -	       lda	songchannel1layer1hi,y
     76  271c9				   -	       sta	songdatahi
     77  271c9				   -			;ora songdatalo
     78  271c9				   -	       bne	channelhasdata
     79  271c9				   -			;channel data is pointing at $0000
     80  271c9				   -	       lda	#$7F
     81  271c9				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     82  271c9				   -setchannelcountbits
     83  271c9				   -	       lda	channel2bits,x
     84  271c9				   -	       ora	inactivechannelcount
     85  271c9				   -	       sta	inactivechannelcount
     86  271c9				   -	       rts
     87  271c9				   -channelhasdata
     88  271c9				   -
     89  271c9				   -	       sty	songstackindex
     90  271c9				   -	       ldy	#0
     91  271c9				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     92  271c9				   -	       cmp	#$ff
     93  271c9				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     94  271c9				   -	       jmp	handlechannelEOD
     95  271c9				   -
     96  271c9				   -carryoncheckingdatatype
     97  271c9				   -	       and	#$F0
     98  271c9				   -	       cmp	#$C0
     99  271c9				   -	       beq	handlechannelrest	; 0000XXXX=rest
    100  271c9				   -	       cmp	#$F0
    101  271c9				   -	       beq	handlemultibytecommand
    102  271c9				   -	       cmp	#$D0
    103  271c9				   -	       beq	handlesemiup
    104  271c9				   -	       cmp	#$E0
    105  271c9				   -	       beq	handlesemidown
    106  271c9				   -handlenotedata
    107  271c9				   -			; ** TODO: note playing is a terrible choice for fall-through
    108  271c9				   -
    109  271c9				   -			; ** its simple note data, prepare arguments for schedulesfx
    110  271c9				   -
    111  271c9				   -			; ** set the note length
    112  271c9				   -	       lda	(songdatalo),y
    113  271c9				   -	       and	#$0F
    114  271c9				   -	       sta	songchannel1busywait,x
    115  271c9				   -
    116  271c9				   -			; ** load the instrument
    117  271c9				   -	       lda	songchannel1instrumentlo,x
    118  271c9				   -	       sta	sfxinstrumentlo
    119  271c9				   -	       lda	songchannel1instrumenthi,x
    120  271c9				   -	       sta	sfxinstrumenthi
    121  271c9				   -
    122  271c9				   -			; ** get the note, and transpose
    123  271c9				   -	       lda	(songdatalo),y
    124  271c9				   -	       lsr
    125  271c9				   -	       lsr
    126  271c9				   -	       lsr
    127  271c9				   -	       lsr
    128  271c9				   -	       clc
    129  271c9				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    130  271c9				   -			; ** its up the respective SFX scheduler to handle and save the note data
    131  271c9				   -	       sta	sfxnoteindex
    132  271c9				   -
    133  271c9				   -	       lda	#0
    134  271c9				   -	       sta	sfxpitchoffset
    135  271c9				   -
    136  271c9				   -	       jsr	schedulesfx
    137  271c9				   -skipnoteschedule
    138  271c9				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  271c9				   -
    140  271c9				   -handlechannelrest
    141  271c9				   -			; ** set the note length
    142  271c9				   -	       lda	(songdatalo),y
    143  271c9				   -	       and	#$0F
    144  271c9				   -	       sta	songchannel1busywait,x
    145  271c9				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    146  271c9				   -
    147  271c9				   -handlesemiup
    148  271c9				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    149  271c9				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    150  271c9				   -	       clc
    151  271c9				   -handlesemidownentry
    152  271c9				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    153  271c9				   -	       sta	songchannel1transpose,x
    154  271c9				   -	       jsr	advancethesongpointer1byte
    155  271c9				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    156  271c9				   -
    157  271c9				   -handlesemidown
    158  271c9				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  271c9				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  271c9				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    161  271c9				   -	       sec
    162  271c9				   -	       jmp	handlesemidownentry
    163  271c9				   -
    164  271c9				   -handlemultibytecommand
    165  271c9				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    166  271c9				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    167  271c9				   -	       cmp	#$08	; ** load new instrument?
    168  271c9				   -	       bne	nothandleinstrumentchange
    169  271c9				   -handleinstrumentchange
    170  271c9				   -	       iny
    171  271c9				   -	       lda	(songdatalo),y
    172  271c9				   -	       sta	songchannel1instrumentlo,x
    173  271c9				   -	       iny
    174  271c9				   -	       lda	(songdatalo),y
    175  271c9				   -	       sta	songchannel1instrumenthi,x
    176  271c9				   -	       lda	#3
    177  271c9				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    178  271c9				   -	       jmp	processsongdata
    179  271c9				   -
    180  271c9				   -nothandleinstrumentchange
    181  271c9				   -	       cmp	#$09	; ** absolute tempo change?
    182  271c9				   -	       bne	nothandletempochange
    183  271c9				   -	       lda	#0
    184  271c9				   -	       sta	songtempo
    185  271c9				   -handlerelativetempochange
    186  271c9				   -	       iny
    187  271c9				   -	       lda	(songdatalo),y
    188  271c9				   -	       clc
    189  271c9				   -	       adc	songtempo
    190  271c9				   -	       sta	songtempo
    191  271c9				   -	       lda	#2
    192  271c9				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    193  271c9				   -	       jmp	processsongdata
    194  271c9				   -
    195  271c9				   -nothandletempochange
    196  271c9				   -	       cmp	#$0A	; ** relative tempo change?:
    197  271c9				   -	       beq	handlerelativetempochange
    198  271c9				   -	       cmp	#$0B	; ** octave/semi change?
    199  271c9				   -	       beq	handleoctavesemichange
    200  271c9				   -handlepatterndata
    201  271c9				   -			; ** if we're here its a pattern/loop "subroutine"
    202  271c9				   -			; ** move the channel's "stack" pointer and populate the new stack level
    203  271c9				   -
    204  271c9				   -	       lda	#4
    205  271c9				   -	       clc
    206  271c9				   -	       adc	songchannel1stackdepth,x
    207  271c9				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    208  271c9				   -
    209  271c9				   -	       stx	inttemp6	; about to invalidate x. save it.
    210  271c9				   -	       lda	songstackindex
    211  271c9				   -	       adc	#4
    212  271c9				   -	       tax
    213  271c9				   -
    214  271c9				   -	       lda	(songdatalo),y
    215  271c9				   -	       and	#$7
    216  271c9				   -	       sta	songchannel1layer1loops,x
    217  271c9				   -	       iny
    218  271c9				   -	       lda	(songdatalo),y
    219  271c9				   -	       sta	songchannel1layer1lo,x
    220  271c9				   -	       iny
    221  271c9				   -	       lda	(songdatalo),y
    222  271c9				   -	       sta	songchannel1layer1hi,x
    223  271c9				   -
    224  271c9				   -	       ldx	inttemp6	; restore x with the channel #
    225  271c9				   -
    226  271c9				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    227  271c9				   -	       lda	#3
    228  271c9				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    229  271c9				   -
    230  271c9				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    231  271c9				   -	       jmp	processsongdata
    232  271c9				   -
    233  271c9				   -handlechannelEOD
    234  271c9				   -			; ** check if there are loops remaining on the pattern
    235  271c9				   -	       stx	inttemp6
    236  271c9				   -	       ldx	songstackindex
    237  271c9				   -	       dec	songchannel1layer1loops,x
    238  271c9				   -	       bmi	handlechannelEODnoloop
    239  271c9				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    240  271c9				   -	       iny
    241  271c9				   -	       lda	(songdatalo),y
    242  271c9				   -	       sta	songchannel1layer1lo,x
    243  271c9				   -	       iny
    244  271c9				   -	       lda	(songdatalo),y
    245  271c9				   -	       sta	songchannel1layer1hi,x
    246  271c9				   -	       ldx	inttemp6
    247  271c9				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    248  271c9				   -
    249  271c9				   -handlechannelEODnoloop
    250  271c9				   -			; this pattern/loop is done playing. "pop" the stack
    251  271c9				   -	       ldx	inttemp6
    252  271c9				   -	       lda	songchannel1stackdepth,x
    253  271c9				   -	       beq	handlerootchannelEOD
    254  271c9				   -	       sec
    255  271c9				   -	       sbc	#4
    256  271c9				   -	       sta	songchannel1stackdepth,x
    257  271c9				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    258  271c9				   -
    259  271c9				   -handlerootchannelEOD
    260  271c9				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    261  271c9				   -	       lda	#0
    262  271c9				   -	       sta	songchannel1layer1lo,x
    263  271c9				   -	       sta	songchannel1layer1hi,x
    264  271c9				   -	       sta	songchannel1busywait,x
    265  271c9				   -	       jmp	setchannelcountbits
    266  271c9				   -	       rts
    267  271c9				   -
    268  271c9				   -nothandlepatternchange
    269  271c9				   -handleoctavesemichange
    270  271c9				   -	       iny
    271  271c9				   -	       lda	(songdatalo),y
    272  271c9				   -	       sta	songchannel1transpose,x
    273  271c9				   -	       lda	#2
    274  271c9				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    275  271c9				   -	       jmp	processsongdata
    276  271c9				   -
    277  271c9				   -advancethesongpointer1byte
    278  271c9				   -	       txa
    279  271c9				   -	       ldx	songstackindex
    280  271c9				   -	       inc	songchannel1layer1lo,x
    281  271c9				   -	       bne	skiphiadvancethesongpointer1byte
    282  271c9				   -	       inc	songchannel1layer1hi,x
    283  271c9				   -skiphiadvancethesongpointer1byte
    284  271c9				   -	       tax
    285  271c9				   -	       rts
    286  271c9				   -
    287  271c9				   -advancethesongpointerNbytes
    288  271c9				   -			; entered with A=# of byte to advance
    289  271c9				   -	       stx	inttemp6
    290  271c9				   -	       ldx	songstackindex
    291  271c9				   -	       clc
    292  271c9				   -	       adc	songchannel1layer1lo,x
    293  271c9				   -	       sta	songchannel1layer1lo,x
    294  271c9				   -	       lda	#0
    295  271c9				   -	       adc	songchannel1layer1hi,x
    296  271c9				   -	       sta	songchannel1layer1hi,x
    297  271c9				   -	       ldx	inttemp6
    298  271c9				   -	       rts
    299  271c9				   -
    300  271c9				   -clearsongmemory
    301  271c9				   -	       lda	#0
    302  271c9				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    303  271c9				   -clearsongmemoryloop1
    304  271c9				   -	       sta	songchannel1layer1lo,x
    305  271c9				   -	       dex
    306  271c9				   -	       bpl	clearsongmemoryloop1
    307  271c9				   -
    308  271c9				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    309  271c9				   -clearsongmemoryloop2
    310  271c9				   -	       sta	songchannel1layer1loops,x
    311  271c9				   -	       dex
    312  271c9				   -	       bpl	clearsongmemoryloop2
    313  271c9				   -
    314  271c9				   -	       lda	#$ff
    315  271c9				   -	       ldx	#3
    316  271c9				   -clearsongmemoryloop3
    317  271c9				   -	       sta	songchannel1busywait,x
    318  271c9				   -	       dex
    319  271c9				   -	       bpl	clearsongmemoryloop3
    320  271c9				   -	       rts
    321  271c9				   -
    322  271c9				   -setsongchannels
    323  271c9				   -	       jsr	clearsongmemory
    324  271c9				   -	       ldy	#7
    325  271c9				   -	       ldx	#3
    326  271c9				   -setsongchannelsloop
    327  271c9				   -	       lda	(songpointerlo),y
    328  271c9				   -	       sta	songchannel1layer1hi,x
    329  271c9				   -	       dey
    330  271c9				   -	       lda	(songpointerlo),y
    331  271c9				   -	       sta	songchannel1layer1lo,x
    332  271c9				   -	       dex
    333  271c9				   -	       dey
    334  271c9				   -	       bpl	setsongchannelsloop
    335  271c9				   -	       rts
    336  271c9				   -
    337  271c9				   -channel2bits
    338  271c9				   -	       .byte	1,2,4,8
    339  271c9				   -
    340  271c9				   -tiatrackeroctavenotes
    341  271c9				   -	       ifconst	BUZZBASS
    342  271c9				   -LOWC       =	15
    343  271c9				   -	       else
    344  271c9				   -LOWC       =	14
    345  271c9				   -	       endif
    346  271c9				   -			; ****** ELECTRONIC (0 to 11)
    347  271c9				   -	       .byte	LOWC,20	; c0	 16.1Hz
    348  271c9				   -	       .byte	LOWC,18	; c#0
    349  271c9				   -	       .byte	LOWC,17	; d0
    350  271c9				   -	       .byte	LOWC,16	; d#0
    351  271c9				   -	       .byte	LOWC,15	; e0
    352  271c9				   -	       .byte	LOWC,14	; f0  (very off)
    353  271c9				   -	       .byte	LOWC,14	; f#0
    354  271c9				   -	       .byte	LOWC,13	; g0
    355  271c9				   -	       .byte	LOWC,12	; g#0
    356  271c9				   -	       .byte	LOWC,11	; a0
    357  271c9				   -	       .byte	LOWC,11	; a#0 (very off)
    358  271c9				   -	       .byte	LOWC,10	; b0	 30.7Hz
    359  271c9				   -
    360  271c9				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    361  271c9				   -	       .byte	6,30	; c1	 32.7Hz
    362  271c9				   -	       .byte	6,28	; c#1
    363  271c9				   -	       .byte	6,27	; d1
    364  271c9				   -	       .byte	6,25	; d#1
    365  271c9				   -	       .byte	6,24	; e1
    366  271c9				   -	       .byte	6,22	; f1
    367  271c9				   -	       .byte	6,21	; f#1
    368  271c9				   -	       .byte	6,20	; g1
    369  271c9				   -	       .byte	6,18	; g#1
    370  271c9				   -	       .byte	6,17	; a1
    371  271c9				   -	       .byte	6,16	; a#1
    372  271c9				   -	       .byte	6,15	; b1	 63.4Hz
    373  271c9				   -
    374  271c9				   -			; ****** BUZZY (24 to 39)
    375  271c9				   -	       .byte	1,31	; c2	 65.5
    376  271c9				   -	       .byte	1,30	; c#2	 67.6
    377  271c9				   -	       .byte	1,27	; d2	 72.3
    378  271c9				   -	       .byte	1,26	; d#2	 77.6
    379  271c9				   -	       .byte	1,24	; e2
    380  271c9				   -	       .byte	1,23	; f2
    381  271c9				   -	       .byte	1,22	; f#2
    382  271c9				   -	       .byte	1,20	; g2
    383  271c9				   -	       .byte	1,19	; g#2
    384  271c9				   -	       .byte	1,18	; a2
    385  271c9				   -	       .byte	1,17	; a#2
    386  271c9				   -	       .byte	1,16	; b2
    387  271c9				   -	       .byte	1,15	; c3	126.8Hz
    388  271c9				   -	       .byte	1,14	; c#3
    389  271c9				   -	       .byte	1,13	; d3	149.7Hz
    390  271c9				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    391  271c9				   -			; ****** PURE (40 to 71) - best key is A3 Major
    392  271c9				   -	       .byte	12,31	; e3	163.8Hz
    393  271c9				   -	       .byte	12,29	; f3
    394  271c9				   -	       .byte	12,28	; f#3
    395  271c9				   -	       .byte	12,26	; g3
    396  271c9				   -	       .byte	12,24	; g#3
    397  271c9				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    398  271c9				   -	       .byte	12,22	; a#3
    399  271c9				   -	       .byte	12,20	; b3
    400  271c9				   -	       .byte	12,19	; c4  (middle C)
    401  271c9				   -	       .byte	12,18	; c#4
    402  271c9				   -	       .byte	12,17	; d4
    403  271c9				   -	       .byte	12,16	; d#4
    404  271c9				   -	       .byte	12,15	; e4
    405  271c9				   -	       .byte	12,14	; f4
    406  271c9				   -	       .byte	12,13	; f#4
    407  271c9				   -	       .byte	12,12	; g4  (very off)
    408  271c9				   -	       .byte	12,12	; g#4
    409  271c9				   -	       .byte	12,11	; a4
    410  271c9				   -	       .byte	12,10	; a#4
    411  271c9				   -	       .byte	4,31	; b4
    412  271c9				   -	       .byte	4,29	; c5
    413  271c9				   -	       .byte	4,28	; c#5
    414  271c9				   -	       .byte	4,26	; d5
    415  271c9				   -	       .byte	4,24	; d#5
    416  271c9				   -	       .byte	4,23	; e5
    417  271c9				   -	       .byte	4,22	; f5
    418  271c9				   -	       .byte	4,20	; f#5
    419  271c9				   -	       .byte	4,19	; g5
    420  271c9				   -	       .byte	4,18	; g#5
    421  271c9				   -	       .byte	4,17	; a5
    422  271c9				   -	       .byte	4,16	; a#5
    423  271c9				   -	       .byte	4,15	; b5
    424  271c9				   -
    425  271c9				   -			; ****** TUNED WIND (72 to 83)
    426  271c9				   -	       .byte	8,30	; c
    427  271c9				   -	       .byte	8,28	; c#
    428  271c9				   -	       .byte	8,27	; d
    429  271c9				   -	       .byte	8,25	; d#
    430  271c9				   -	       .byte	8,24	; e
    431  271c9				   -	       .byte	8,22	; f
    432  271c9				   -	       .byte	8,21	; f#
    433  271c9				   -	       .byte	8,20	; g
    434  271c9				   -	       .byte	8,18	; g#
    435  271c9				   -	       .byte	8,17	; a
    436  271c9				   -	       .byte	8,16	; a#
    437  271c9				   -	       .byte	8,15	; b
    438  271c9				   -
    439  271c9				   -	       include	"tiadrumkit.asm"
    440  271c9				   -
    441  271c9				   -trackerend
    442  271c9				   -
    443  271c9				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    444  271c9				   -
    445  271c9					       endif		;MUSICTRACKER
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1874  271c9					       endif
   1875  271c9					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  271c9					       include	hiscore.asm
      1  271c9							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  271c9
      3  271c9				   -	       ifconst	HSSUPPORT
      4  271c9				   -
      5  271c9				   -	       ifconst	BANKSETROM
      6  271c9				   -	       ifconst	isBANKSETBANK
      7  271c9				   -HSCHARSHERE =	1
      8  271c9				   -	       endif
      9  271c9				   -	       else		; !BANKSETROM so embed the character strings
     10  271c9				   -HSCHARSHERE =	1
     11  271c9				   -	       endif
     12  271c9				   -
     13  271c9				   -	       ifnconst	isBANKSETBANK
     14  271c9				   -hiscorestart
     15  271c9				   -
     16  271c9				   -detectatarivoxeeprom
     17  271c9				   -hiscoremodulestart
     18  271c9				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  271c9				   -	       jsr	AVoxDetect
     20  271c9				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  271c9				   -	       sta	avoxdetected
     22  271c9				   -	       lda	#$0
     23  271c9				   -	       sta	SWACNT
     24  271c9				   -	       lda	avoxdetected
     25  271c9				   -	       rts
     26  271c9				   -
     27  271c9				   -detecthsc
     28  271c9				   -			; check for the HSC ROM signature...
     29  271c9				   -	       lda	XCTRL1s
     30  271c9				   -	       ora	#%00001100
     31  271c9				   -	       sta	XCTRL1s
     32  271c9				   -	       sta	XCTRL1
     33  271c9				   -
     34  271c9				   -	       lda	$3900
     35  271c9				   -	       eor	#$C6
     36  271c9				   -	       bne	detecthscfail
     37  271c9				   -	       lda	$3904
     38  271c9				   -	       eor	#$FE
     39  271c9				   -	       bne	detecthscfail
     40  271c9				   -
     41  271c9				   -			; check if it's initialized...
     42  271c9				   -	       ldy	#0
     43  271c9				   -	       lda	#$ff
     44  271c9				   -checkhscinit
     45  271c9				   -	       and	$1000,y
     46  271c9				   -	       dey
     47  271c9				   -	       bpl	checkhscinit
     48  271c9				   -	       cmp	#$ff
     49  271c9				   -	       bne	hscisalreadyinit
     50  271c9				   -checkhscinit2
     51  271c9				   -	       ora	$1000,y
     52  271c9				   -	       dey
     53  271c9				   -	       bpl	checkhscinit2
     54  271c9				   -	       cmp	#0
     55  271c9				   -	       bne	hscisalreadyinit
     56  271c9				   -			; if we're here, we need to do a minimal HSC init...
     57  271c9				   -	       ldy	#$28
     58  271c9				   -hscinitloop1
     59  271c9				   -	       lda	hscheader,y
     60  271c9				   -	       sta	$1000,y
     61  271c9				   -	       dey
     62  271c9				   -	       bpl	hscinitloop1
     63  271c9				   -	       ldy	#$89
     64  271c9				   -	       lda	#$7F
     65  271c9				   -hscinitloop2
     66  271c9				   -	       sta	$10B3,y
     67  271c9				   -	       dey
     68  271c9				   -	       cpy	#$ff
     69  271c9				   -	       bne	hscinitloop2
     70  271c9				   -hscisalreadyinit
     71  271c9				   -	       lda	#$ff
     72  271c9				   -	       rts
     73  271c9				   -hscheader
     74  271c9				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     75  271c9				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     76  271c9				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     77  271c9				   -detecthscfail
     78  271c9				   -	       lda	XCTRL1s
     79  271c9				   -	       and	#%11110111
     80  271c9				   -	       sta	XCTRL1s
     81  271c9				   -	       lda	#0
     82  271c9				   -	       rts
     83  271c9				   -	       endif		; isBANKSETBANK
     84  271c9				   -
     85  271c9				   -	       ifnconst	hiscorefont
     86  271c9				   -	       echo	""
     87  271c9				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     88  271c9				   -	       echo	" NOT imported with incgraphic. The high score display code"
     89  271c9				   -	       echo	" has been omitted from this build."
     90  271c9				   -	       echo	""
     91  271c9				   -	       else		; hiscorefont
     92  271c9				   -	       ifnconst	isBANKSETBANK
     93  271c9				   -hscdrawscreen
     94  271c9				   -
     95  271c9				   -			; we use 20 lines on a 24 line display
     96  271c9				   -			; HSSCOREY to dynamically centers based on
     97  271c9				   -			;HSSCOREY = 0
     98  271c9				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     99  271c9				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
    100  271c9				   -
    101  271c9				   -	       ifconst	HSSCORESIZE
    102  271c9				   -SCORESIZE  =	HSSCORESIZE
    103  271c9				   -	       else
    104  271c9				   -SCORESIZE  =	6
    105  271c9				   -	       endif
    106  271c9				   -
    107  271c9				   -			;save shadow registers for later return...
    108  271c9				   -	       lda	sCTRL
    109  271c9				   -	       pha
    110  271c9				   -	       lda	sCHARBASE
    111  271c9				   -	       pha
    112  271c9				   -
    113  271c9				   -	       jsr	blacken320colors
    114  271c9				   -	       jsr	drawoverwait
    115  271c9				   -	       jsr	drawwait
    116  271c9				   -	       jsr	hiscorecleardlmem
    117  271c9				   -	       jsr	clearscreen
    118  271c9				   -
    119  271c9				   -	       lda	#$60
    120  271c9				   -	       sta	charactermode
    121  271c9				   -
    122  271c9				   -			;set the character base to the HSC font
    123  271c9				   -	       lda	#>hiscorefont
    124  271c9				   -	       sta	CHARBASE
    125  271c9				   -	       sta	sCHARBASE
    126  271c9				   -	       lda	#%01000011	;Enable DMA, mode=320A
    127  271c9				   -	       sta	CTRL
    128  271c9				   -	       sta	sCTRL
    129  271c9				   -
    130  271c9				   -	       lda	#60
    131  271c9				   -	       sta	hsjoydebounce
    132  271c9				   -
    133  271c9				   -	       lda	#0
    134  271c9				   -	       sta	hscursorx
    135  271c9				   -	       sta	framecounter
    136  271c9				   -
    137  271c9				   -	       ifnconst	HSCOLORCHASESTART
    138  271c9				   -	       lda	#$8D	; default is blue. why not?
    139  271c9				   -	       else
    140  271c9				   -	       lda	#HSCOLORCHASESTART
    141  271c9				   -	       endif
    142  271c9				   -	       sta	hscolorchaseindex
    143  271c9				   -	       lda	#$0F
    144  271c9				   -	       sta	P0C2	; base text is white
    145  271c9				   -	       jsr	hschasecolors
    146  271c9				   -
    147  271c9				   -			; ** plot all of the initials
    148  271c9				   -	       lda	#<HSRAMInitials
    149  271c9				   -	       sta	temp1	; charmaplo
    150  271c9				   -	       lda	#>HSRAMInitials
    151  271c9				   -	       sta	temp2	; charmaphi
    152  271c9				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    153  271c9				   -	       sta	temp3	; palette/width
    154  271c9				   -	       lda	#104
    155  271c9				   -	       sta	temp4	; X
    156  271c9				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    157  271c9				   -	       sta	temp5	; Y
    158  271c9				   -plothsinitialsloop
    159  271c9				   -	       jsr	plotcharacters
    160  271c9				   -	       clc
    161  271c9				   -	       lda	temp3
    162  271c9				   -	       adc	#32
    163  271c9				   -	       sta	temp3
    164  271c9				   -	       inc	temp5
    165  271c9				   -	       if	WZONEHEIGHT = 8
    166  271c9				   -	       inc	temp5
    167  271c9				   -	       endif
    168  271c9				   -	       clc
    169  271c9				   -	       lda	#3
    170  271c9				   -	       adc	temp1
    171  271c9				   -	       sta	temp1
    172  271c9				   -	       cmp	#(<(HSRAMInitials+15))
    173  271c9				   -	       bcc	plothsinitialsloop
    174  271c9				   -
    175  271c9				   -	       ifconst	HSGAMENAMELEN
    176  271c9				   -			;plot the game name...
    177  271c9				   -	       lda	#<HSGAMENAMEtable
    178  271c9				   -	       sta	temp1	; charmaplo
    179  271c9				   -	       lda	#>HSGAMENAMEtable
    180  271c9				   -	       sta	temp2	; charmaphi
    181  271c9				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    182  271c9				   -	       sta	temp3	; palette/width
    183  271c9				   -	       lda	#(80-(HSGAMENAMELEN*2))
    184  271c9				   -	       sta	temp4	; X
    185  271c9				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    186  271c9				   -	       sta	temp5	; Y
    187  271c9				   -	       jsr	plotcharacters
    188  271c9				   -	       endif		; HSGAMENAMELEN
    189  271c9				   -
    190  271c9				   -			;plot "difficulty"...
    191  271c9				   -	       ldy	gamedifficulty
    192  271c9				   -	       ifnconst	HSNOLEVELNAMES
    193  271c9				   -	       lda	highscoredifficultytextlo,y
    194  271c9				   -	       sta	temp1
    195  271c9				   -	       lda	highscoredifficultytexthi,y
    196  271c9				   -	       sta	temp2
    197  271c9				   -	       sec
    198  271c9				   -	       lda	#32
    199  271c9				   -	       sbc	highscoredifficultytextlen,y
    200  271c9				   -	       sta	temp3	; palette/width
    201  271c9				   -	       sec
    202  271c9				   -	       lda	#40
    203  271c9				   -	       sbc	highscoredifficultytextlen,y
    204  271c9				   -	       asl
    205  271c9				   -	       sta	temp4	; X
    206  271c9				   -	       else
    207  271c9				   -	       lda	#<HSHIGHSCOREStext
    208  271c9				   -	       sta	temp1	; charmaplo
    209  271c9				   -	       lda	#>HSHIGHSCOREStext
    210  271c9				   -	       sta	temp2	; charmaphi
    211  271c9				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    212  271c9				   -	       sta	temp3	; palette/width
    213  271c9				   -	       lda	#(80-(11*2))
    214  271c9				   -	       sta	temp4	; X
    215  271c9				   -	       endif		; HSNOLEVELNAMES
    216  271c9				   -
    217  271c9				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    218  271c9				   -	       sta	temp5	; Y
    219  271c9				   -	       jsr	plotcharacters
    220  271c9				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    221  271c9				   -	       bne	carronwithscoreevaluation
    222  271c9				   -	       jmp	donoscoreevaluation
    223  271c9				   -carronwithscoreevaluation
    224  271c9				   -	       dey
    225  271c9				   -	       lda	highscorelabeltextlo,y
    226  271c9				   -	       sta	temp1
    227  271c9				   -	       lda	highscorelabeltexthi,y
    228  271c9				   -	       sta	temp2
    229  271c9				   -	       sec
    230  271c9				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    231  271c9				   -	       sta	temp3	; palette/width
    232  271c9				   -	       lda	highscorelabeladjust1,y
    233  271c9				   -	       sta	temp4	; X
    234  271c9				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    235  271c9				   -	       sta	temp5	; Y
    236  271c9				   -	       jsr	plotcharacters
    237  271c9				   -
    238  271c9				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    239  271c9				   -	       dey
    240  271c9				   -			;plot the current player score...
    241  271c9				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    242  271c9				   -	       sta	temp3	; palette/width
    243  271c9				   -	       lda	highscorelabeladjust2,y
    244  271c9				   -	       sta	temp4	; X
    245  271c9				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    246  271c9				   -	       sta	temp5	; Y
    247  271c9				   -
    248  271c9				   -	       lda	scorevarlo,y
    249  271c9				   -	       sta	temp7	; score variable lo
    250  271c9				   -	       lda	scorevarhi,y
    251  271c9				   -	       sta	temp8	; score variable hi
    252  271c9				   -
    253  271c9				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    254  271c9				   -	       sta	temp9
    255  271c9				   -
    256  271c9				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    257  271c9				   -	       sta	temp1	; charmaplo
    258  271c9				   -	       lda	#>(hiscorefont+33)
    259  271c9				   -	       sta	temp2	; charmaphi
    260  271c9				   -	       lda	#SCORESIZE
    261  271c9				   -	       sta	temp6
    262  271c9				   -	       ifnconst	DOUBLEWIDE
    263  271c9				   -	       jsr	plotvalue
    264  271c9				   -	       else
    265  271c9				   -	       jsr	plotvaluedw
    266  271c9				   -	       endif
    267  271c9				   -
    268  271c9				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    269  271c9				   -
    270  271c9				   -	       ifconst	HSGAMERANKS
    271  271c9				   -
    272  271c9				   -	       ldx	#$ff	; start at 0 after the inx...
    273  271c9				   -comparescore2rankloop
    274  271c9				   -	       inx
    275  271c9				   -	       ldy	#0
    276  271c9				   -	       lda	rankvalue_0,x
    277  271c9				   -	       cmp	(temp7),y
    278  271c9				   -	       bcc	score2rankloopdone
    279  271c9				   -	       bne	comparescore2rankloop
    280  271c9				   -	       iny
    281  271c9				   -	       lda	rankvalue_1,x
    282  271c9				   -	       cmp	(temp7),y
    283  271c9				   -	       bcc	score2rankloopdone
    284  271c9				   -	       bne	comparescore2rankloop
    285  271c9				   -	       iny
    286  271c9				   -	       lda	(temp7),y
    287  271c9				   -	       cmp	rankvalue_2,x
    288  271c9				   -	       bcs	score2rankloopdone
    289  271c9				   -	       jmp	comparescore2rankloop
    290  271c9				   -score2rankloopdone
    291  271c9				   -	       stx	hsnewscorerank
    292  271c9				   -
    293  271c9				   -	       lda	ranklabello,x
    294  271c9				   -	       sta	temp1
    295  271c9				   -	       lda	ranklabelhi,x
    296  271c9				   -	       sta	temp2
    297  271c9				   -	       sec
    298  271c9				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    299  271c9				   -	       sbc	ranklabellengths,x
    300  271c9				   -	       sta	temp3	; palette/width
    301  271c9				   -	       sec
    302  271c9				   -	       lda	#(40+6)
    303  271c9				   -	       sbc	ranklabellengths,x
    304  271c9				   -	       asl
    305  271c9				   -	       sta	temp4	; X
    306  271c9				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    307  271c9				   -	       sta	temp5	; Y
    308  271c9				   -	       jsr	plotcharacters
    309  271c9				   -
    310  271c9				   -	       ldx	hsnewscorerank
    311  271c9				   -
    312  271c9				   -	       lda	#<highscoreranklabel
    313  271c9				   -	       sta	temp1
    314  271c9				   -	       lda	#>highscoreranklabel
    315  271c9				   -	       sta	temp2
    316  271c9				   -
    317  271c9				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    318  271c9				   -	       sta	temp3	; palette/width
    319  271c9				   -	       lda	#(40-6)
    320  271c9				   -	       sec
    321  271c9				   -	       sbc	ranklabellengths,x
    322  271c9				   -	       asl
    323  271c9				   -	       sta	temp4	; X
    324  271c9				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    325  271c9				   -	       sta	temp5	; Y
    326  271c9				   -	       jsr	plotcharacters
    327  271c9				   -	       endif		; HSGAMERANKS
    328  271c9				   -
    329  271c9				   -
    330  271c9				   -			; ** which line did this player beat?
    331  271c9				   -	       lda	#$ff
    332  271c9				   -	       sta	hsnewscoreline
    333  271c9				   -	       ldx	#$fd
    334  271c9				   -comparescoreadd2x
    335  271c9				   -	       inx
    336  271c9				   -comparescoreadd1x
    337  271c9				   -	       inx
    338  271c9				   -comparescore2lineloop
    339  271c9				   -	       inc	hsnewscoreline
    340  271c9				   -	       inx		; initialrun, x=0
    341  271c9				   -	       cpx	#15
    342  271c9				   -	       beq	nohighscoreforyou
    343  271c9				   -	       ldy	#0
    344  271c9				   -	       lda	HSRAMScores,x
    345  271c9				   -	       cmp	(temp7),y	; first score digit
    346  271c9				   -	       bcc	score2lineloopdonedel1x
    347  271c9				   -	       bne	comparescoreadd2x
    348  271c9				   -	       iny
    349  271c9				   -	       inx
    350  271c9				   -	       lda	HSRAMScores,x
    351  271c9				   -	       cmp	(temp7),y
    352  271c9				   -	       bcc	score2lineloopdonedel2x
    353  271c9				   -	       bne	comparescoreadd1x
    354  271c9				   -	       iny
    355  271c9				   -	       inx
    356  271c9				   -	       lda	(temp7),y
    357  271c9				   -	       cmp	HSRAMScores,x
    358  271c9				   -	       bcs	score2lineloopdonedel3x
    359  271c9				   -	       jmp	comparescore2lineloop
    360  271c9				   -nohighscoreforyou
    361  271c9				   -	       lda	#$ff
    362  271c9				   -	       sta	hsnewscoreline
    363  271c9				   -	       sta	countdownseconds
    364  271c9				   -	       jmp	donoscoreevaluation
    365  271c9				   -score2lineloopdonedel3x
    366  271c9				   -	       dex
    367  271c9				   -score2lineloopdonedel2x
    368  271c9				   -	       dex
    369  271c9				   -score2lineloopdonedel1x
    370  271c9				   -	       dex
    371  271c9				   -
    372  271c9				   -			; 0 1 2
    373  271c9				   -			; 3 4 5
    374  271c9				   -			; 6 7 8
    375  271c9				   -			; 9 0 1
    376  271c9				   -			; 2 3 4
    377  271c9				   -
    378  271c9				   -	       stx	temp9
    379  271c9				   -	       cpx	#11
    380  271c9				   -	       beq	postsortscoresuploop
    381  271c9				   -	       ldx	#11
    382  271c9				   -sortscoresuploop
    383  271c9				   -	       lda	HSRAMScores,x
    384  271c9				   -	       sta	HSRAMScores+3,x
    385  271c9				   -	       lda	HSRAMInitials,x
    386  271c9				   -	       sta	HSRAMInitials+3,x
    387  271c9				   -	       dex
    388  271c9				   -	       cpx	temp9
    389  271c9				   -	       bne	sortscoresuploop
    390  271c9				   -postsortscoresuploop
    391  271c9				   -
    392  271c9				   -			;stick the score and cleared initials in the slot...
    393  271c9				   -	       inx
    394  271c9				   -	       ldy	#0
    395  271c9				   -	       sty	hsinitialhold
    396  271c9				   -	       lda	(temp7),y
    397  271c9				   -	       sta	HSRAMScores,x
    398  271c9				   -	       iny
    399  271c9				   -	       lda	(temp7),y
    400  271c9				   -	       sta	HSRAMScores+1,x
    401  271c9				   -	       iny
    402  271c9				   -	       lda	(temp7),y
    403  271c9				   -	       sta	HSRAMScores+2,x
    404  271c9				   -	       lda	#0
    405  271c9				   -	       sta	HSRAMInitials,x
    406  271c9				   -	       lda	#29
    407  271c9				   -	       sta	HSRAMInitials+1,x
    408  271c9				   -	       sta	HSRAMInitials+2,x
    409  271c9				   -
    410  271c9				   -	       stx	hsinitialpos
    411  271c9				   -
    412  271c9				   -	       ifconst	vox_highscore
    413  271c9				   -	       lda	<#vox_highscore
    414  271c9				   -	       sta	speech_addr
    415  271c9				   -	       lda	>#vox_highscore
    416  271c9				   -	       sta	speech_addr+1
    417  271c9				   -	       endif		; vox_highscore
    418  271c9				   -	       ifconst	sfx_highscore
    419  271c9				   -	       lda	<#sfx_highscore
    420  271c9				   -	       sta	temp1
    421  271c9				   -	       lda	>#sfx_highscore
    422  271c9				   -	       sta	temp2
    423  271c9				   -	       lda	#0
    424  271c9				   -	       sta	temp3
    425  271c9				   -	       jsr	schedulesfx
    426  271c9				   -	       endif		; sfx_highscore
    427  271c9				   -	       ifconst	songdatastart_song_highscore
    428  271c9				   -	       lda	#<songchanneltable_song_highscore
    429  271c9				   -	       sta	songpointerlo
    430  271c9				   -	       lda	#>songchanneltable_song_highscore
    431  271c9				   -	       sta	songpointerhi
    432  271c9				   -	       lda	#73
    433  271c9				   -	       sta	songtempo
    434  271c9				   -	       jsr	setsongchannels
    435  271c9				   -	       endif		; songdatastart_song_highscore
    436  271c9				   -
    437  271c9				   -
    438  271c9				   -donoscoreevaluation
    439  271c9				   -
    440  271c9				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    441  271c9				   -	       sta	temp3	; palette/width
    442  271c9				   -	       lda	#(72+(4*(6-SCORESIZE)))
    443  271c9				   -	       sta	temp4	; X
    444  271c9				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    445  271c9				   -	       sta	temp5	; Y
    446  271c9				   -	       lda	#<HSRAMScores
    447  271c9				   -	       sta	temp7	; score variable lo
    448  271c9				   -	       lda	#>HSRAMScores
    449  271c9				   -	       sta	temp8	; score variable hi
    450  271c9				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    451  271c9				   -	       sta	temp9
    452  271c9				   -plothsscoresloop
    453  271c9				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    454  271c9				   -	       sta	temp1	; charmaplo
    455  271c9				   -	       lda	#>(hiscorefont+33)
    456  271c9				   -	       sta	temp2	; charmaphi
    457  271c9				   -	       lda	#6
    458  271c9				   -	       sta	temp6
    459  271c9				   -	       ifnconst	DOUBLEWIDE
    460  271c9				   -	       jsr	plotvalue
    461  271c9				   -	       else
    462  271c9				   -	       jsr	plotvaluedw
    463  271c9				   -	       endif
    464  271c9				   -	       clc
    465  271c9				   -	       lda	temp3
    466  271c9				   -	       adc	#32
    467  271c9				   -	       sta	temp3
    468  271c9				   -	       inc	temp5
    469  271c9				   -	       if	WZONEHEIGHT = 8
    470  271c9				   -	       inc	temp5
    471  271c9				   -	       endif
    472  271c9				   -	       clc
    473  271c9				   -	       lda	#3
    474  271c9				   -	       adc	temp7
    475  271c9				   -	       sta	temp7
    476  271c9				   -	       cmp	#(<(HSRAMScores+15))
    477  271c9				   -	       bcc	plothsscoresloop
    478  271c9				   -plothsindex
    479  271c9				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    480  271c9				   -	       sta	temp3	; palette/width
    481  271c9				   -	       lda	#44
    482  271c9				   -	       sta	temp4	; X
    483  271c9				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    484  271c9				   -	       sta	temp5	; Y
    485  271c9				   -	       lda	#<hsgameslotnumbers
    486  271c9				   -	       sta	temp7	; score variable lo
    487  271c9				   -	       lda	#>hsgameslotnumbers
    488  271c9				   -	       sta	temp8	; score variable hi
    489  271c9				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    490  271c9				   -	       sta	temp9
    491  271c9				   -plothsindexloop
    492  271c9				   -	       lda	#<(hiscorefont+33)
    493  271c9				   -	       sta	temp1	; charmaplo
    494  271c9				   -	       lda	#>(hiscorefont+33)
    495  271c9				   -	       sta	temp2	; charmaphi
    496  271c9				   -	       lda	#1
    497  271c9				   -	       sta	temp6	; number of characters
    498  271c9				   -	       ifnconst	DOUBLEWIDE
    499  271c9				   -	       jsr	plotvalue
    500  271c9				   -	       else
    501  271c9				   -	       jsr	plotvaluedw
    502  271c9				   -	       endif
    503  271c9				   -	       clc
    504  271c9				   -	       lda	temp3
    505  271c9				   -	       adc	#32
    506  271c9				   -	       sta	temp3
    507  271c9				   -	       inc	temp5
    508  271c9				   -	       if	WZONEHEIGHT = 8
    509  271c9				   -	       inc	temp5
    510  271c9				   -	       endif
    511  271c9				   -	       inc	temp7
    512  271c9				   -	       lda	temp7
    513  271c9				   -	       cmp	#(<(hsgameslotnumbers+5))
    514  271c9				   -	       bcc	plothsindexloop
    515  271c9				   -
    516  271c9				   -	       jsr	savescreen
    517  271c9				   -	       ifnconst	HSSECONDS
    518  271c9				   -	       lda	#6
    519  271c9				   -	       else
    520  271c9				   -	       lda	#HSSECONDS
    521  271c9				   -	       endif
    522  271c9				   -
    523  271c9				   -	       sta	countdownseconds
    524  271c9				   -
    525  271c9				   -keepdisplayinghs
    526  271c9				   -	       jsr	restorescreen
    527  271c9				   -
    528  271c9				   -	       jsr	setuphsinpt1
    529  271c9				   -
    530  271c9				   -	       lda	hsnewscoreline
    531  271c9				   -	       bpl	carryonkeepdisplayinghs
    532  271c9				   -	       jmp	skipenterscorecontrol
    533  271c9				   -carryonkeepdisplayinghs
    534  271c9				   -
    535  271c9				   -
    536  271c9				   -	       ifnconst	HSSECONDS
    537  271c9				   -	       lda	#6
    538  271c9				   -	       else
    539  271c9				   -	       lda	#HSSECONDS
    540  271c9				   -	       endif
    541  271c9				   -
    542  271c9				   -	       sta	countdownseconds
    543  271c9				   -
    544  271c9				   -			;plot the "cursor" initial sprite...
    545  271c9				   -	       lda	hsinitialhold
    546  271c9				   -
    547  271c9				   -	       sta	temp1
    548  271c9				   -	       lda	#>(hiscorefont+32)
    549  271c9				   -	       sta	temp2
    550  271c9				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    551  271c9				   -	       sta	temp3	; palette/width
    552  271c9				   -	       lda	hscursorx
    553  271c9				   -	       asl
    554  271c9				   -	       asl
    555  271c9				   -	       clc
    556  271c9				   -	       adc	#104
    557  271c9				   -	       sta	temp4	; X
    558  271c9				   -	       lda	hsnewscoreline
    559  271c9				   -	       asl
    560  271c9				   -	       asl
    561  271c9				   -	       asl
    562  271c9				   -	       asl
    563  271c9				   -	       adc	#((3*16)+HSCURSORY)
    564  271c9				   -	       sta	temp5	; Y
    565  271c9				   -	       lda	#%01000000
    566  271c9				   -	       sta	temp6
    567  271c9				   -	       jsr	plotsprite
    568  271c9				   -
    569  271c9				   -	       ldx	hscursorx
    570  271c9				   -	       ldy	hsdisplaymode
    571  271c9				   -	       ifnconst	.HSup
    572  271c9				   -	       lda	sSWCHA
    573  271c9				   -	       cpy	#3
    574  271c9				   -	       bne	hsskipadjustjoystick1
    575  271c9				   -	       asl
    576  271c9				   -	       asl
    577  271c9				   -	       asl
    578  271c9				   -	       asl
    579  271c9				   -hsskipadjustjoystick1
    580  271c9				   -	       sta	hsswcha
    581  271c9				   -	       else		; there are user-defined routines!
    582  271c9				   -	       jsr	.HSdown
    583  271c9				   -	       lda	hsreturn	; b0
    584  271c9				   -	       asl
    585  271c9				   -	       pha
    586  271c9				   -	       jsr	.HSup
    587  271c9				   -	       pla
    588  271c9				   -	       ora	hsreturn
    589  271c9				   -	       asl
    590  271c9				   -	       asl
    591  271c9				   -	       asl
    592  271c9				   -	       asl
    593  271c9				   -	       eor	#$FF
    594  271c9				   -	       sta	hsswcha
    595  271c9				   -	       endif
    596  271c9				   -	       lda	SWCHB
    597  271c9				   -	       and	#%00000010
    598  271c9				   -	       bne	hsskipselectswitch
    599  271c9				   -	       lda	#%00010000
    600  271c9				   -	       sta	hsswcha
    601  271c9				   -	       bne	hsdodebouncecheck
    602  271c9				   -hsskipselectswitch
    603  271c9				   -	       lda	hsswcha
    604  271c9				   -	       and	#%00110000
    605  271c9				   -	       cmp	#%00110000
    606  271c9				   -	       beq	hsjoystickskipped
    607  271c9				   -hsdodebouncecheck
    608  271c9				   -	       lda	hsjoydebounce
    609  271c9				   -	       beq	hsdontdebounce
    610  271c9				   -	       jmp	hspostjoystick
    611  271c9				   -hsdontdebounce
    612  271c9				   -	       ldx	#1	; small tick sound
    613  271c9				   -	       jsr	playhssfx
    614  271c9				   -	       lda	hsswcha
    615  271c9				   -	       and	#%00110000
    616  271c9				   -	       ldx	hscursorx
    617  271c9				   -	       cmp	#%00100000	; check down
    618  271c9				   -	       bne	hsjoycheckup
    619  271c9				   -	       ldy	hsinitialhold
    620  271c9				   -	       cpx	#0
    621  271c9				   -	       bne	skipavoid31_1
    622  271c9				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    623  271c9				   -	       bne	skipavoid31_1
    624  271c9				   -	       dey
    625  271c9				   -skipavoid31_1
    626  271c9				   -	       dey
    627  271c9				   -	       jmp	hssetdebounce
    628  271c9				   -hsjoycheckup
    629  271c9				   -	       cmp	#%00010000	; check up
    630  271c9				   -	       bne	hsjoystickskipped
    631  271c9				   -	       ldy	hsinitialhold
    632  271c9				   -	       cpx	#0
    633  271c9				   -	       bne	skipavoid31_2
    634  271c9				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    635  271c9				   -	       bne	skipavoid31_2
    636  271c9				   -	       iny
    637  271c9				   -skipavoid31_2
    638  271c9				   -	       iny
    639  271c9				   -hssetdebounce
    640  271c9				   -	       tya
    641  271c9				   -	       and	#31
    642  271c9				   -	       sta	hsinitialhold
    643  271c9				   -	       lda	#15
    644  271c9				   -	       sta	hsjoydebounce
    645  271c9				   -	       bne	hspostjoystick
    646  271c9				   -hsjoystickskipped
    647  271c9				   -			; check the fire button only when the stick isn't engaged
    648  271c9				   -	       lda	hsinpt1
    649  271c9				   -	       bpl	hsbuttonskipped
    650  271c9				   -	       lda	hsjoydebounce
    651  271c9				   -	       bne	hspostjoystick
    652  271c9				   -hsfiredontdebounce
    653  271c9				   -	       lda	hsinitialhold
    654  271c9				   -	       cmp	#31
    655  271c9				   -	       beq	hsmovecursorback
    656  271c9				   -	       inc	hscursorx
    657  271c9				   -	       inc	hsinitialpos
    658  271c9				   -	       lda	hscursorx
    659  271c9				   -	       cmp	#3
    660  271c9				   -	       bne	skiphsentryisdone
    661  271c9				   -	       lda	#0
    662  271c9				   -	       sta	framecounter
    663  271c9				   -	       lda	#$ff
    664  271c9				   -	       sta	hsnewscoreline
    665  271c9				   -	       dec	hsinitialpos
    666  271c9				   -	       bne	skiphsentryisdone
    667  271c9				   -hsmovecursorback
    668  271c9				   -	       lda	hscursorx
    669  271c9				   -	       beq	skiphsmovecursorback
    670  271c9				   -	       lda	#29
    671  271c9				   -	       ldx	hsinitialpos
    672  271c9				   -	       sta	HSRAMInitials,x
    673  271c9				   -	       dec	hsinitialpos
    674  271c9				   -	       dec	hscursorx
    675  271c9				   -	       dex
    676  271c9				   -	       lda	HSRAMInitials,x
    677  271c9				   -	       sta	hsinitialhold
    678  271c9				   -skiphsmovecursorback
    679  271c9				   -skiphsentryisdone
    680  271c9				   -	       ldx	#0
    681  271c9				   -	       jsr	playhssfx
    682  271c9				   -	       lda	#20
    683  271c9				   -	       sta	hsjoydebounce
    684  271c9				   -	       bne	hspostjoystick
    685  271c9				   -
    686  271c9				   -hsbuttonskipped
    687  271c9				   -	       lda	#0
    688  271c9				   -	       sta	hsjoydebounce
    689  271c9				   -hspostjoystick
    690  271c9				   -
    691  271c9				   -	       ldx	hsinitialpos
    692  271c9				   -	       lda	hsinitialhold
    693  271c9				   -	       sta	HSRAMInitials,x
    694  271c9				   -
    695  271c9				   -	       jmp	skiphschasecolors
    696  271c9				   -
    697  271c9				   -skipenterscorecontrol
    698  271c9				   -	       jsr	hschasecolors
    699  271c9				   -	       jsr	setuphsinpt1
    700  271c9				   -	       lda	hsjoydebounce
    701  271c9				   -	       bne	skiphschasecolors
    702  271c9				   -	       lda	hsinpt1
    703  271c9				   -	       bmi	returnfromhs
    704  271c9				   -skiphschasecolors
    705  271c9				   -
    706  271c9				   -	       jsr	drawscreen
    707  271c9				   -
    708  271c9				   -	       lda	countdownseconds
    709  271c9				   -	       beq	returnfromhs
    710  271c9				   -	       jmp	keepdisplayinghs
    711  271c9				   -returnfromhs
    712  271c9				   -
    713  271c9				   -	       ifconst	songdatastart_song_highscore
    714  271c9				   -	       lda	hsdisplaymode
    715  271c9				   -	       beq	skipclearHSCsong
    716  271c9				   -	       lda	#0
    717  271c9				   -	       sta	songtempo
    718  271c9				   -skipclearHSCsong
    719  271c9				   -	       endif
    720  271c9				   -	       jsr	drawwait
    721  271c9				   -	       jsr	clearscreen
    722  271c9				   -	       lda	#0
    723  271c9				   -	       ldy	#7
    724  271c9				   -	       jsr	blacken320colors
    725  271c9				   -			;lda ssCHARBASE
    726  271c9				   -	       pla
    727  271c9				   -	       sta	sCHARBASE
    728  271c9				   -			;lda ssCTRL
    729  271c9				   -	       pla
    730  271c9				   -	       sta	sCTRL
    731  271c9				   -	       rts
    732  271c9				   -
    733  271c9				   -setuphsinpt1
    734  271c9				   -	       lda	#$ff
    735  271c9				   -	       sta	hsinpt1
    736  271c9				   -	       lda	hsjoydebounce
    737  271c9				   -	       beq	skipdebounceadjust
    738  271c9				   -	       dec	hsjoydebounce
    739  271c9				   -	       bne	skipstorefirebuttonstatus
    740  271c9				   -skipdebounceadjust
    741  271c9				   -	       lda	SWCHB
    742  271c9				   -	       and	#%00000001
    743  271c9				   -	       bne	hscheckresetover
    744  271c9				   -	       lda	#$ff
    745  271c9				   -	       sta	hsinpt1
    746  271c9				   -	       rts
    747  271c9				   -hscheckresetover
    748  271c9				   -	       ifnconst	.HSup
    749  271c9				   -	       ldx	hsdisplaymode
    750  271c9				   -	       cpx	#3
    751  271c9				   -	       bne	hsskipadjustjoyfire1
    752  271c9				   -	       lda	sINPT3
    753  271c9				   -	       jmp	hsskipadjustjoyfire1done
    754  271c9				   -hsskipadjustjoyfire1
    755  271c9				   -	       lda	sINPT1
    756  271c9				   -hsskipadjustjoyfire1done
    757  271c9				   -	       sta	hsinpt1
    758  271c9				   -	       else		; there are user-defined routines!
    759  271c9				   -	       jsr	.HSselect
    760  271c9				   -	       lda	hsreturn
    761  271c9				   -	       ror		; carry
    762  271c9				   -	       ror		; b7
    763  271c9				   -	       sta	hsinpt1
    764  271c9				   -	       endif	.HSup
    765  271c9				   -skipstorefirebuttonstatus
    766  271c9				   -	       rts
    767  271c9				   -
    768  271c9				   -blacken320colors
    769  271c9				   -	       ldy	#7
    770  271c9				   -blacken320colorsloop
    771  271c9				   -	       sta	P0C2,y
    772  271c9				   -	       dey
    773  271c9				   -	       bpl	blacken320colorsloop
    774  271c9				   -	       rts
    775  271c9				   -
    776  271c9				   -hschasecolors
    777  271c9				   -	       lda	framecounter
    778  271c9				   -	       and	#3
    779  271c9				   -	       bne	hschasecolorsreturn
    780  271c9				   -	       inc	hscolorchaseindex
    781  271c9				   -	       lda	hscolorchaseindex
    782  271c9				   -
    783  271c9				   -	       sta	P5C2
    784  271c9				   -	       sbc	#$02
    785  271c9				   -	       sta	P4C2
    786  271c9				   -	       sbc	#$02
    787  271c9				   -	       sta	P3C2
    788  271c9				   -	       sbc	#$02
    789  271c9				   -	       sta	P2C2
    790  271c9				   -	       sbc	#$02
    791  271c9				   -	       sta	P1C2
    792  271c9				   -hschasecolorsreturn
    793  271c9				   -	       rts
    794  271c9				   -
    795  271c9				   -playhssfx
    796  271c9				   -	       lda	hssfx_lo,x
    797  271c9				   -	       sta	temp1
    798  271c9				   -	       lda	hssfx_hi,x
    799  271c9				   -	       sta	temp2
    800  271c9				   -	       lda	#0
    801  271c9				   -	       sta	temp3
    802  271c9				   -	       jmp	schedulesfx
    803  271c9				   -
    804  271c9				   -hssfx_lo
    805  271c9				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    806  271c9				   -hssfx_hi
    807  271c9				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    808  271c9				   -
    809  271c9				   -sfx_hsletterpositionchange
    810  271c9				   -	       .byte	$10,$18,$00
    811  271c9				   -	       .byte	$02,$06,$08
    812  271c9				   -	       .byte	$02,$06,$04
    813  271c9				   -	       .byte	$00,$00,$00
    814  271c9				   -sfx_hslettertick
    815  271c9				   -	       .byte	$10,$18,$00
    816  271c9				   -	       .byte	$00,$00,$0a
    817  271c9				   -	       .byte	$00,$00,$00
    818  271c9				   -
    819  271c9				   -highscorelabeladjust1
    820  271c9				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    821  271c9				   -highscorelabeladjust2
    822  271c9				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    823  271c9				   -
    824  271c9				   -scorevarlo
    825  271c9				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    826  271c9				   -scorevarhi
    827  271c9				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    828  271c9				   -
    829  271c9				   -	       endif		; !isBANKSETBANK
    830  271c9				   -
    831  271c9				   -	       ifnconst	HSNOLEVELNAMES
    832  271c9				   -	       ifnconst	isBANKSETBANK
    833  271c9				   -highscoredifficultytextlo
    834  271c9				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    835  271c9				   -highscoredifficultytexthi
    836  271c9				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    837  271c9				   -	       endif		; !isBANKSETBANK
    838  271c9				   -
    839  271c9				   -	       ifnconst	HSCUSTOMLEVELNAMES
    840  271c9				   -	       ifnconst	isBANKSETBANK
    841  271c9				   -highscoredifficultytextlen
    842  271c9				   -	       .byte	22, 30, 26, 24
    843  271c9				   -	       endif		; !isBANKSETBANK
    844  271c9				   -
    845  271c9				   -	       ifconst	HSCHARSHERE
    846  271c9				   -
    847  271c9				   -easylevelname
    848  271c9				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  271c9				   -mediumlevelname
    850  271c9				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    851  271c9				   -hardlevelname
    852  271c9				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    853  271c9				   -expertlevelname
    854  271c9				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    855  271c9				   -	       endif		; HSCHARSHERE
    856  271c9				   -	       else		; HSCUSTOMLEVELNAMES
    857  271c9				   -	       include	"7800hsgamediffnames.asm"
    858  271c9				   -	       endif		; HSCUSTOMLEVELNAMES
    859  271c9				   -	       else		; HSNOLEVELNAMES
    860  271c9				   -	       ifconst	HSCHARSHERE
    861  271c9				   -HSHIGHSCOREStext
    862  271c9				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    863  271c9				   -	       endif		; HSCHARSHERE
    864  271c9				   -	       endif		; HSNOLEVELNAMES
    865  271c9				   -
    866  271c9				   -	       ifnconst	isBANKSETBANK
    867  271c9				   -highscorelabeltextlo
    868  271c9				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    869  271c9				   -highscorelabeltexthi
    870  271c9				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    871  271c9				   -	       endif		; !isBANKSETBANK
    872  271c9				   -
    873  271c9				   -	       ifconst	HSCHARSHERE
    874  271c9				   -player0label
    875  271c9				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    876  271c9				   -
    877  271c9				   -player1label
    878  271c9				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    879  271c9				   -
    880  271c9				   -player2label
    881  271c9				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    882  271c9				   -	       endif		; HSCHARSHERE
    883  271c9				   -
    884  271c9				   -
    885  271c9				   -	       ifconst	HSGAMENAMELEN
    886  271c9				   -	       ifconst	HSCHARSHERE
    887  271c9				   -HSGAMENAMEtable
    888  271c9				   -	       include	"7800hsgamename.asm"
    889  271c9				   -	       endif		; HSCHARSHERE
    890  271c9				   -	       endif		; HSGAMENAMELEN
    891  271c9				   -	       ifconst	HSGAMERANKS
    892  271c9				   -	       include	"7800hsgameranks.asm"
    893  271c9				   -	       ifconst	HSCHARSHERE
    894  271c9				   -highscoreranklabel
    895  271c9				   -	       .byte	$11,$00,$0d,$0a,$1a
    896  271c9				   -	       endif		; HSCHARSHERE
    897  271c9				   -	       endif		; HSGAMERANKS
    898  271c9				   -
    899  271c9				   -			;ensure our table doesn't wrap a page...
    900  271c9				   -	       if	((<*)>251)
    901  271c9				   -	       align	256
    902  271c9				   -	       endif
    903  271c9				   -hsgameslotnumbers
    904  271c9				   -	       .byte	33,34,35,36,37
    905  271c9				   -	       endif		; hiscorefont
    906  271c9				   -
    907  271c9				   -
    908  271c9				   -	       ifnconst	isBANKSETBANK
    909  271c9				   -loaddifficultytable
    910  271c9				   -	       lda	gamedifficulty
    911  271c9				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    912  271c9				   -	       sta	gamedifficulty
    913  271c9				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    914  271c9				   -	       bne	loaddifficultytablecontinue1
    915  271c9				   -	       rts		; this high score difficulty table is already loaded
    916  271c9				   -loaddifficultytablecontinue1
    917  271c9				   -	       lda	gamedifficulty
    918  271c9				   -	       sta	hsdifficulty
    919  271c9				   -			;we need to check the device for the table
    920  271c9				   -	       lda	hsdevice
    921  271c9				   -	       bne	loaddifficultytablecontinue2
    922  271c9				   -			; there's no save device. clear out this table.
    923  271c9				   -	       jmp	cleardifficultytablemem
    924  271c9				   -loaddifficultytablecontinue2
    925  271c9				   -	       lda	hsdevice
    926  271c9				   -	       and	#1
    927  271c9				   -	       beq	memdeviceisntHSC
    928  271c9				   -	       jmp	loaddifficultytableHSC
    929  271c9				   -memdeviceisntHSC
    930  271c9				   -	       jmp	loaddifficultytableAVOX
    931  271c9				   -
    932  271c9				   -savedifficultytable
    933  271c9				   -			;*** we need to check which device we should use...
    934  271c9				   -	       lda	hsdevice
    935  271c9				   -	       bne	savedifficultytablerealdevice
    936  271c9				   -	       rts		; its a ram device
    937  271c9				   -savedifficultytablerealdevice
    938  271c9				   -	       and	#1
    939  271c9				   -	       beq	savememdeviceisntHSC
    940  271c9				   -	       jmp	savedifficultytableHSC
    941  271c9				   -savememdeviceisntHSC
    942  271c9				   -	       jmp	savedifficultytableAVOX
    943  271c9				   -
    944  271c9				   -savedifficultytableAVOX
    945  271c9				   -			; the load call already setup the memory structure and atarivox memory location
    946  271c9				   -	       jsr	savealoadedHSCtablecontinue
    947  271c9				   -savedifficultytableAVOXskipconvert
    948  271c9				   -	       lda	#HSIDHI
    949  271c9				   -	       sta	eeprombuffer
    950  271c9				   -	       lda	#HSIDLO
    951  271c9				   -	       sta	eeprombuffer+1
    952  271c9				   -	       lda	hsdifficulty
    953  271c9				   -	       sta	eeprombuffer+2
    954  271c9				   -	       lda	#32
    955  271c9				   -	       jsr	AVoxWriteBytes
    956  271c9				   -	       rts
    957  271c9				   -
    958  271c9				   -savedifficultytableHSC
    959  271c9				   -			;we always load a table before reaching here, so the
    960  271c9				   -			;memory structures from the load should be intact...
    961  271c9				   -	       ldy	hsgameslot
    962  271c9				   -	       bpl	savealoadedHSCtable
    963  271c9				   -	       rts
    964  271c9				   -savealoadedHSCtable
    965  271c9				   -	       lda	HSCGameDifficulty,y
    966  271c9				   -	       cmp	#$7F
    967  271c9				   -	       bne	savealoadedHSCtablecontinue
    968  271c9				   -	       jsr	initializeHSCtableentry
    969  271c9				   -savealoadedHSCtablecontinue
    970  271c9				   -			;convert our RAM table to HSC format and write it out...
    971  271c9				   -	       ldy	#0
    972  271c9				   -	       ldx	#0
    973  271c9				   -savedifficultytableScores
    974  271c9				   -
    975  271c9				   -	       lda	HSRAMInitials,x
    976  271c9				   -	       sta	temp3
    977  271c9				   -	       lda	HSRAMInitials+1,x
    978  271c9				   -	       sta	temp4
    979  271c9				   -	       lda	HSRAMInitials+2,x
    980  271c9				   -	       sta	temp5
    981  271c9				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    982  271c9				   -
    983  271c9				   -	       lda	temp1
    984  271c9				   -	       sta	(HSGameTableLo),y
    985  271c9				   -	       iny
    986  271c9				   -	       lda	temp2
    987  271c9				   -	       sta	(HSGameTableLo),y
    988  271c9				   -	       iny
    989  271c9				   -
    990  271c9				   -	       lda	HSRAMScores,x
    991  271c9				   -	       sta	(HSGameTableLo),y
    992  271c9				   -	       iny
    993  271c9				   -	       lda	HSRAMScores+1,x
    994  271c9				   -	       sta	(HSGameTableLo),y
    995  271c9				   -	       iny
    996  271c9				   -	       lda	HSRAMScores+2,x
    997  271c9				   -	       sta	(HSGameTableLo),y
    998  271c9				   -	       iny
    999  271c9				   -	       inx
   1000  271c9				   -	       inx
   1001  271c9				   -	       inx		; +3
   1002  271c9				   -	       cpx	#15
   1003  271c9				   -	       bne	savedifficultytableScores
   1004  271c9				   -	       rts
   1005  271c9				   -
   1006  271c9				   -loaddifficultytableHSC
   1007  271c9				   -			; routine responsible for loading the difficulty table from HSC
   1008  271c9				   -	       jsr	findindexHSC
   1009  271c9				   -	       ldy	hsgameslot
   1010  271c9				   -	       lda	HSCGameDifficulty,y
   1011  271c9				   -	       cmp	#$7F
   1012  271c9				   -	       bne	loaddifficultytableHSCcontinue
   1013  271c9				   -			;there was an error. use a new RAM table instead...
   1014  271c9				   -	       jsr	initializeHSCtableentry
   1015  271c9				   -	       jmp	cleardifficultytablemem
   1016  271c9				   -loaddifficultytableHSCcontinue
   1017  271c9				   -			; parse the data into the HS memory...
   1018  271c9				   -	       ldy	#0
   1019  271c9				   -	       ldx	#0
   1020  271c9				   -loaddifficultytableScores
   1021  271c9				   -	       lda	(HSGameTableLo),y
   1022  271c9				   -	       sta	temp1
   1023  271c9				   -	       iny
   1024  271c9				   -	       lda	(HSGameTableLo),y
   1025  271c9				   -	       sta	temp2
   1026  271c9				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1027  271c9				   -	       iny
   1028  271c9				   -	       lda	(HSGameTableLo),y
   1029  271c9				   -	       sta	HSRAMScores,x
   1030  271c9				   -	       lda	temp3
   1031  271c9				   -	       sta	HSRAMInitials,x
   1032  271c9				   -	       inx
   1033  271c9				   -	       iny
   1034  271c9				   -	       lda	(HSGameTableLo),y
   1035  271c9				   -	       sta	HSRAMScores,x
   1036  271c9				   -	       lda	temp4
   1037  271c9				   -	       sta	HSRAMInitials,x
   1038  271c9				   -	       inx
   1039  271c9				   -	       iny
   1040  271c9				   -	       lda	(HSGameTableLo),y
   1041  271c9				   -	       sta	HSRAMScores,x
   1042  271c9				   -	       lda	temp5
   1043  271c9				   -	       sta	HSRAMInitials,x
   1044  271c9				   -	       inx
   1045  271c9				   -	       iny
   1046  271c9				   -	       cpx	#15
   1047  271c9				   -	       bne	loaddifficultytableScores
   1048  271c9				   -	       ldx	#14
   1049  271c9				   -	       lda	#$ff
   1050  271c9				   -validatescoresloop
   1051  271c9				   -	       and	HSRAMScores,x
   1052  271c9				   -	       dex
   1053  271c9				   -	       bpl	validatescoresloop
   1054  271c9				   -	       cmp	#$ff
   1055  271c9				   -	       bne	exitloaddifficultytableScores
   1056  271c9				   -	       jmp	cleardifficultytablemem
   1057  271c9				   -exitloaddifficultytableScores
   1058  271c9				   -	       rts
   1059  271c9				   -
   1060  271c9				   -decodeHSCInitials
   1061  271c9				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1062  271c9				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1063  271c9				   -	       lda	#0
   1064  271c9				   -	       sta	temp4
   1065  271c9				   -	       lda	temp1
   1066  271c9				   -	       and	#%00011111
   1067  271c9				   -	       sta	temp3
   1068  271c9				   -
   1069  271c9				   -	       lda	temp2
   1070  271c9				   -	       and	#%00011111
   1071  271c9				   -	       sta	temp5
   1072  271c9				   -
   1073  271c9				   -	       lda	temp1
   1074  271c9				   -	       asl
   1075  271c9				   -	       rol	temp4
   1076  271c9				   -	       asl
   1077  271c9				   -	       rol	temp4
   1078  271c9				   -	       asl
   1079  271c9				   -	       rol	temp4
   1080  271c9				   -	       lda	temp2
   1081  271c9				   -	       asl
   1082  271c9				   -	       rol	temp4
   1083  271c9				   -	       asl
   1084  271c9				   -	       rol	temp4
   1085  271c9				   -	       rts
   1086  271c9				   -encodeHSCInitials
   1087  271c9				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1088  271c9				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1089  271c9				   -			; start with packing temp1...
   1090  271c9				   -	       lda	temp4
   1091  271c9				   -	       and	#%00011100
   1092  271c9				   -	       sta	temp1
   1093  271c9				   -	       asl	temp1
   1094  271c9				   -	       asl	temp1
   1095  271c9				   -	       asl	temp1
   1096  271c9				   -	       lda	temp3
   1097  271c9				   -	       and	#%00011111
   1098  271c9				   -	       ora	temp1
   1099  271c9				   -	       sta	temp1
   1100  271c9				   -			; ...temp1 is now packed, on to temp2...
   1101  271c9				   -	       lda	temp5
   1102  271c9				   -	       asl
   1103  271c9				   -	       asl
   1104  271c9				   -	       ror	temp4
   1105  271c9				   -	       ror
   1106  271c9				   -	       ror	temp4
   1107  271c9				   -	       ror
   1108  271c9				   -	       sta	temp2
   1109  271c9				   -	       rts
   1110  271c9				   -
   1111  271c9				   -findindexHSCerror
   1112  271c9				   -			;the HSC is stuffed. return the bad slot flag
   1113  271c9				   -	       ldy	#$ff
   1114  271c9				   -	       sty	hsgameslot
   1115  271c9				   -	       rts
   1116  271c9				   -
   1117  271c9				   -findindexHSC
   1118  271c9				   -HSCGameID1 =	$1029
   1119  271c9				   -HSCGameID2 =	$106E
   1120  271c9				   -HSCGameDifficulty =	$10B3
   1121  271c9				   -HSCGameIndex =	$10F8
   1122  271c9				   -			; routine responsible for finding the game index from HSC
   1123  271c9				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1124  271c9				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1125  271c9				   -	       ldy	#69	; start +1 to account for the dey
   1126  271c9				   -findindexHSCloop
   1127  271c9				   -	       dey
   1128  271c9				   -	       bmi	findindexHSCerror
   1129  271c9				   -	       lda	HSCGameDifficulty,y
   1130  271c9				   -	       cmp	#$7F
   1131  271c9				   -	       beq	findourindexHSC
   1132  271c9				   -	       cmp	gamedifficulty
   1133  271c9				   -	       bne	findindexHSCloop
   1134  271c9				   -	       lda	HSCGameID1,y
   1135  271c9				   -	       cmp	#HSIDHI
   1136  271c9				   -	       bne	findindexHSCloop
   1137  271c9				   -	       lda	HSCGameID2,y
   1138  271c9				   -	       cmp	#HSIDLO
   1139  271c9				   -	       bne	findindexHSCloop
   1140  271c9				   -findourindexHSC
   1141  271c9				   -			; if we're here we found our index in the table
   1142  271c9				   -			; or we found the first empty one
   1143  271c9				   -	       sty	hsgameslot
   1144  271c9				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1145  271c9				   -	       rts
   1146  271c9				   -
   1147  271c9				   -
   1148  271c9				   -initializeHSCtableentry
   1149  271c9				   -	       ldy	hsgameslot
   1150  271c9				   -			; we need to make a new entry...
   1151  271c9				   -	       lda	#HSIDHI
   1152  271c9				   -	       sta	HSCGameID1,y
   1153  271c9				   -	       lda	#HSIDLO
   1154  271c9				   -	       sta	HSCGameID2,y
   1155  271c9				   -	       lda	gamedifficulty
   1156  271c9				   -	       sta	HSCGameDifficulty,y
   1157  271c9				   -	       ldx	#0
   1158  271c9				   -fixHSDGameDifficultylistLoop
   1159  271c9				   -	       inx
   1160  271c9				   -	       txa
   1161  271c9				   -	       sta	HSCGameIndex,y
   1162  271c9				   -	       iny
   1163  271c9				   -	       cpy	#69
   1164  271c9				   -	       bne	fixHSDGameDifficultylistLoop
   1165  271c9				   -	       rts
   1166  271c9				   -
   1167  271c9				   -setupHSCGamepointer
   1168  271c9				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1169  271c9				   -	       lda	#$17
   1170  271c9				   -	       sta	HSGameTableHi
   1171  271c9				   -	       lda	#$FA
   1172  271c9				   -	       sta	HSGameTableLo
   1173  271c9				   -setupHSCGamepointerLoop
   1174  271c9				   -	       lda	HSGameTableLo
   1175  271c9				   -	       sec
   1176  271c9				   -	       sbc	#25
   1177  271c9				   -	       sta	HSGameTableLo
   1178  271c9				   -	       lda	HSGameTableHi
   1179  271c9				   -	       sbc	#0
   1180  271c9				   -	       sta	HSGameTableHi
   1181  271c9				   -	       iny
   1182  271c9				   -	       cpy	#69
   1183  271c9				   -	       bne	setupHSCGamepointerLoop
   1184  271c9				   -	       rts
   1185  271c9				   -
   1186  271c9				   -loaddifficultytableAVOX
   1187  271c9				   -			; routine responsible for loading the difficulty table from Avox
   1188  271c9				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1189  271c9				   -	       lda	#>(eeprombuffer+3)
   1190  271c9				   -	       sta	HSGameTableHi
   1191  271c9				   -	       lda	#<(eeprombuffer+3)
   1192  271c9				   -	       sta	HSGameTableLo
   1193  271c9				   -
   1194  271c9				   -			; the start location in EEPROM, subtract 32...
   1195  271c9				   -	       lda	#$5F
   1196  271c9				   -	       sta	HSVoxHi
   1197  271c9				   -	       lda	#$E0
   1198  271c9				   -	       sta	HSVoxLo
   1199  271c9				   -	       lda	#0
   1200  271c9				   -	       sta	temp1
   1201  271c9				   -loaddifficultytableAVOXloop
   1202  271c9				   -	       inc	temp1
   1203  271c9				   -	       beq	loaddifficultytableAVOXfull
   1204  271c9				   -	       clc
   1205  271c9				   -	       lda	HSVoxLo
   1206  271c9				   -	       adc	#32
   1207  271c9				   -	       sta	HSVoxLo
   1208  271c9				   -	       lda	HSVoxHi
   1209  271c9				   -	       adc	#0
   1210  271c9				   -	       sta	HSVoxHi
   1211  271c9				   -	       lda	#3
   1212  271c9				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1213  271c9				   -	       lda	eeprombuffer
   1214  271c9				   -	       cmp	#$FF
   1215  271c9				   -	       beq	loaddifficultytableAVOXempty
   1216  271c9				   -	       cmp	#HSIDHI
   1217  271c9				   -	       bne	loaddifficultytableAVOXloop
   1218  271c9				   -	       lda	eeprombuffer+1
   1219  271c9				   -	       cmp	#HSIDLO
   1220  271c9				   -	       bne	loaddifficultytableAVOXloop
   1221  271c9				   -	       lda	eeprombuffer+2
   1222  271c9				   -	       cmp	gamedifficulty
   1223  271c9				   -	       bne	loaddifficultytableAVOXloop
   1224  271c9				   -loaddifficultytableAVOXdone
   1225  271c9				   -	       lda	#32
   1226  271c9				   -	       jsr	AVoxReadBytes
   1227  271c9				   -	       jsr	loaddifficultytableHSCcontinue
   1228  271c9				   -	       rts
   1229  271c9				   -loaddifficultytableAVOXfull
   1230  271c9				   -	       lda	#0
   1231  271c9				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1232  271c9				   -loaddifficultytableAVOXempty
   1233  271c9				   -	       jmp	cleardifficultytablemem
   1234  271c9				   -	       rts
   1235  271c9				   -
   1236  271c9				   -cleardifficultytablemem
   1237  271c9				   -	       ldy	#29
   1238  271c9				   -	       lda	#0
   1239  271c9				   -cleardifficultytablememloop
   1240  271c9				   -	       sta	HSRAMTable,y
   1241  271c9				   -	       dey
   1242  271c9				   -	       bpl	cleardifficultytablememloop
   1243  271c9				   -	       rts
   1244  271c9				   -hiscoremoduleend
   1245  271c9				   -
   1246  271c9				   -hiscorecleardlmem
   1247  271c9				   -	       ldx	#(WZONECOUNT-1)
   1248  271c9				   -hiscorecleardlmemloop1
   1249  271c9				   -	       lda	DLPOINTL,x
   1250  271c9				   -	       sta	dlpnt
   1251  271c9				   -	       lda	DLPOINTH,x
   1252  271c9				   -	       sta	dlpnt+1
   1253  271c9				   -	       lda	#0
   1254  271c9				   -	       ldy	#17
   1255  271c9				   -hiscorecleardlmemloop2
   1256  271c9				   -	       sta	(dlpnt),y
   1257  271c9				   -	       dey
   1258  271c9				   -	       bpl	hiscorecleardlmemloop2
   1259  271c9				   -	       dex
   1260  271c9				   -	       bpl	hiscorecleardlmemloop1
   1261  271c9				   -	       rts
   1262  271c9				   -
   1263  271c9				   -	       ifconst	DOUBLEWIDE
   1264  271c9				   -plotvaluedw
   1265  271c9				   -plotdigitcount =	temp6
   1266  271c9				   -	       lda	#0
   1267  271c9				   -	       tay
   1268  271c9				   -	       ldx	valbufend
   1269  271c9				   -
   1270  271c9				   -	       lda	plotdigitcount
   1271  271c9				   -	       and	#1
   1272  271c9				   -	       beq	pvnibble2chardw
   1273  271c9				   -	       lda	#0
   1274  271c9				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1275  271c9				   -	       beq	pvnibble2char_skipnibbledw
   1276  271c9				   -
   1277  271c9				   -pvnibble2chardw
   1278  271c9				   -			; high nibble...
   1279  271c9				   -	       lda	(temp7),y
   1280  271c9				   -	       and	#$f0
   1281  271c9				   -	       lsr
   1282  271c9				   -	       lsr
   1283  271c9				   -	       lsr
   1284  271c9				   -	       lsr
   1285  271c9				   -
   1286  271c9				   -	       clc
   1287  271c9				   -	       adc	temp1	; add the offset to character graphics to our value
   1288  271c9				   -	       sta	VALBUFFER,x
   1289  271c9				   -	       inx
   1290  271c9				   -	       dec	plotdigitcount
   1291  271c9				   -pvnibble2char_skipnibbledw
   1292  271c9				   -			; low nibble...
   1293  271c9				   -	       lda	(temp7),y
   1294  271c9				   -	       and	#$0f
   1295  271c9				   -	       clc
   1296  271c9				   -	       adc	temp1	; add the offset to character graphics to our value
   1297  271c9				   -	       sta	VALBUFFER,x
   1298  271c9				   -	       inx
   1299  271c9				   -	       iny
   1300  271c9				   -
   1301  271c9				   -	       dec	plotdigitcount
   1302  271c9				   -	       bne	pvnibble2chardw
   1303  271c9				   -			;point to the start of our valuebuffer
   1304  271c9				   -	       clc
   1305  271c9				   -	       lda	#<VALBUFFER
   1306  271c9				   -	       adc	valbufend
   1307  271c9				   -	       sta	temp1
   1308  271c9				   -	       lda	#>VALBUFFER
   1309  271c9				   -	       adc	#0
   1310  271c9				   -	       sta	temp2
   1311  271c9				   -
   1312  271c9				   -			;advance valbufend to the end of our value buffer
   1313  271c9				   -	       stx	valbufend
   1314  271c9				   -
   1315  271c9				   -	       ifnconst	plotvalueonscreen
   1316  271c9				   -	       jmp	plotcharacters
   1317  271c9				   -	       else
   1318  271c9				   -	       jmp	plotcharacterslive
   1319  271c9				   -	       endif
   1320  271c9				   -	       endif		; DOUBLEWIDE
   1321  271c9				   -
   1322  271c9				   -hiscoreend
   1323  271c9				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1324  271c9				   -	       endif		; !isBANKSETBANK
   1325  271c9					       endif		; HSSUPPORT
   1326  271c9
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1877  271c9					       endif
   1878  271c9					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  271c9					       include	fourbitfade.asm
      1  271c9							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  271c9							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  271c9							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  271c9							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  271c9							; **	      other registers are preserved
      6  271c9
      7  271c9				   -	       ifconst	FOURBITFADE
      8  271c9				   -
      9  271c9				   -			; non-interrupt routine
     10  271c9				   -
     11  271c9				   -fourbitfade
     12  271c9				   -	       sty	fourbittemp1
     13  271c9				   -	       pha
     14  271c9				   -	       and	#$0F
     15  271c9				   -	       ora	fourbitfadevalue
     16  271c9				   -	       tay
     17  271c9				   -	       pla
     18  271c9				   -	       and	#$F0
     19  271c9				   -	       ora	fourbitfadelut,y
     20  271c9				   -	       ldy	fourbittemp1	; restore Y
     21  271c9				   -	       rts
     22  271c9				   -
     23  271c9				   -			; interrupt routine
     24  271c9				   -
     25  271c9				   -fourbitfadeint
     26  271c9				   -	       sty	fourbittemp1int
     27  271c9				   -	       pha
     28  271c9				   -	       and	#$0F
     29  271c9				   -	       ora	fourbitfadevalueint
     30  271c9				   -	       tay
     31  271c9				   -	       pla
     32  271c9				   -	       and	#$F0
     33  271c9				   -	       ora	fourbitfadelut,y
     34  271c9				   -	       ldy	fourbittemp1int	; restore Y
     35  271c9				   -	       rts
     36  271c9				   -
     37  271c9				   -fourbitfadelut
     38  271c9				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  271c9				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  271c9				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  271c9				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  271c9				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  271c9				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  271c9				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  271c9				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  271c9				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  271c9				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  271c9				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  271c9				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  271c9				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  271c9				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  271c9				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  271c9				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  271c9				   -
     55  271c9				   -fourbitfadeend
     56  271c9				   -
     57  271c9				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes of rom)"
     58  271c9				   -
     59  271c9					       endif
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1880  271c9					       endif
   1881  271c9					       ifnconst	included.plotsprite4.asm
------- FILE plotsprite4.asm LEVEL 2 PASS 3
      0  271c9					       include	plotsprite4.asm
      1  271c9							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  271c9
      3  271c9				   -	       ifconst	PLOTSP4
      4  271c9				   -
      5  271c9				   -plotsprite4
      6  271c9				   -	       ifnconst	NODRAWWAIT
      7  271c9				   -	       ifconst	DOUBLEBUFFER
      8  271c9				   -	       lda	doublebufferstate
      9  271c9				   -	       bne	skipplotsprite4wait
     10  271c9				   -	       endif		; DOUBLEBUFFER
     11  271c9				   -	       ifconst	DEBUGWAITCOLOR
     12  271c9				   -	       lda	#$41
     13  271c9				   -	       sta	BACKGRND
     14  271c9				   -	       endif
     15  271c9				   -plotsprite4wait
     16  271c9				   -	       lda	visibleover
     17  271c9				   -	       bne	plotsprite4wait
     18  271c9				   -skipplotsprite4wait
     19  271c9				   -	       ifconst	DEBUGWAITCOLOR
     20  271c9				   -	       lda	#$0
     21  271c9				   -	       sta	BACKGRND
     22  271c9				   -	       endif
     23  271c9				   -	       endif
     24  271c9				   -
     25  271c9				   -			;arguments:
     26  271c9				   -			; temp1=lo graphicdata
     27  271c9				   -			; temp2=hi graphicdata
     28  271c9				   -			; temp3=palette | width byte
     29  271c9				   -			; temp4=x
     30  271c9				   -			; temp5=y
     31  271c9				   -
     32  271c9				   -	       lda	temp5	;Y position
     33  271c9				   -	       lsr		; 2 - Divide by 8 or 16
     34  271c9				   -	       lsr		; 2
     35  271c9				   -	       lsr		; 2
     36  271c9				   -	       if	WZONEHEIGHT = 16
     37  271c9				   -	       lsr		; 2
     38  271c9				   -	       endif
     39  271c9				   -
     40  271c9				   -	       tax
     41  271c9				   -
     42  271c9				   -	       ifnconst	NOLIMITCHECKING
     43  271c9				   -
     44  271c9				   -			; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
     45  271c9				   -
     46  271c9				   -	       cmp	#WZONECOUNT
     47  271c9				   -
     48  271c9				   -	       bcc	continueplotsprite41	; the sprite is fully on-screen, so carry on...
     49  271c9				   -			; otherwise, check to see if the bottom half is in zone 0...
     50  271c9				   -
     51  271c9				   -	       if	WZONEHEIGHT = 16
     52  271c9				   -	       cmp	#15
     53  271c9				   -	       else
     54  271c9				   -	       cmp	#31
     55  271c9				   -	       endif
     56  271c9				   -
     57  271c9				   -	       bne	exitplotsprite41
     58  271c9				   -	       ldx	#0
     59  271c9				   -	       jmp	continueplotsprite42
     60  271c9				   -exitplotsprite41
     61  271c9				   -	       rts
     62  271c9				   -	       endif
     63  271c9				   -
     64  271c9				   -continueplotsprite41
     65  271c9				   -
     66  271c9				   -	       ifconst	VSCROLL
     67  271c9				   -	       ldy	Xx3,x
     68  271c9				   -	       lda	DLLMEM+11,y
     69  271c9				   -	       else		; !VSCROLL
     70  271c9				   -	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
     71  271c9				   -	       endif		; !VSCROLL
     72  271c9				   -	       ifconst	DOUBLEBUFFER
     73  271c9				   -	       clc
     74  271c9				   -	       adc	doublebufferdloffset
     75  271c9				   -	       endif		; DOUBLEBUFFER
     76  271c9				   -	       sta	dlpnt
     77  271c9				   -	       ifconst	VSCROLL
     78  271c9				   -	       lda	DLLMEM+10,y
     79  271c9				   -	       else		; !VSCROLL
     80  271c9				   -	       lda	DLPOINTH,x
     81  271c9				   -	       endif		; !VSCROLL
     82  271c9				   -	       ifconst	DOUBLEBUFFER
     83  271c9				   -	       adc	#0
     84  271c9				   -	       endif		; DOUBLEBUFFER
     85  271c9				   -	       sta	dlpnt+1
     86  271c9				   -
     87  271c9				   -			;Create DL entry for upper part of sprite
     88  271c9				   -
     89  271c9				   -	       ldy	dlend,x	;Get the index to the end of this DL
     90  271c9				   -
     91  271c9				   -	       ifconst	CHECKOVERWRITE
     92  271c9				   -	       cpy	#DLLASTOBJ
     93  271c9				   -	       beq	checkcontinueplotsprite42
     94  271c9				   -continueplotsprite41a
     95  271c9				   -	       endif
     96  271c9				   -
     97  271c9				   -	       lda	temp1	; graphic data, lo byte
     98  271c9				   -	       sta	(dlpnt),y	;Low byte of data address
     99  271c9				   -
    100  271c9				   -	       iny
    101  271c9				   -	       lda	temp3	;palette|width
    102  271c9				   -	       sta	(dlpnt),y
    103  271c9				   -
    104  271c9				   -	       iny
    105  271c9				   -	       lda	temp5	;Y position
    106  271c9				   -	       and	#(WZONEHEIGHT - 1)
    107  271c9				   -	       cmp	#1	; clear carry if our sprite is just in this zone
    108  271c9				   -	       ora	temp2	; graphic data, hi byte
    109  271c9				   -	       sta	(dlpnt),y
    110  271c9				   -
    111  271c9				   -	       iny
    112  271c9				   -	       lda	temp4	;Horizontal position
    113  271c9				   -	       sta	(dlpnt),y
    114  271c9				   -
    115  271c9				   -	       iny
    116  271c9				   -	       sty	dlend,x
    117  271c9				   -
    118  271c9				   -	       ifconst	ALWAYSTERMINATE
    119  271c9				   -	       iny
    120  271c9				   -	       lda	#0
    121  271c9				   -	       sta	(dlpnt),y
    122  271c9				   -	       endif
    123  271c9				   -
    124  271c9				   -checkcontinueplotsprite42
    125  271c9				   -
    126  271c9				   -	       bcc	doneSPDL4	;branch if the sprite was fully in the last zone
    127  271c9				   -
    128  271c9				   -			;Create DL entry for lower part of sprite
    129  271c9				   -
    130  271c9				   -	       inx		;Next region
    131  271c9				   -
    132  271c9				   -	       ifnconst	NOLIMITCHECKING
    133  271c9				   -	       cpx	#WZONECOUNT
    134  271c9				   -
    135  271c9				   -	       bcc	continueplotsprite42	; the second half of the sprite is fully on-screen, so carry on...
    136  271c9				   -	       rts
    137  271c9				   -continueplotsprite42
    138  271c9				   -	       endif
    139  271c9				   -
    140  271c9				   -	       ifconst	VSCROLL
    141  271c9				   -	       ldy	Xx3,x
    142  271c9				   -	       lda	DLLMEM+11,y
    143  271c9				   -	       else		; !VSCROLL
    144  271c9				   -	       lda	DLPOINTL,x	;Get pointer to next DL
    145  271c9				   -	       endif		; !VSCROLL
    146  271c9				   -	       ifconst	DOUBLEBUFFER
    147  271c9				   -	       clc
    148  271c9				   -	       adc	doublebufferdloffset
    149  271c9				   -	       endif		; DOUBLEBUFFER
    150  271c9				   -	       sta	dlpnt
    151  271c9				   -	       ifconst	VSCROLL
    152  271c9				   -	       lda	DLLMEM+10,y
    153  271c9				   -	       else		; !VSCROLL
    154  271c9				   -	       lda	DLPOINTH,x
    155  271c9				   -	       endif		; !VSCROLL
    156  271c9				   -	       ifconst	DOUBLEBUFFER
    157  271c9				   -	       adc	#0
    158  271c9				   -	       endif		; DOUBLEBUFFER
    159  271c9				   -	       sta	dlpnt+1
    160  271c9				   -	       ldy	dlend,x	;Get the index to the end of this DL
    161  271c9				   -
    162  271c9				   -	       ifconst	CHECKOVERWRITE
    163  271c9				   -	       cpy	#DLLASTOBJ
    164  271c9				   -	       bne	continueplotsprite42a
    165  271c9				   -	       rts
    166  271c9				   -continueplotsprite42a
    167  271c9				   -	       endif
    168  271c9				   -
    169  271c9				   -	       lda	temp1	; graphic data, lo byte
    170  271c9				   -	       sta	(dlpnt),y
    171  271c9				   -
    172  271c9				   -	       iny
    173  271c9				   -	       lda	temp3	;palette|width
    174  271c9				   -	       sta	(dlpnt),y
    175  271c9				   -
    176  271c9				   -	       iny
    177  271c9				   -	       lda	temp5	;Y position
    178  271c9				   -	       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
    179  271c9				   -	       ora	temp2	; graphic data, hi byte
    180  271c9				   -	       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
    181  271c9				   -	       sta	(dlpnt),y
    182  271c9				   -
    183  271c9				   -	       iny
    184  271c9				   -	       lda	temp4	;Horizontal position
    185  271c9				   -	       sta	(dlpnt),y
    186  271c9				   -
    187  271c9				   -	       iny
    188  271c9				   -	       sty	dlend,x
    189  271c9				   -
    190  271c9				   -	       ifconst	ALWAYSTERMINATE
    191  271c9				   -	       iny
    192  271c9				   -	       lda	#0
    193  271c9				   -	       sta	(dlpnt),y
    194  271c9				   -	       endif
    195  271c9				   -
    196  271c9				   -doneSPDL4
    197  271c9				   -	       rts
    198  271c9				   -
    199  271c9					       endif		; PLOTSP4
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1883  271c9					       endif
   1884  271c9					       ifnconst	included.lzsa1compression.asm
------- FILE lzsa1compression.asm LEVEL 2 PASS 3
      0  271c9					       include	lzsa1compression.asm
      1  271c9							; ***************************************************************************
      2  271c9							; ***************************************************************************
      3  271c9							;
      4  271c9							; lzsa1_6502.s
      5  271c9							;
      6  271c9							; NMOS 6502 decompressor for data stored in Emmanuel Marty's LZSA1 format.
      7  271c9							;
      8  271c9							; Decompresses a raw LZSA1 block, created with the command-line lzsa utility:
      9  271c9							;     lzsa -r <original_file> <compressed_file>
     10  271c9							;
     11  271c9							; in:
     12  271c9							; * LZSA_SRC_LO and LZSA_SRC_HI contain the compressed raw block address
     13  271c9							; * LZSA_DST_LO and LZSA_DST_HI contain the destination buffer address
     14  271c9							;
     15  271c9							; out:
     16  271c9							; * the destination buffer will contain the decompressed data
     17  271c9							; * LZSA_DST_LO and LZSA_DST_HI contain the last decompressed byte address +1
     18  271c9							;
     19  271c9							; ***************************************************************************
     20  271c9							;
     21  271c9							; This code is written for the ACME assembler.
     22  271c9							;
     23  271c9							; The code is 165 bytes for the small version, and 191 bytes for the normal.
     24  271c9							;
     25  271c9							; Copyright John Brandwood 2021.
     26  271c9							;
     27  271c9							; Changes intruduced by Mike Saarna, 2023:
     28  271c9							;    -converted to DASM format.
     29  271c9							;    -generalised memory locations, for easier incorporation into 7800basic
     30  271c9							;    -removed self-modifying code, for execution from rom.
     31  271c9							;    -added LZSAFASTCOPYBYTE optimisation ; +24 bytes rom, ~10% quicker
     32  271c9							;
     33  271c9							; get the original unmodified code from:
     34  271c9							; https://raw.githubusercontent.com/emmanuel-marty/lzsa
     35  271c9							;
     36  271c9							; Distributed under the Boost Software License, Version 1.0.
     37  271c9							; (See accompanying file LICENSE_1_0.txt or copy at
     38  271c9							; http://www.boost.org/LICENSE_1_0.txt)
     39  271c9							;
     40  271c9							; ***************************************************************************
     41  271c9							; ***************************************************************************
     42  271c9
     43  271c9
     44  271c9
     45  271c9							; ***************************************************************************
     46  271c9							; ***************************************************************************
     47  271c9							;
     48  271c9							; Decompression Options & Macros
     49  271c9							;
     50  271c9
     51  271c9							;
     52  271c9							; Choose size over decompression speed (within sane limits)?
     53  271c9							;
     54  271c9
     55  271c9			00 00	    LZSA_SMALL_SIZE =	0
     56  271c9			00 01	    LZSAFASTCOPYBYTE =	1	; +24 bytes rom, ~10% quicker
     57  271c9
     58  271c9							; ***************************************************************************
     59  271c9							; ***************************************************************************
     60  271c9							;
     61  271c9							; ZP memory allocations... (temp1-temp9 are 7800basic ZP locations)
     62  271c9			00 42	    LSZA1ZPRAM =	temp1
     63  271c9			00 42	    lzsa_winptr =	LSZA1ZPRAM	; 1 word (temp1+temp2)
     64  271c9			00 44	    lzsa_srcptr =	LSZA1ZPRAM + 2	; 1 word (temp3+temp4)
     65  271c9			00 46	    lzsa_dstptr =	LSZA1ZPRAM + 4	; 1 word (temp5+temp6)
     66  271c9
     67  271c9							; Doesn't need to be ZP allocations...
     68  271c9			00 48	    LSZA1TEMPRAM =	temp7
     69  271c9			00 48	    lzsa_cmdbuf =	LSZA1TEMPRAM	; 1 byte (temp7)
     70  271c9			00 49	    lzsa_cp_npages =	LSZA1TEMPRAM + 1	; 1 byte (temp8)
     71  271c9			00 4a	    lzsa_lz_npages =	LSZA1TEMPRAM + 2	; 1 byte (temp9)
     72  271c9
     73  271c9							; Alternate names for previous allocations...
     74  271c9			00 42	    lzsa_offset =	lzsa_winptr
     75  271c9			00 44	    LZSA_SRC_LO =	lzsa_srcptr
     76  271c9			00 45	    LZSA_SRC_HI =	lzsa_srcptr+1
     77  271c9			00 46	    LZSA_DST_LO =	lzsa_dstptr
     78  271c9			00 47	    LZSA_DST_HI =	lzsa_dstptr+1
     79  271c9
     80  271c9				   -	       ifconst	lzsa1support
     81  271c9				   -
     82  271c9				   -lzsa1modulestart
     83  271c9				   -
     84  271c9				   -	       if	LZSAFASTCOPYBYTE = 1
     85  271c9				   -.cp_fixpointer
     86  271c9				   -			; the optimised pointer adjustment fails if .cp_byte copied a whole page.
     87  271c9				   -			; so we deal with it as a special case here, out of the regular .cp_byte flow.
     88  271c9				   -			; this only happens rarely.
     89  271c9				   -	       inc	lzsa_srcptr+1	; CC
     90  271c9				   -	       inc	lzsa_dstptr+1
     91  271c9				   -	       bcc	.cp_skip3	; always taken
     92  271c9				   -			; each of these happen infrequently (~1 in 256 byte copies)
     93  271c9				   -.cp_fixsrc1
     94  271c9				   -	       inc	lzsa_srcptr+1
     95  271c9				   -	       clc
     96  271c9				   -	       bcc	.cp_skip1
     97  271c9				   -.cp_fixsrc2
     98  271c9				   -	       inc	lzsa_dstptr+1
     99  271c9				   -	       clc
    100  271c9				   -	       bcc	.cp_skip2
    101  271c9				   -	       endif
    102  271c9				   -
    103  271c9				   -			; ***************************************************************************
    104  271c9				   -			; ***************************************************************************
    105  271c9				   -			;
    106  271c9				   -			; lzsa1_unpack - Decompress data stored in Emmanuel Marty's LZSA1 format.
    107  271c9				   -			;
    108  271c9				   -			; Args: lzsa_srcptr = ptr to compessed data
    109  271c9				   -			; Args: lzsa_dstptr = ptr to output buffer
    110  271c9				   -			;
    111  271c9				   -
    112  271c9				   -
    113  271c9				   -DECOMPRESS_LZSA1_FAST
    114  271c9				   -lzsa1_unpack
    115  271c9				   -	       ldy	#0	; Initialize source index.
    116  271c9				   -	       ldx	#0	; Initialize hi-byte of length.
    117  271c9				   -	       stx	lzsa_cp_npages
    118  271c9				   -	       stx	lzsa_lz_npages
    119  271c9				   -
    120  271c9				   -			;
    121  271c9				   -			; Copy bytes from compressed source data.
    122  271c9				   -			;
    123  271c9				   -			; N.B. X=0 is expected and guaranteed when we get here.
    124  271c9				   -			;
    125  271c9				   -
    126  271c9				   -.cp_length
    127  271c9				   -	       if	LZSA_SMALL_SIZE = 1
    128  271c9				   -
    129  271c9				   -	       jsr	.get_byte
    130  271c9				   -
    131  271c9				   -	       else		; !LZSA_SMALL_SIZE
    132  271c9				   -
    133  271c9				   -	       lda	(lzsa_srcptr),y
    134  271c9				   -	       inc	lzsa_srcptr+0
    135  271c9				   -	       bne	.cp_skip0
    136  271c9				   -	       inc	lzsa_srcptr+1
    137  271c9				   -
    138  271c9				   -	       endif		; !LZSA_SMALL_SIZE
    139  271c9				   -
    140  271c9				   -.cp_skip0
    141  271c9				   -	       sta	lzsa_cmdbuf	; Preserve this for later.
    142  271c9				   -	       and	#$70	; Extract literal length.
    143  271c9				   -	       lsr		; Set CC before ...
    144  271c9				   -	       beq	.lz_offset	; Skip directly to match?
    145  271c9				   -
    146  271c9				   -	       lsr		; Get 3-bit literal length.
    147  271c9				   -	       lsr
    148  271c9				   -	       lsr
    149  271c9				   -	       cmp	#$07	; Extended length?
    150  271c9				   -	       bcc	.cp_got_len
    151  271c9				   -
    152  271c9				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    153  271c9				   -	       stx	lzsa_cp_npages	; Hi-byte of length.
    154  271c9				   -
    155  271c9				   -.cp_got_len
    156  271c9				   -	       tax		; Lo-byte of length.
    157  271c9				   -
    158  271c9				   -	       if	LZSAFASTCOPYBYTE = 0
    159  271c9				   -
    160  271c9				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    161  271c9				   -	       lda	(lzsa_srcptr),y	; 5
    162  271c9				   -	       sta	(lzsa_dstptr),y	; 5
    163  271c9				   -	       inc	lzsa_srcptr+0	; 5
    164  271c9				   -	       bne	.cp_skip1	; 3
    165  271c9				   -	       inc	lzsa_srcptr+1
    166  271c9				   -.cp_skip1
    167  271c9				   -	       inc	lzsa_dstptr+0	; 5
    168  271c9				   -	       bne	.cp_skip2	; 3
    169  271c9				   -	       inc	lzsa_dstptr+1
    170  271c9				   -.cp_skip2
    171  271c9				   -	       dex		; 2
    172  271c9				   -	       bne	.cp_byte	; 3
    173  271c9				   -			;  ~29 cycles overall for X=1
    174  271c9				   -			;  ~58 cycles overall for X=2
    175  271c9				   -			;  ~87 cycles overall for X=3
    176  271c9				   -			; ...
    177  271c9				   -			; ~174 cycles overall for X=6
    178  271c9				   -
    179  271c9				   -	       else		; LZSAFASTCOPYBYTE != 0
    180  271c9				   -
    181  271c9				   -			; according to 7800heat, this loop is hot. It runs on average ~6x.
    182  271c9				   -
    183  271c9				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    184  271c9				   -	       lda	(lzsa_srcptr),y	; 5+
    185  271c9				   -	       sta	(lzsa_dstptr),y	; 5+
    186  271c9				   -	       iny		; 2
    187  271c9				   -	       dex		; 2
    188  271c9				   -	       bne	.cp_byte	; 3/2
    189  271c9				   -			; ~17 cycles each iteration
    190  271c9				   -	       tya		; 2
    191  271c9				   -	       beq	.cp_fixpointer	; 2 unlikely branch - only if we copied a full page
    192  271c9				   -	       adc	lzsa_srcptr+0	; 3
    193  271c9				   -	       sta	lzsa_srcptr+0	; 3
    194  271c9				   -	       bcs	.cp_fixsrc1	; 2 (typical)
    195  271c9				   -.cp_skip1
    196  271c9				   -	       tya		; 2
    197  271c9				   -	       adc	lzsa_dstptr+0	; 3
    198  271c9				   -	       sta	lzsa_dstptr+0	; 3
    199  271c9				   -	       bcs	.cp_fixsrc2	; 2 (typical)
    200  271c9				   -.cp_skip2
    201  271c9				   -	       ldy	#0	; 2
    202  271c9				   -.cp_skip3
    203  271c9				   -			; ~24 cycles overhead, typical
    204  271c9				   -
    205  271c9				   -			; ~41	cycles for X=1 (+12  cycles vs non-optimized)
    206  271c9				   -			; ~58	cycles for X=2 (  0  cycles vs non-optimized)
    207  271c9				   -			; ~75	cycles for X=3 (-12  cycles vs non-optimized)
    208  271c9				   -			; ...
    209  271c9				   -			; ~126 cycles for X=6 (-48  cycles vs non-optimized)
    210  271c9				   -	       endif		; ! LZSAFASTCOPYBYTE = 0
    211  271c9				   -
    212  271c9				   -.cp_npages
    213  271c9				   -	       lda	lzsa_cp_npages	; Any full pages left to copy?
    214  271c9				   -	       beq	.lz_offset
    215  271c9				   -
    216  271c9				   -	       dec	lzsa_cp_npages	; Unlikely, so can be slow.
    217  271c9				   -	       bcc	.cp_byte	; Always true!
    218  271c9				   -
    219  271c9				   -	       if	LZSA_SMALL_SIZE = 1
    220  271c9				   -
    221  271c9				   -			; Copy bytes from decompressed window.
    222  271c9				   -			;
    223  271c9				   -			; Shorter but slower version.
    224  271c9				   -			;
    225  271c9				   -			; N.B. X=0 is expected and guaranteed when we get here.
    226  271c9				   -			;
    227  271c9				   -
    228  271c9				   -.lz_offset
    229  271c9				   -	       jsr	.get_byte	; Get offset-lo.
    230  271c9				   -
    231  271c9				   -.offset_lo
    232  271c9				   -	       adc	lzsa_dstptr+0	; Always CC from .cp_page loop.
    233  271c9				   -	       sta	lzsa_winptr+0
    234  271c9				   -
    235  271c9				   -	       lda	#$FF
    236  271c9				   -	       bit	lzsa_cmdbuf
    237  271c9				   -	       bpl	.offset_hi
    238  271c9				   -
    239  271c9				   -	       jsr	.get_byte	; Get offset-hi.
    240  271c9				   -
    241  271c9				   -.offset_hi
    242  271c9				   -	       adc	lzsa_dstptr+1	; lzsa_winptr < lzsa_dstptr, so
    243  271c9				   -	       sta	lzsa_winptr+1	; always leaves CS.
    244  271c9				   -
    245  271c9				   -.lz_length
    246  271c9				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    247  271c9				   -	       and	#$0F
    248  271c9				   -	       adc	#$03 - 1	; CS from previous ADC.
    249  271c9				   -	       cmp	#$12	; Extended length?
    250  271c9				   -	       bcc	.lz_got_len
    251  271c9				   -
    252  271c9				   -	       jsr	.get_length	; CS from CMP, X=0, returns CC.
    253  271c9				   -	       stx	lzsa_lz_npages	; Hi-byte of length.
    254  271c9				   -
    255  271c9				   -.lz_got_len
    256  271c9				   -	       tax		; Lo-byte of length.
    257  271c9				   -
    258  271c9				   -.lz_byte
    259  271c9				   -	       lda	(lzsa_winptr),y	; CC throughout the execution of
    260  271c9				   -	       sta	(lzsa_dstptr),y	; of this .lz_page loop.
    261  271c9				   -	       inc	lzsa_winptr+0
    262  271c9				   -	       bne	.lz_skip1
    263  271c9				   -	       inc	lzsa_winptr+1
    264  271c9				   -.lz_skip1
    265  271c9				   -	       inc	lzsa_dstptr+0
    266  271c9				   -	       bne	.lz_skip2
    267  271c9				   -	       inc	lzsa_dstptr+1
    268  271c9				   -.lz_skip2
    269  271c9				   -	       dex
    270  271c9				   -	       bne	.lz_byte
    271  271c9				   -.lz_npages
    272  271c9				   -	       lda	lzsa_lz_npages	; Any full pages left to copy?
    273  271c9				   -	       beq	.cp_length
    274  271c9				   -
    275  271c9				   -	       dec	lzsa_lz_npages	; Unlikely, so can be slow.
    276  271c9				   -	       bcc	.lz_byte	; Always true!
    277  271c9				   -
    278  271c9				   -	       else		; !LZSA_SMALL_SIZE
    279  271c9				   -
    280  271c9				   -			;
    281  271c9				   -			; Copy bytes from decompressed window.
    282  271c9				   -			;
    283  271c9				   -			; Longer but faster.
    284  271c9				   -			;
    285  271c9				   -			; N.B. X=0 is expected and guaranteed when we get here.
    286  271c9				   -			;
    287  271c9				   -
    288  271c9				   -.lz_offset
    289  271c9				   -	       lda	(lzsa_srcptr),y	; Get offset-lo.
    290  271c9				   -	       inc	lzsa_srcptr+0
    291  271c9				   -	       bne	.offset_lo
    292  271c9				   -	       inc	lzsa_srcptr+1
    293  271c9				   -
    294  271c9				   -.offset_lo
    295  271c9				   -	       sta	lzsa_offset+0
    296  271c9				   -
    297  271c9				   -	       lda	#$FF	; Get offset-hi.
    298  271c9				   -	       bit	lzsa_cmdbuf
    299  271c9				   -	       bpl	.offset_hi
    300  271c9				   -
    301  271c9				   -	       lda	(lzsa_srcptr),y
    302  271c9				   -	       inc	lzsa_srcptr+0
    303  271c9				   -	       bne	.offset_hi
    304  271c9				   -	       inc	lzsa_srcptr+1
    305  271c9				   -
    306  271c9				   -.offset_hi
    307  271c9				   -	       sta	lzsa_offset+1
    308  271c9				   -
    309  271c9				   -.lz_length
    310  271c9				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    311  271c9				   -	       and	#$0F
    312  271c9				   -	       adc	#$03	; Always CC from .cp_page loop.
    313  271c9				   -	       cmp	#$12	; Extended length?
    314  271c9				   -	       bcc	.got_lz_len
    315  271c9				   -
    316  271c9				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    317  271c9				   -
    318  271c9				   -.got_lz_len
    319  271c9				   -	       inx		; Hi-byte of length+256.
    320  271c9				   -
    321  271c9				   -	       eor	#$FF	; Negate the lo-byte of length
    322  271c9				   -	       tay
    323  271c9				   -	       eor	#$FF
    324  271c9				   -
    325  271c9				   -.get_lz_dst
    326  271c9				   -	       adc	lzsa_dstptr+0	; Calc address of partial page.
    327  271c9				   -	       sta	lzsa_dstptr+0	; Always CC from previous CMP.
    328  271c9				   -	       iny
    329  271c9				   -	       bcs	.get_lz_win
    330  271c9				   -	       beq	.get_lz_win	; Is lo-byte of length zero?
    331  271c9				   -	       dec	lzsa_dstptr+1
    332  271c9				   -
    333  271c9				   -.get_lz_win
    334  271c9				   -	       clc		; Calc address of match.
    335  271c9				   -	       adc	lzsa_offset+0	; N.B. Offset is negative!
    336  271c9				   -	       sta	lzsa_winptr+0
    337  271c9				   -	       lda	lzsa_dstptr+1
    338  271c9				   -	       adc	lzsa_offset+1
    339  271c9				   -	       sta	lzsa_winptr+1
    340  271c9				   -
    341  271c9				   -			; according to 7800heat, this loop is hot. It runs on average ~7.5x.
    342  271c9				   -			; TODO: see if there's a chance to unroll it.
    343  271c9				   -.lz_byte
    344  271c9				   -	       lda	(lzsa_winptr),y
    345  271c9				   -	       sta	(lzsa_dstptr),y
    346  271c9				   -	       iny
    347  271c9				   -	       bne	.lz_byte
    348  271c9				   -
    349  271c9				   -	       inc	lzsa_dstptr+1
    350  271c9				   -	       dex		; Any full pages left to copy?
    351  271c9				   -	       bne	.lz_more
    352  271c9				   -
    353  271c9				   -	       jmp	.cp_length	; Loop around to the beginning.
    354  271c9				   -
    355  271c9				   -.lz_more
    356  271c9				   -	       inc	lzsa_winptr+1	; Unlikely, so can be slow.
    357  271c9				   -	       bne	.lz_byte	; Always true!
    358  271c9				   -
    359  271c9				   -	       endif		; !LZSA_SMALL_SIZE
    360  271c9				   -
    361  271c9				   -			;
    362  271c9				   -			; Get 16-bit length in X:A register pair, return with CC.
    363  271c9				   -			;
    364  271c9				   -			; N.B. X=0 is expected and guaranteed when we get here.
    365  271c9				   -			;
    366  271c9				   -
    367  271c9				   -.get_length
    368  271c9				   -	       clc		; Add on the next byte to get
    369  271c9				   -	       adc	(lzsa_srcptr),y	; the length.
    370  271c9				   -	       inc	lzsa_srcptr+0
    371  271c9				   -	       bne	.skip_inc
    372  271c9				   -	       inc	lzsa_srcptr+1
    373  271c9				   -.skip_inc
    374  271c9				   -
    375  271c9				   -	       bcc	.got_length	; No overflow means done.
    376  271c9				   -	       clc		; MUST return CC!
    377  271c9				   -	       tax		; Preserve overflow value.
    378  271c9				   -
    379  271c9				   -.extra_byte
    380  271c9				   -	       jsr	.get_byte	; So rare, this can be slow!
    381  271c9				   -	       pha
    382  271c9				   -	       txa		; Overflow to 256 or 257?
    383  271c9				   -	       beq	.extra_word
    384  271c9				   -
    385  271c9				   -.check_length
    386  271c9				   -	       pla		; Length-lo.
    387  271c9				   -	       bne	.got_length	; Check for zero.
    388  271c9				   -	       dex		; Do one less page loop if so.
    389  271c9				   -.got_length
    390  271c9				   -	       rts
    391  271c9				   -
    392  271c9				   -.extra_word
    393  271c9				   -	       jsr	.get_byte	; So rare, this can be slow!
    394  271c9				   -	       tax
    395  271c9				   -	       bne	.check_length	; Length-hi == 0 at EOF.
    396  271c9				   -
    397  271c9				   -.finished
    398  271c9				   -	       pla		; Length-lo.
    399  271c9				   -	       pla		; Decompression completed, pop
    400  271c9				   -	       pla		; return address.
    401  271c9				   -	       rts
    402  271c9				   -
    403  271c9				   -.get_byte
    404  271c9				   -	       lda	(lzsa_srcptr),y	; Subroutine version for when
    405  271c9				   -	       inc	lzsa_srcptr+0	; inlining isn't advantageous.
    406  271c9				   -	       bne	.got_byte
    407  271c9				   -	       inc	lzsa_srcptr+1	; Inc & test for bank overflow.
    408  271c9				   -.got_byte
    409  271c9				   -	       rts
    410  271c9				   -
    411  271c9				   -lzsa1moduleend
    412  271c9				   -
    413  271c9				   -	       echo	"  (lzsa1compression module is using ",[(lzsa1moduleend-lzsa1modulestart)]d," bytes of rom)"
    414  271c9				   -
    415  271c9					       endif		; lzsa1support
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\SakuraAbsolNinjaWarrior7800\7800Game.78b.asm
   1886  271c9					       endif
   1887  271c9							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1888  271c9
   1889  271c9							;standard routimes needed for pretty much all games
   1890  271c9
   1891  271c9							; some definitions used with "set debug color"
   1892  271c9			00 91	    DEBUGCALC  =	$91
   1893  271c9			00 41	    DEBUGWASTE =	$41
   1894  271c9			00 c1	    DEBUGDRAW  =	$C1
   1895  271c9
   1896  271c9							;NMI and IRQ handlers
   1897  271c9				    NMI
   1898  271c9							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   1899  271c9			48		       pha		; save A
   1900  271ca			d8		       cld
   1901  271cb			a5 4d		       lda	visibleover
   1902  271cd			49 ff		       eor	#255
   1903  271cf			85 4d		       sta	visibleover
   1904  271d1				   -	       ifconst	DEBUGINTERRUPT
   1905  271d1				   -	       and	#$93
   1906  271d1				   -	       sta	BACKGRND
   1907  271d1					       endif
   1908  271d1			8a		       txa		; save X
   1909  271d2			48		       pha
   1910  271d3			98		       tya		; save Y
   1911  271d4			48		       pha
   1912  271d5			ce b2 01	       dec	interruptindex
   1913  271d8			d0 03		       bne	skipreallyoffvisible
   1914  271da			4c 34 f2	       jmp	reallyoffvisible
   1915  271dd				    skipreallyoffvisible
   1916  271dd			a5 4d		       lda	visibleover
   1917  271df			d0 03		       bne	carryontopscreenroutine
   1918  271e1				   -	       ifconst	.bottomscreenroutine
   1919  271e1				   -	       lda	interrupthold
   1920  271e1				   -	       beq	skipbottomroutine
   1921  271e1				   -	       jsr	.bottomscreenroutine
   1922  271e1				   -skipbottomroutine
   1923  271e1					       endif
   1924  271e1			4c 42 f2	       jmp	NMIexit
   1925  271e4				    carryontopscreenroutine
   1926  271e4				   -	       ifconst	.topscreenroutine
   1927  271e4				   -	       lda	interrupthold
   1928  271e4				   -	       beq	skiptoproutine
   1929  271e4				   -	       jsr	.topscreenroutine
   1930  271e4				   -skiptoproutine
   1931  271e4					       endif
   1932  271e4					       ifnconst	CANARYOFF
   1933  271e4			ad c5 01	       lda	canary
   1934  271e7			f0 07		       beq	skipcanarytriggered
   1935  271e9			a9 45		       lda	#$45
   1936  271eb			85 20		       sta	BACKGRND
   1937  271ed			4c 2c f2	       jmp	skipbrkolorset	; common crash dump routine, if available
   1938  271f0				    skipcanarytriggered
   1939  271f0					       endif
   1940  271f0
   1941  271f0			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   1942  271f3
   1943  271f3							; ** Other important routines that need to regularly run, and can run onscreen.
   1944  271f3							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   1945  271f3
   1946  271f3				   -	       ifconst	LONGCONTROLLERREAD
   1947  271f3				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   1948  271f3				   -	       ldy	port1control
   1949  271f3				   -	       lda	longreadtype,y
   1950  271f3				   -	       beq	LLRET1
   1951  271f3				   -	       tay
   1952  271f3				   -	       lda	longreadroutinehiP1,y
   1953  271f3				   -	       sta	inttemp4
   1954  271f3				   -	       lda	longreadroutineloP1,y
   1955  271f3				   -	       sta	inttemp3
   1956  271f3				   -	       jmp	(inttemp3)
   1957  271f3				   -LLRET1
   1958  271f3				   -	       ldy	port0control
   1959  271f3				   -	       lda	longreadtype,y
   1960  271f3				   -	       beq	LLRET0
   1961  271f3				   -	       tay
   1962  271f3				   -	       lda	longreadroutinehiP0,y
   1963  271f3				   -	       sta	inttemp4
   1964  271f3				   -	       lda	longreadroutineloP0,y
   1965  271f3				   -	       sta	inttemp3
   1966  271f3				   -	       jmp	(inttemp3)
   1967  271f3				   -LLRET0
   1968  271f3				   -
   1969  271f3				   -
   1970  271f3				   -	       ifconst	PADDLERANGE
   1971  271f3				   -TIMEVAL    =	PADDLERANGE
   1972  271f3				   -	       else
   1973  271f3				   -TIMEVAL    =	160
   1974  271f3				   -	       endif
   1975  271f3				   -TIMEOFFSET =	10
   1976  271f3				   -
   1977  271f3					       endif		; LONGCONTROLLERREAD
   1978  271f3
   1979  271f3
   1980  271f3			20 0f f4	       jsr	servicesfxchannels
   1981  271f6				   -	       ifconst	MUSICTRACKER
   1982  271f6				   -	       jsr	servicesong
   1983  271f6					       endif		; MUSICTRACKER
   1984  271f6				   -	       ifconst	RMT
   1985  271f6				   -	       ifnconst	RMTOFFSPEED
   1986  271f6				   -	       ifconst	RMTPALSPEED
   1987  271f6				   -	       lda	ntscslowframe
   1988  271f6				   -	       bne	skiprasterupdate
   1989  271f6				   -	       endif
   1990  271f6				   -	       endif
   1991  271f6				   -	       lda	rasterpause
   1992  271f6				   -	       beq	skiprasterupdate
   1993  271f6				   -	       ifconst	PAUSESILENT
   1994  271f6				   -	       lda	pausestate
   1995  271f6				   -	       bne	skiprasterupdate
   1996  271f6				   -	       endif
   1997  271f6				   -	       jsr	RASTERMUSICTRACKER+3
   1998  271f6				   -skiprasterupdate
   1999  271f6				   -RMT_Iend
   2000  271f6					       endif
   2001  271f6
   2002  271f6			ee a4 01	       inc	framecounter
   2003  271f9			ad a4 01	       lda	framecounter
   2004  271fc			29 3f		       and	#63
   2005  271fe			d0 08		       bne	skipcountdownseconds
   2006  27200			ad a5 01	       lda	countdownseconds
   2007  27203			f0 03		       beq	skipcountdownseconds
   2008  27205			ce a5 01	       dec	countdownseconds
   2009  27208				    skipcountdownseconds
   2010  27208
   2011  27208			a2 01		       ldx	#1
   2012  2720a				    buttonreadloop
   2013  2720a			8a		       txa
   2014  2720b			48		       pha
   2015  2720c			bc b8 01	       ldy	port0control,x
   2016  2720f			b9 eb f3	       lda	buttonhandlerlo,y
   2017  27212			85 da		       sta	inttemp3
   2018  27214			b9 de f3	       lda	buttonhandlerhi,y
   2019  27217			85 db		       sta	inttemp4
   2020  27219			05 da		       ora	inttemp3
   2021  2721b			f0 03		       beq	buttonreadloopreturn
   2022  2721d			6c da 00	       jmp	(inttemp3)
   2023  27220				    buttonreadloopreturn
   2024  27220			68		       pla
   2025  27221			aa		       tax
   2026  27222			ca		       dex
   2027  27223			10 e5		       bpl	buttonreadloop
   2028  27225
   2029  27225				   -	       ifconst	DOUBLEBUFFER
   2030  27225				   -	       lda	doublebufferminimumframeindex
   2031  27225				   -	       beq	skipdoublebufferminimumframeindexadjust
   2032  27225				   -	       dec	doublebufferminimumframeindex
   2033  27225				   -skipdoublebufferminimumframeindexadjust
   2034  27225					       endif
   2035  27225
   2036  27225			4c 42 f2	       jmp	NMIexit
   2037  27228
   2038  27228				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   2039  27228					       ifnconst	BREAKPROTECTOFF
   2040  27228			a9 1a		       lda	#$1A
   2041  2722a			85 20		       sta	BACKGRND
   2042  2722c				    skipbrkolorset
   2043  2722c				    skipbrkdetected
   2044  2722c			a9 60		       lda	#$60
   2045  2722e			8d 07 21	       sta	sCTRL
   2046  27231			85 3c		       sta	CTRL
   2047  27233					       ifnconst	hiscorefont
   2048  27233			02		       .byte.b	$02	; KIL/JAM
   2049  27234				   -	       else		; hiscorefont is present
   2050  27234				   -	       ifconst	CRASHDUMP
   2051  27234				   -	       bit	MSTAT
   2052  27234				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   2053  27234				   -
   2054  27234				   -	       ifconst	dumpbankswitch
   2055  27234				   -	       lda	dumpbankswitch
   2056  27234				   -	       pha
   2057  27234				   -	       endif
   2058  27234				   -
   2059  27234				   -			; bankswitch if needed, to get to the hiscore font
   2060  27234				   -	       ifconst	bankswitchmode
   2061  27234				   -	       ifconst	included.hiscore.asm.bank
   2062  27234				   -	       ifconst	MCPDEVCART
   2063  27234				   -	       lda	#($18 | included.hiscore.asm.bank)
   2064  27234				   -	       sta	$3000
   2065  27234				   -	       else
   2066  27234				   -	       lda	#(included.hiscore.asm.bank)
   2067  27234				   -	       sta	$8000
   2068  27234				   -	       endif
   2069  27234				   -	       endif		; included.hiscore.asm.bank
   2070  27234				   -	       endif		; bankswitchmode
   2071  27234				   -
   2072  27234				   -	       ifconst	DOUBLEBUFFER
   2073  27234				   -			;turn off double-buffering, if on...
   2074  27234				   -	       lda	#>DLLMEM
   2075  27234				   -	       sta	DPPH
   2076  27234				   -	       lda	#<DLLMEM
   2077  27234				   -	       sta	DPPL
   2078  27234				   -	       endif
   2079  27234				   -
   2080  27234				   -	       lda	#$00
   2081  27234				   -	       sta	P0C2
   2082  27234				   -
   2083  27234				   -			;update the second-from-top DL...
   2084  27234				   -	       ldy	#8
   2085  27234				   -NMIupdatetopDL
   2086  27234				   -	       lda	show2700,y
   2087  27234				   -	       sta	ZONE1ADDRESS,y
   2088  27234				   -	       dey
   2089  27234				   -	       bpl	NMIupdatetopDL
   2090  27234				   -
   2091  27234				   -			; the hiscore font is present, so we try to output the stack
   2092  27234				   -	       ldy	#0
   2093  27234				   -copystackloop
   2094  27234				   -	       pla
   2095  27234				   -	       pha
   2096  27234				   -	       lsr
   2097  27234				   -	       lsr
   2098  27234				   -	       lsr
   2099  27234				   -	       lsr
   2100  27234				   -	       tax
   2101  27234				   -	       lda	hiscorehexlut,x
   2102  27234				   -	       sta	$2700,y
   2103  27234				   -	       iny
   2104  27234				   -
   2105  27234				   -	       pla
   2106  27234				   -	       and	#$0F
   2107  27234				   -	       tax
   2108  27234				   -	       lda	hiscorehexlut,x
   2109  27234				   -	       sta	$2700,y
   2110  27234				   -	       iny
   2111  27234				   -
   2112  27234				   -	       lda	#27	; period
   2113  27234				   -	       sta	$2700,y
   2114  27234				   -	       iny
   2115  27234				   -
   2116  27234				   -	       cpy	#30
   2117  27234				   -	       bne	copystackloop
   2118  27234				   -
   2119  27234				   -	       lda	#>hiscorefont
   2120  27234				   -	       sta	CHARBASE
   2121  27234				   -	       sta	sCHARBASE
   2122  27234				   -	       lda	#%01000011	;Enable DMA, mode=320A
   2123  27234				   -	       sta	CTRL
   2124  27234				   -	       sta	sCTRL
   2125  27234				   -	       .byte	$02	; KIL/JAM
   2126  27234				   -hiscorehexlut
   2127  27234				   -			; 0 1 2 3 4 5 6 7 8 9 A B C D E F
   2128  27234				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   2129  27234				   -show2700
   2130  27234				   -			; lo mode hi width=29 x EODL
   2131  27234				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   2132  27234				   -	       else		; CRASHDUMP
   2133  27234				   -	       .byte	$02	; KIL/JAM
   2134  27234				   -	       endif		; crashdump
   2135  27234					       endif		; hiscorefont
   2136  27234				   -	       else
   2137  27234				   -	       RTI
   2138  27234					       endif
   2139  27234
   2140  27234				   -	       ifconst	LONGCONTROLLERREAD
   2141  27234				   -
   2142  27234				   -longreadtype
   2143  27234				   -	       .byte	0, 0, 0, 1	; NONE PROLINE LIGHTGUN PADDLE
   2144  27234				   -	       .byte	2, 0, 3, 0	; TRKBALL VCSSTICK DRIVING KEYPAD
   2145  27234				   -	       .byte	3, 3, 0, 0	; STMOUSE AMOUSE ATARIVOX SNES
   2146  27234				   -
   2147  27234				   -longreadroutineloP0
   2148  27234				   -	       .byte	<LLRET0	; 0 = no routine
   2149  27234				   -	       .byte	<paddleport0update	; 1 = paddle
   2150  27234				   -	       .byte	<trakball0update	; 2 = trakball
   2151  27234				   -	       .byte	<mouse0update	; 3 = mouse
   2152  27234				   -
   2153  27234				   -longreadroutinehiP0
   2154  27234				   -	       .byte	>LLRET0	; 0 = no routine
   2155  27234				   -	       .byte	>paddleport0update	; 1 = paddle
   2156  27234				   -	       .byte	>trakball0update	; 2 = trackball
   2157  27234				   -	       .byte	>mouse0update	; 3 = mouse
   2158  27234				   -
   2159  27234				   -longreadroutineloP1
   2160  27234				   -	       .byte	<LLRET1	; 0 = no routine
   2161  27234				   -	       .byte	<paddleport1update	; 1 = paddle
   2162  27234				   -	       .byte	<trakball1update	; 2 = trakball
   2163  27234				   -	       .byte	<mouse1update	; 3 = mouse
   2164  27234				   -
   2165  27234				   -longreadroutinehiP1
   2166  27234				   -	       .byte	>LLRET1	; 0 = no routine
   2167  27234				   -	       .byte	>paddleport1update	; 1 = paddle
   2168  27234				   -	       .byte	>trakball1update	; 2 = trackball
   2169  27234				   -	       .byte	>mouse1update	; 3 = mouse
   2170  27234				   -
   2171  27234				   -
   2172  27234				   -SETTIM64T
   2173  27234				   -	       bne	skipdefaulttime
   2174  27234				   -	       ifnconst	PADDLESMOOTHINGOFF
   2175  27234				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   2176  27234				   -	       else
   2177  27234				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   2178  27234				   -	       endif
   2179  27234				   -skipdefaulttime
   2180  27234				   -	       tay
   2181  27234				   -	       dey
   2182  27234				   -.setTIM64Tloop
   2183  27234				   -	       sta	TIM64T
   2184  27234				   -	       cpy	INTIM
   2185  27234				   -	       bne	.setTIM64Tloop
   2186  27234				   -	       rts
   2187  27234					       endif		; LONGCONTROLLERREAD
   2188  27234
   2189  27234				    reallyoffvisible
   2190  27234			85 24		       sta	WSYNC
   2191  27236
   2192  27236			a9 00		       lda	#0
   2193  27238			85 4d		       sta	visibleover
   2194  2723a				   -	       ifconst	DEBUGINTERRUPT
   2195  2723a				   -	       sta	BACKGRND
   2196  2723a					       endif
   2197  2723a
   2198  2723a			a9 03		       lda	#3
   2199  2723c			8d b2 01	       sta	interruptindex
   2200  2723f
   2201  2723f			20 14 f3	       jsr	uninterruptableroutines
   2202  27242
   2203  27242				   -	       ifconst	.userinterrupt
   2204  27242				   -	       lda	interrupthold
   2205  27242				   -	       beq	skipuserintroutine
   2206  27242				   -	       jsr	.userinterrupt
   2207  27242				   -skipuserintroutine
   2208  27242					       endif
   2209  27242
   2210  27242				   -	       ifconst	KEYPADSUPPORT
   2211  27242				   -	       jsr	keypadcolumnread
   2212  27242				   -	       jsr	keypadrowselect
   2213  27242					       endif
   2214  27242
   2215  27242				    NMIexit
   2216  27242			68		       pla
   2217  27243			a8		       tay
   2218  27244			68		       pla
   2219  27245			aa		       tax
   2220  27246			68		       pla
   2221  27247			40		       RTI
   2222  27248
   2223  27248				    clearscreen
   2224  27248			a2 0b		       ldx	#(WZONECOUNT-1)
   2225  2724a			a9 00		       lda	#0
   2226  2724c				    clearscreenloop
   2227  2724c			95 65		       sta	dlend,x
   2228  2724e			ca		       dex
   2229  2724f			10 fb		       bpl	clearscreenloop
   2230  27251			a9 00		       lda	#0
   2231  27253			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   2232  27256			8d ae 01	       sta	valbufendsave
   2233  27259			60		       rts
   2234  2725a
   2235  2725a				    restorescreen
   2236  2725a			a2 0b		       ldx	#(WZONECOUNT-1)
   2237  2725c			a9 00		       lda	#0
   2238  2725e				    restorescreenloop
   2239  2725e			b5 82		       lda	dlendsave,x
   2240  27260			95 65		       sta	dlend,x
   2241  27262			ca		       dex
   2242  27263			10 f9		       bpl	restorescreenloop
   2243  27265			ad ae 01	       lda	valbufendsave
   2244  27268			8d ad 01	       sta	valbufend
   2245  2726b			60		       rts
   2246  2726c
   2247  2726c				    savescreen
   2248  2726c			a2 0b		       ldx	#(WZONECOUNT-1)
   2249  2726e				    savescreenloop
   2250  2726e			b5 65		       lda	dlend,x
   2251  27270			95 82		       sta	dlendsave,x
   2252  27272			ca		       dex
   2253  27273			10 f9		       bpl	savescreenloop
   2254  27275			ad ad 01	       lda	valbufend
   2255  27278			8d ae 01	       sta	valbufendsave
   2256  2727b				   -	       ifconst	DOUBLEBUFFER
   2257  2727b				   -	       lda	doublebufferstate
   2258  2727b				   -	       beq	savescreenrts
   2259  2727b				   -	       lda	#1
   2260  2727b				   -	       sta	doublebufferbufferdirty
   2261  2727b				   -savescreenrts
   2262  2727b					       endif		; DOUBLEBUFFER
   2263  2727b			60		       rts
   2264  2727c
   2265  2727c				    drawscreen
   2266  2727c
   2267  2727c				   -	       ifconst	interrupthold
   2268  2727c				   -	       lda	#$FF
   2269  2727c				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   2270  2727c					       endif
   2271  2727c
   2272  2727c			a9 00		       lda	#0
   2273  2727e			85 42		       sta	temp1	; not B&W if we're here...
   2274  27280
   2275  27280				    drawscreenwait
   2276  27280			a5 4d		       lda	visibleover
   2277  27282			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2278  27284
   2279  27284							;restore some registers in case the game changed them mid-screen...
   2280  27284			ad 07 21	       lda	sCTRL
   2281  27287			05 42		       ora	temp1
   2282  27289			85 3c		       sta	CTRL
   2283  2728b			ad 0b 21	       lda	sCHARBASE
   2284  2728e			85 34		       sta	CHARBASE
   2285  27290
   2286  27290							;ensure all of the display list is terminated...
   2287  27290			20 fa f2	       jsr	terminatedisplaylist
   2288  27293
   2289  27293					       ifnconst	pauseroutineoff
   2290  27293			20 9e f2	       jsr	pauseroutine
   2291  27296					       endif		; pauseroutineoff
   2292  27296
   2293  27296							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2294  27296							; delaying a full frame, but still allowing time for basic calculations.
   2295  27296				    visiblescreenstartedwait
   2296  27296			a5 4d		       lda	visibleover
   2297  27298			f0 fc		       beq	visiblescreenstartedwait
   2298  2729a				    visiblescreenstartedwaitdone
   2299  2729a			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2300  2729d			60		       rts
   2301  2729e
   2302  2729e					       ifnconst	pauseroutineoff
   2303  2729e							; check to see if pause was pressed and released
   2304  2729e				    pauseroutine
   2305  2729e			ad b3 01	       lda	pausedisable
   2306  272a1			d0 47		       bne	leavepauseroutine
   2307  272a3			a9 08		       lda	#8
   2308  272a5			2c 82 02	       bit	SWCHB
   2309  272a8			f0 22		       beq	pausepressed
   2310  272aa
   2311  272aa				   -	       ifconst	SNES0PAUSE
   2312  272aa				   -	       lda	port0control
   2313  272aa				   -	       cmp	#11
   2314  272aa				   -	       bne	skipsnes0pause
   2315  272aa				   -	       lda	snesdetected0
   2316  272aa				   -	       beq	skipsnes0pause
   2317  272aa				   -	       lda	snes2atari0hi
   2318  272aa				   -	       and	#%00010000
   2319  272aa				   -	       beq	pausepressed
   2320  272aa				   -skipsnes0pause
   2321  272aa					       endif
   2322  272aa				   -	       ifconst	SNES1PAUSE
   2323  272aa				   -
   2324  272aa				   -	       lda	port1control
   2325  272aa				   -	       cmp	#11
   2326  272aa				   -	       bne	skipsnes1pause
   2327  272aa				   -	       lda	snesdetected1
   2328  272aa				   -	       beq	skipsnes1pause
   2329  272aa				   -	       lda	snes2atari1hi
   2330  272aa				   -	       and	#%00010000
   2331  272aa				   -	       beq	pausepressed
   2332  272aa				   -skipsnes1pause
   2333  272aa					       endif
   2334  272aa				   -	       ifconst	SNESNPAUSE
   2335  272aa				   -	       ldx	snesport
   2336  272aa				   -	       lda	port0control,x
   2337  272aa				   -	       cmp	#11
   2338  272aa				   -	       bne	skipsnesNpause
   2339  272aa				   -	       lda	snesdetected0,x
   2340  272aa				   -	       beq	skipsnesNpause
   2341  272aa				   -	       lda	snes2atari0hi,x
   2342  272aa				   -	       and	#%00010000
   2343  272aa				   -	       beq	pausepressed
   2344  272aa				   -skipsnesNpause
   2345  272aa					       endif
   2346  272aa				   -	       ifconst	MULTIBUTTONPAUSE
   2347  272aa				   -	       ldx	#1
   2348  272aa				   -multibuttonpauseloop
   2349  272aa				   -	       lda	port0control,x
   2350  272aa				   -	       cmp	#11
   2351  272aa				   -	       bcc	multibuttonpauseloopbottom
   2352  272aa				   -	       lda	sINPT1,x
   2353  272aa				   -	       and	#1
   2354  272aa				   -	       beq	pausepressed
   2355  272aa				   -multibuttonpauseloopbottom
   2356  272aa				   -	       dex
   2357  272aa				   -	       bpl	multibuttonpauseloop
   2358  272aa					       endif		; MULTIBUTTONPAUSE
   2359  272aa
   2360  272aa							;pause isn't pressed
   2361  272aa			a9 00		       lda	#0
   2362  272ac			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2363  272af
   2364  272af							;check if we're in an already paused state
   2365  272af			ad 00 21	       lda	pausestate
   2366  272b2			f0 36		       beq	leavepauseroutine	; nope, leave
   2367  272b4
   2368  272b4			c9 01		       cmp	#1	; last frame was the start of pausing
   2369  272b6			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   2370  272b8
   2371  272b8			c9 02		       cmp	#2
   2372  272ba			f0 34		       beq	carryonpausing
   2373  272bc
   2374  272bc							;pausestate must be >2, which means we're ending an unpause 
   2375  272bc			a9 00		       lda	#0
   2376  272be			8d ac 01	       sta	pausebuttonflag
   2377  272c1			8d 00 21	       sta	pausestate
   2378  272c4			ad 07 21	       lda	sCTRL
   2379  272c7			85 3c		       sta	CTRL
   2380  272c9			4c ea f2	       jmp	leavepauseroutine
   2381  272cc
   2382  272cc				    pausepressed
   2383  272cc							;pause is pressed
   2384  272cc			ad ac 01	       lda	pausebuttonflag
   2385  272cf			c9 ff		       cmp	#$ff
   2386  272d1			f0 1d		       beq	carryonpausing
   2387  272d3
   2388  272d3							;its a new press, increment the state
   2389  272d3			ee 00 21	       inc	pausestate
   2390  272d6
   2391  272d6							;silence volume at the start and end of pausing
   2392  272d6			a9 00		       lda	#0
   2393  272d8			85 19		       sta	AUDV0
   2394  272da			85 1a		       sta	AUDV1
   2395  272dc
   2396  272dc				   -	       ifconst	pokeysupport
   2397  272dc				   -	       ldy	#7
   2398  272dc				   -pausesilencepokeyaudioloop
   2399  272dc				   -	       sta	(pokeybase),y
   2400  272dc				   -	       dey
   2401  272dc				   -	       bpl	pausesilencepokeyaudioloop
   2402  272dc					       endif		; pokeysupport
   2403  272dc
   2404  272dc			a9 ff		       lda	#$ff
   2405  272de			8d ac 01	       sta	pausebuttonflag
   2406  272e1			d0 0d		       bne	carryonpausing
   2407  272e3
   2408  272e3				    enterpausestate2
   2409  272e3			a9 02		       lda	#2
   2410  272e5			8d 00 21	       sta	pausestate
   2411  272e8			d0 06		       bne	carryonpausing
   2412  272ea				    leavepauseroutine
   2413  272ea			ad 07 21	       lda	sCTRL
   2414  272ed			85 3c		       sta	CTRL
   2415  272ef			60		       rts
   2416  272f0				    carryonpausing
   2417  272f0				   -	       ifconst	.pause
   2418  272f0				   -	       jsr	.pause
   2419  272f0					       endif		; .pause
   2420  272f0			ad 07 21	       lda	sCTRL
   2421  272f3			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2422  272f5			85 3c		       sta	CTRL
   2423  272f7			4c 9e f2	       jmp	pauseroutine
   2424  272fa					       endif		; pauseroutineoff
   2425  272fa
   2426  272fa
   2427  272fa				   -	       ifconst	DOUBLEBUFFER
   2428  272fa				   -skipterminatedisplaylistreturn
   2429  272fa				   -	       rts
   2430  272fa					       endif		; DOUBLEBUFFER
   2431  272fa				    terminatedisplaylist
   2432  272fa				   -	       ifconst	DOUBLEBUFFER
   2433  272fa				   -	       lda	doublebufferstate
   2434  272fa				   -	       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2435  272fa					       endif		; DOUBLEBUFFER
   2436  272fa				    terminatedisplaybuffer
   2437  272fa							;add DL end entry on each DL
   2438  272fa			a2 0b		       ldx	#(WZONECOUNT-1)
   2439  272fc				    dlendloop
   2440  272fc				   -	       ifconst	VSCROLL
   2441  272fc				   -	       ldy	Xx3,x
   2442  272fc				   -	       lda	DLLMEM+11,y
   2443  272fc					       else		; !VSCROLL
   2444  272fc			bd 5e f7	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2445  272ff					       endif		; !VSCROLL
   2446  272ff				   -	       ifconst	DOUBLEBUFFER
   2447  272ff				   -	       clc
   2448  272ff				   -	       adc	doublebufferdloffset
   2449  272ff					       endif		; DOUBLEBUFFER
   2450  272ff			85 63		       sta	dlpnt
   2451  27301				   -	       ifconst	VSCROLL
   2452  27301				   -	       lda	DLLMEM+10,y
   2453  27301					       else		; !VSCROLL
   2454  27301			bd 52 f7	       lda	DLPOINTH,x
   2455  27304					       endif		; !VSCROLL
   2456  27304				   -	       ifconst	DOUBLEBUFFER
   2457  27304				   -	       adc	#0
   2458  27304					       endif		; DOUBLEBUFFER
   2459  27304			85 64		       sta	dlpnt+1
   2460  27306			b4 65		       ldy	dlend,x
   2461  27308			a9 00		       lda	#$00
   2462  2730a				    dlendmoreloops
   2463  2730a			c8		       iny
   2464  2730b			91 63		       sta	(dlpnt),y
   2465  2730d				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2466  2730d				   -	       cpy	#DLLASTOBJ+1
   2467  2730d				   -	       beq	dlendthiszonedone
   2468  2730d				   -	       iny
   2469  2730d				   -	       iny
   2470  2730d				   -	       iny
   2471  2730d				   -	       iny
   2472  2730d				   -	       iny
   2473  2730d				   -	       sta	(dlpnt),y
   2474  2730d				   -dlendthiszonedone
   2475  2730d					       endif	FRAMESKIPGLITCHFIXWEAK
   2476  2730d				   -	       ifconst	FRAMESKIPGLITCHFIX
   2477  2730d				   -	       iny
   2478  2730d				   -	       iny
   2479  2730d				   -	       iny
   2480  2730d				   -	       iny
   2481  2730d				   -	       cpy	#DLLASTOBJ-1
   2482  2730d				   -	       bcc	dlendmoreloops
   2483  2730d					       endif		; FRAMESKIPGLITCHFIX
   2484  2730d			ca		       dex
   2485  2730e			10 ec		       bpl	dlendloop
   2486  27310
   2487  27310					       ifnconst	pauseroutineoff
   2488  27310			20 9e f2	       jsr	pauseroutine
   2489  27313					       endif		; pauseroutineoff
   2490  27313			60		       rts
   2491  27314
   2492  27314				    uninterruptableroutines
   2493  27314							; this is for routines that must happen off the visible screen, each frame.
   2494  27314
   2495  27314				   -	       ifconst	AVOXVOICE
   2496  27314				   -	       jsr	serviceatarivoxqueue
   2497  27314					       endif
   2498  27314					       ifconst	MEGA7800SUPPORT
   2499  27314			a2 01		       ldx	#1
   2500  27316				    mega7800polling
   2501  27316			bd b8 01	       lda	port0control,x
   2502  27319			c9 0c		       cmp	#12	; mega7800
   2503  2731b			d0 06		       bne	mega7800handlercheck2
   2504  2731d			20 11 f1	       jsr	mega7800handler
   2505  27320			4c 38 f3	       jmp	mega7800handlerdone
   2506  27323				    mega7800handlercheck2
   2507  27323					       ifconst	MULTIBUTTON
   2508  27323			c9 01		       cmp	#1	; proline
   2509  27325			d0 11		       bne	mega7800handlerdone
   2510  27327			ad a4 01	       lda	framecounter
   2511  2732a			49 07		       eor	#7	; avoid the same frame as the snes2atari probe
   2512  2732c			29 3f		       and	#63
   2513  2732e			d0 08		       bne	mega7800handlerdone
   2514  27330			a9 0c		       lda	#12
   2515  27332			9d b8 01	       sta	port0control,x
   2516  27335			20 11 f1	       jsr	mega7800handler
   2517  27338					       endif		; MULTIBUTTON
   2518  27338				    mega7800handlerdone
   2519  27338			ca		       dex
   2520  27339			10 db		       bpl	mega7800polling
   2521  2733b					       endif		; MEGA7800SUPPORT
   2522  2733b
   2523  2733b			a9 00		       lda	#0
   2524  2733d			8d b7 01	       sta	palfastframe
   2525  27340			8d b6 01	       sta	ntscslowframe
   2526  27343			ae 09 21	       ldx	paldetected	; 0=ntsc 1=pal
   2527  27346			ac b5 01	       ldy	palframes
   2528  27349			c8		       iny
   2529  2734a			c0 05		       cpy	#5
   2530  2734c			d0 08		       bne	palframeskipdone
   2531  2734e			ad 09 21	       lda	paldetected
   2532  27351			fe b6 01	       inc	ntscslowframe,x
   2533  27354			a0 00		       ldy	#0
   2534  27356				    palframeskipdone
   2535  27356			8c b5 01	       sty	palframes
   2536  27359				    skippalframeadjusting
   2537  27359
   2538  27359				   -	       ifconst	MUSICTRACKER
   2539  27359				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2540  27359				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2541  27359				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   2542  27359				   -			; problem twice, and if we do, we just drop a musical note or two.
   2543  27359				   -	       lda	sfxschedulemissed
   2544  27359				   -	       beq	servicesongwasnotmissed
   2545  27359				   -	       jsr	servicesong
   2546  27359				   -servicesongwasnotmissed
   2547  27359					       endif		; MUSICTRACKER
   2548  27359
   2549  27359				   -	       ifconst	RMT
   2550  27359				   -	       ifnconst	RMTPALSPEED
   2551  27359				   -	       ifnconst	RMTOFFSPEED
   2552  27359				   -	       ifconst	PAUSESILENT
   2553  27359				   -	       lda	pausestate
   2554  27359				   -	       bne	skiprasterupdate2
   2555  27359				   -	       endif
   2556  27359				   -	       lda	palfastframe
   2557  27359				   -	       beq	skiprasterupdate2
   2558  27359				   -	       lda	rasterpause
   2559  27359				   -	       beq	skiprasterupdate2
   2560  27359				   -	       jsr	RASTERMUSICTRACKER+3
   2561  27359				   -skiprasterupdate2
   2562  27359				   -	       endif
   2563  27359				   -	       endif
   2564  27359					       endif
   2565  27359
   2566  27359			60		       rts
   2567  2735a
   2568  2735a				    serviceatarivoxqueue
   2569  2735a				   -	       ifconst	AVOXVOICE
   2570  2735a				   -	       lda	voxlock
   2571  2735a				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2572  2735a				   -skipvoxqueuesizedec
   2573  2735a				   -	       jmp	processavoxvoice
   2574  2735a				   -skipvoxprocessing
   2575  2735a				   -	       rts
   2576  2735a				   -
   2577  2735a				   -processavoxvoice
   2578  2735a				   -	       ifconst	HSSUPPORT
   2579  2735a				   -			; ** we skip speech if hi-score is on and no vox was detected
   2580  2735a				   -			; ** this is to avoid later collision with snes pads.
   2581  2735a				   -	       lda	hsdevice
   2582  2735a				   -	       and	#2
   2583  2735a				   -	       beq	processavoxvoicereturn
   2584  2735a				   -	       endif		; HSSUPPORT
   2585  2735a				   -	       lda	avoxenable
   2586  2735a				   -	       bne	avoxfixport
   2587  2735a				   -	       SPKOUT	tempavox
   2588  2735a				   -	       rts
   2589  2735a				   -avoxfixport
   2590  2735a				   -	       lda	#0	; restore the port to all bits as inputs...
   2591  2735a				   -	       sta	CTLSWA
   2592  2735a				   -	       rts
   2593  2735a				   -silenceavoxvoice
   2594  2735a				   -	       SPEAK	avoxsilentdata
   2595  2735a				   -processavoxvoicereturn
   2596  2735a				   -	       rts
   2597  2735a				   -avoxsilentdata
   2598  2735a				   -	       .byte	31,255
   2599  2735a					       else
   2600  2735a			60		       rts
   2601  2735b					       endif		; AVOXVOICE
   2602  2735b
   2603  2735b				    prolinebuttonpadhandler
   2604  2735b					       ifconst	MULTIBUTTON
   2605  2735b			ad a4 01	       lda	framecounter
   2606  2735e			29 3f		       and	#63
   2607  27360			d0 15		       bne	jbhandlercont1
   2608  27362			20 a6 f6	       jsr	setonebuttonmode
   2609  27365			a9 0b		       lda	#11
   2610  27367			9d b8 01	       sta	port0control,x
   2611  2736a			20 1b f0	       jsr	snes2atari_signal_go
   2612  2736d			bd b8 01	       lda	port0control,x
   2613  27370			c9 01		       cmp	#1	; check if it's still a proline 
   2614  27372			f0 03		       beq	jbhandlercont1
   2615  27374			4c 20 f2	       jmp	buttonreadloopreturn
   2616  27377				    jbhandlercont1
   2617  27377			a9 02		       lda	#2
   2618  27379			9d c3 01	       sta	multibuttoncount0,x
   2619  2737c					       endif		; MULTIBUTTON
   2620  2737c				    joybuttonpadhandler
   2621  2737c			ad 31 21	       lda	sSWCHA	; clear previous dirs for this pad, from
   2622  2737f			1d ce f3	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
   2623  27382			8d 31 21	       sta	sSWCHA
   2624  27385			ad 80 02	       lda	SWCHA	; load th actual joystick dirs, ensuring
   2625  27388			1d cf f3	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
   2626  2738b			2d 31 21	       and	sSWCHA
   2627  2738e			8d 31 21	       sta	sSWCHA
   2628  27391				    joybuttonhandler
   2629  27391			8a		       txa
   2630  27392			0a		       asl
   2631  27393			a8		       tay
   2632  27394			b9 08 00	       lda	INPT0,y
   2633  27397			4a		       lsr
   2634  27398							;ora #%00111111
   2635  27398			9d 02 21	       sta	sINPT1,x
   2636  2739b			b9 09 00	       lda	INPT1,y
   2637  2739e			29 80		       and	#%10000000
   2638  273a0			1d 02 21	       ora	sINPT1,x
   2639  273a3			9d 02 21	       sta	sINPT1,x
   2640  273a6
   2641  273a6			b5 0c		       lda	INPT4,x
   2642  273a8			30 19		       bmi	.skip1bjoyfirecheck
   2643  273aa							;one button joystick is down
   2644  273aa			49 80		       eor	#%10000000
   2645  273ac			9d 02 21	       sta	sINPT1,x
   2646  273af
   2647  273af			ad b1 01	       lda	joybuttonmode
   2648  273b2			3d cc f6	       and	thisjoy2buttonbit,x
   2649  273b5			f0 0c		       beq	.skip1bjoyfirecheck
   2650  273b7			ad b1 01	       lda	joybuttonmode
   2651  273ba			1d cc f6	       ora	thisjoy2buttonbit,x
   2652  273bd			8d b1 01	       sta	joybuttonmode
   2653  273c0			8d 82 02	       sta	SWCHB
   2654  273c3				    .skip1bjoyfirecheck
   2655  273c3			a9 3f		       lda	#%00111111
   2656  273c5			1d 02 21	       ora	sINPT1,x
   2657  273c8			9d 02 21	       sta	sINPT1,x	; ensure multibutton bits are hi
   2658  273cb			4c 20 f2	       jmp	buttonreadloopreturn
   2659  273ce
   2660  273ce				    SWCHA_DIRMASK
   2661  273ce							;  p0	p1  p0
   2662  273ce			f0 0f f0	       .byte.b	$F0,$0F,$F0
   2663  273d1
   2664  273d1				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2665  273d1				   -	       ifconst	LIGHTGUNSUPPORT
   2666  273d1				   -	       cpx	#0
   2667  273d1				   -	       bne	secondportgunhandler
   2668  273d1				   -firstportgunhandler
   2669  273d1				   -	       lda	SWCHA
   2670  273d1				   -	       asl
   2671  273d1				   -	       asl
   2672  273d1				   -	       asl		; shift D4 to D7
   2673  273d1				   -	       and	#%10000000
   2674  273d1				   -	       eor	#%10000000
   2675  273d1				   -	       sta	sINPT1
   2676  273d1				   -	       jmp	buttonreadloopreturn
   2677  273d1				   -secondportgunhandler
   2678  273d1				   -	       lda	SWCHA
   2679  273d1				   -	       lsr		; shift D0 into carry
   2680  273d1				   -	       lsr		; shift carry into D7
   2681  273d1				   -	       and	#%10000000
   2682  273d1				   -	       eor	#%10000000
   2683  273d1				   -	       sta	sINPT3
   2684  273d1				   -	       jmp	buttonreadloopreturn
   2685  273d1					       endif		; LIGHTGUNSUPPORT
   2686  273d1
   2687  273d1				    controlsusing2buttoncode
   2688  273d1			00		       .byte.b	0	; 00=no controller plugged in
   2689  273d2			01		       .byte.b	1	; 01=proline joystick
   2690  273d3			00		       .byte.b	0	; 02=lightgun
   2691  273d4			00		       .byte.b	0	; 03=paddle
   2692  273d5			01		       .byte.b	1	; 04=trakball
   2693  273d6			01		       .byte.b	1	; 05=vcs joystick
   2694  273d7			01		       .byte.b	1	; 06=driving control
   2695  273d8			00		       .byte.b	0	; 07=keypad control
   2696  273d9			00		       .byte.b	0	; 08=st mouse/cx80
   2697  273da			00		       .byte.b	0	; 09=amiga mouse
   2698  273db			01		       .byte.b	1	; 10=atarivox
   2699  273dc			00		       .byte.b	0	; 11=snes2atari
   2700  273dd			00		       .byte.b	0	; 12=mega7800
   2701  273de
   2702  273de				    buttonhandlerhi
   2703  273de			00		       .byte.b	0	; 00=no controller plugged in
   2704  273df			f3		       .byte.b	>prolinebuttonpadhandler	; 01=proline joystick
   2705  273e0			f3		       .byte.b	>gunbuttonhandler	; 02=lightgun
   2706  273e1			f6		       .byte.b	>paddlebuttonhandler	; 03=paddle
   2707  273e2			f3		       .byte.b	>joybuttonhandler	; 04=trakball
   2708  273e3			f3		       .byte.b	>joybuttonpadhandler	; 05=vcs joystick
   2709  273e4			f3		       .byte.b	>joybuttonhandler	; 06=driving control
   2710  273e5			00		       .byte.b	0	; 07=keypad
   2711  273e6			f6		       .byte.b	>mousebuttonhandler	; 08=st mouse
   2712  273e7			f6		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2713  273e8			f3		       .byte.b	>joybuttonhandler	; 10=atarivox
   2714  273e9			f0		       .byte.b	>snes2atarihandler	; 11=snes
   2715  273ea			00		       .byte.b	0	; 12=mega7800
   2716  273eb				    buttonhandlerlo
   2717  273eb			00		       .byte.b	0	; 00=no controller plugged in
   2718  273ec			5b		       .byte.b	<prolinebuttonpadhandler	; 01=proline joystick
   2719  273ed			d1		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   2720  273ee			9c		       .byte.b	<paddlebuttonhandler	; 03=paddle
   2721  273ef			91		       .byte.b	<joybuttonhandler	; 04=trakball
   2722  273f0			7c		       .byte.b	<joybuttonpadhandler	; 05=vcs joystick
   2723  273f1			91		       .byte.b	<joybuttonhandler	; 06=driving control
   2724  273f2			00		       .byte.b	0	; 07=keypad
   2725  273f3			9c		       .byte.b	<mousebuttonhandler	; 08=st mouse
   2726  273f4			9c		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2727  273f5			91		       .byte.b	<joybuttonhandler	; 10=atarivox
   2728  273f6			09		       .byte.b	<snes2atarihandler	; 11=snes
   2729  273f7			00		       .byte.b	0	; 12=mega7800
   2730  273f8
   2731  273f8				    drawwait
   2732  273f8			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2733  273fa			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   2734  273fc			60		       rts
   2735  273fd
   2736  273fd				    drawoverwait
   2737  273fd			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2738  273ff			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   2739  27401			60		       rts
   2740  27402
   2741  27402
   2742  27402				    mutetia
   2743  27402			a9 00		       lda	#0
   2744  27404			a2 03		       ldx	#3
   2745  27406				    mutetialoop
   2746  27406			95 4e		       sta	sfx1pointlo,x
   2747  27408			95 17		       sta	AUDF0,x
   2748  2740a			ca		       dex
   2749  2740b			10 f9		       bpl	mutetialoop
   2750  2740d			60		       rts
   2751  2740e
   2752  2740e				    servicesfxchannelsdone
   2753  2740e					       ifnconst	pokeysupport
   2754  2740e			60		       rts
   2755  2740f				   -	       else
   2756  2740f				   -	       jmp	checkpokeyplaying
   2757  2740f					       endif
   2758  2740f				    servicesfxchannels
   2759  2740f				   -	       ifconst	PAUSESILENT
   2760  2740f				   -	       lda	pausestate
   2761  2740f				   -	       beq	servicesfxchannels_1
   2762  2740f				   -	       rts
   2763  2740f				   -servicesfxchannels_1
   2764  2740f					       endif
   2765  2740f			a2 ff		       ldx	#255
   2766  27411				    servicesfxchannelsloop
   2767  27411			e8		       inx
   2768  27412					       ifnconst	TIASFXMONO
   2769  27412			e0 02		       cpx	#2
   2770  27414				   -	       else
   2771  27414				   -	       cpx	#1
   2772  27414					       endif
   2773  27414			f0 f8		       beq	servicesfxchannelsdone
   2774  27416
   2775  27416			a5 de		       lda	sfxschedulelock	; =1 if locked
   2776  27418			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   2777  2741a
   2778  2741a			b5 4e		       lda	sfx1pointlo,x
   2779  2741c			85 dc		       sta	inttemp5
   2780  2741e			15 50		       ora	sfx1pointhi,x
   2781  27420			f0 ef		       beq	servicesfxchannelsloop
   2782  27422			b5 50		       lda	sfx1pointhi,x
   2783  27424			85 dd		       sta	inttemp6
   2784  27426
   2785  27426			b5 58		       lda	sfx1tick,x
   2786  27428			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   2787  2742a			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2788  2742c			4c 11 f4	       jmp	servicesfxchannelsloop
   2789  2742f				    servicesfx_cont1
   2790  2742f
   2791  2742f			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   2792  27431			b1 dc		       lda	(inttemp5),y
   2793  27433			c9 10		       cmp	#$10
   2794  27435			d0 1b		       bne	servicesfx_cont1a
   2795  27437			a0 02		       ldy	#2
   2796  27439			b1 dc		       lda	(inttemp5),y
   2797  2743b			95 56		       sta	sfx1frames,x	; change the frame countdown
   2798  2743d			a9 00		       lda	#0
   2799  2743f			95 58		       sta	sfx1tick,x
   2800  27441							; advance the sound pointer by 3...
   2801  27441			b5 4e		       lda	sfx1pointlo,x
   2802  27443			18		       clc
   2803  27444			69 03		       adc	#3
   2804  27446			95 4e		       sta	sfx1pointlo,x
   2805  27448			b5 50		       lda	sfx1pointhi,x
   2806  2744a			69 00		       adc	#0
   2807  2744c			95 50		       sta	sfx1pointhi,x
   2808  2744e							; and then fetch another sample for this channel...
   2809  2744e			ca		       dex
   2810  2744f			4c 11 f4	       jmp	servicesfxchannelsloop
   2811  27452				    servicesfx_cont1a
   2812  27452
   2813  27452			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2814  27454			95 58		       sta	sfx1tick,x
   2815  27456
   2816  27456			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2817  27458			f0 02		       beq	servicesfx_cont2
   2818  2745a			d6 52		       dec	sfx1priority,x
   2819  2745c				    servicesfx_cont2
   2820  2745c
   2821  2745c			a0 00		       ldy	#0	; play the sound
   2822  2745e			b1 dc		       lda	(inttemp5),y
   2823  27460			85 d8		       sta	inttemp1
   2824  27462
   2825  27462				   -	       ifconst	MUSICTRACKER
   2826  27462				   -	       lda	sfx1notedata,x
   2827  27462				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   2828  27462				   -	       ldy	#0
   2829  27462				   -	       sty	inttemp2
   2830  27462				   -	       clc
   2831  27462				   -	       adc	(inttemp5),y
   2832  27462				   -	       asl		; x2
   2833  27462				   -	       tay
   2834  27462				   -	       lda	tiatrackeroctavenotes,y
   2835  27462				   -	       sta	AUDC0,x
   2836  27462				   -	       iny
   2837  27462				   -	       lda	tiatrackeroctavenotes,y
   2838  27462				   -	       sta	AUDF0,x
   2839  27462				   -	       ldy	#1
   2840  27462				   -	       jmp	sfxvolumeentrypt
   2841  27462				   -exitmusictracker
   2842  27462				   -	       lda	inttemp1
   2843  27462					       endif		; MUSICTRACKER
   2844  27462
   2845  27462			18		       clc
   2846  27463			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   2847  27465			95 17		       sta	AUDF0,x
   2848  27467			c8		       iny
   2849  27468			b1 dc		       lda	(inttemp5),y
   2850  2746a			95 15		       sta	AUDC0,x
   2851  2746c			85 d9		       sta	inttemp2
   2852  2746e			c8		       iny
   2853  2746f				    sfxvolumeentrypt
   2854  2746f				   -	       ifconst	TIAVOLUME
   2855  2746f				   -	       lda	tiavolume
   2856  2746f				   -	       asl
   2857  2746f				   -	       asl
   2858  2746f				   -	       asl
   2859  2746f				   -	       asl
   2860  2746f				   -	       sta	fourbitfadevalueint
   2861  2746f					       endif		; TIAVOLUME
   2862  2746f			b1 dc		       lda	(inttemp5),y
   2863  27471				   -	       ifconst	TIAVOLUME
   2864  27471				   -	       jsr	fourbitfadeint
   2865  27471					       endif		; TIAVOLUME
   2866  27471			95 19		       sta	AUDV0,x
   2867  27473			c9 10		       cmp	#$10
   2868  27475			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2869  27477
   2870  27477			05 d9		       ora	inttemp2
   2871  27479			05 d8		       ora	inttemp1	; check if F|C|V=0
   2872  2747b			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   2873  2747d
   2874  2747d				    advancesfxpointer
   2875  2747d							; advance the pointer to the next sound chunk
   2876  2747d			c8		       iny
   2877  2747e			84 da		       sty	inttemp3
   2878  27480			18		       clc
   2879  27481			b5 4e		       lda	sfx1pointlo,x
   2880  27483			65 da		       adc	inttemp3
   2881  27485			95 4e		       sta	sfx1pointlo,x
   2882  27487			b5 50		       lda	sfx1pointhi,x
   2883  27489			69 00		       adc	#0
   2884  2748b			95 50		       sta	sfx1pointhi,x
   2885  2748d			4c 11 f4	       jmp	servicesfxchannelsloop
   2886  27490
   2887  27490				    sfxsoundloop
   2888  27490			48		       pha
   2889  27491			b5 52		       lda	sfx1priority,x
   2890  27493			d0 04		       bne	sfxsoundloop_carryon
   2891  27495			68		       pla		; fix the stack before we go
   2892  27496			4c 7d f4	       jmp	advancesfxpointer
   2893  27499				    sfxsoundloop_carryon
   2894  27499			68		       pla
   2895  2749a			29 f0		       and	#$F0
   2896  2749c			4a		       lsr
   2897  2749d			4a		       lsr
   2898  2749e			4a		       lsr
   2899  2749f			4a		       lsr
   2900  274a0
   2901  274a0				    zerosfx
   2902  274a0			95 4e		       sta	sfx1pointlo,x
   2903  274a2			95 50		       sta	sfx1pointhi,x
   2904  274a4			95 52		       sta	sfx1priority,x
   2905  274a6			4c 11 f4	       jmp	servicesfxchannelsloop
   2906  274a9
   2907  274a9
   2908  274a9				    schedulesfx
   2909  274a9							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2910  274a9			a0 00		       ldy	#0
   2911  274ab				   -	       ifconst	pokeysupport
   2912  274ab				   -	       lda	sfxinstrumenthi
   2913  274ab				   -	       beq	scheduletiasfx	; drums have undefined instrument
   2914  274ab				   -	       lda	(sfxinstrumentlo),y
   2915  274ab				   -	       cmp	#$20	; POKEY?
   2916  274ab				   -	       bne	scheduletiasfx
   2917  274ab				   -	       jmp	schedulepokeysfx
   2918  274ab					       endif
   2919  274ab				    scheduletiasfx
   2920  274ab							;cmp #$10 ; TIA?
   2921  274ab							;beq continuescheduletiasfx
   2922  274ab							; rts ; unhandled!!! 
   2923  274ab				    continuescheduletiasfx
   2924  274ab					       ifnconst	TIASFXMONO
   2925  274ab			a5 50		       lda	sfx1pointhi
   2926  274ad			f0 15		       beq	schedulesfx1	;if channel 1 is idle, use it
   2927  274af			a5 51		       lda	sfx2pointhi
   2928  274b1			f0 15		       beq	schedulesfx2	;if channel 2 is idle, use it
   2929  274b3							; Both channels are scheduled. 
   2930  274b3			a5 e1		       lda	sfxinstrumenthi
   2931  274b5			f0 06		       beq	skipscheduledrums
   2932  274b7			a0 01		       ldy	#1
   2933  274b9			b1 e0		       lda	(sfxinstrumentlo),y
   2934  274bb			d0 01		       bne	interruptsfx
   2935  274bd				    skipscheduledrums
   2936  274bd			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2937  274be				    interruptsfx
   2938  274be							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2939  274be			a5 52		       lda	sfx1priority
   2940  274c0			c5 53		       cmp	sfx2priority
   2941  274c2			b0 04		       bcs	schedulesfx2
   2942  274c4					       endif		; !TIASFXMONO
   2943  274c4
   2944  274c4				    schedulesfx1
   2945  274c4			a2 00		       ldx	#0	; channel 1
   2946  274c6					       ifnconst	TIASFXMONO
   2947  274c6			f0 02		       beq	skipschedulesfx2
   2948  274c8				    schedulesfx2
   2949  274c8			a2 01		       ldx	#1	; channel 2
   2950  274ca				    skipschedulesfx2
   2951  274ca					       endif		; !TIASFXMONO
   2952  274ca
   2953  274ca				   -	       ifconst	MUSICTRACKER
   2954  274ca				   -	       lda	sfxnoteindex
   2955  274ca				   -	       bpl	skipdrumkitoverride
   2956  274ca				   -	       and	#$7F	; subtract 128
   2957  274ca				   -	       sec
   2958  274ca				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   2959  274ca				   -	       asl
   2960  274ca				   -	       tay
   2961  274ca				   -	       lda	tiadrumkitdefinition,y
   2962  274ca				   -	       sta	sfxinstrumentlo
   2963  274ca				   -	       iny
   2964  274ca				   -	       lda	tiadrumkitdefinition,y
   2965  274ca				   -	       sta	sfxinstrumenthi
   2966  274ca				   -	       lda	#0
   2967  274ca				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2968  274ca				   -skipdrumkitoverride
   2969  274ca					       endif		; MUSICTRACKER
   2970  274ca			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   2971  274cc			b1 e0		       lda	(sfxinstrumentlo),y
   2972  274ce			95 52		       sta	sfx1priority,x
   2973  274d0			c8		       iny
   2974  274d1			b1 e0		       lda	(sfxinstrumentlo),y
   2975  274d3			95 56		       sta	sfx1frames,x
   2976  274d5			a5 e0		       lda	sfxinstrumentlo
   2977  274d7			18		       clc
   2978  274d8			69 03		       adc	#3
   2979  274da			95 4e		       sta	sfx1pointlo,x
   2980  274dc			a5 e1		       lda	sfxinstrumenthi
   2981  274de			69 00		       adc	#0
   2982  274e0			95 50		       sta	sfx1pointhi,x
   2983  274e2			a5 e2		       lda	sfxpitchoffset
   2984  274e4			95 54		       sta	sfx1poffset,x
   2985  274e6			a9 00		       lda	#0
   2986  274e8			95 58		       sta	sfx1tick,x
   2987  274ea			a5 e3		       lda	sfxnoteindex
   2988  274ec			95 cd		       sta	sfx1notedata,x
   2989  274ee			60		       rts
   2990  274ef
   2991  274ef				    plotsprite
   2992  274ef					       ifnconst	NODRAWWAIT
   2993  274ef				   -	       ifconst	DOUBLEBUFFER
   2994  274ef				   -	       lda	doublebufferstate
   2995  274ef				   -	       bne	skipplotspritewait
   2996  274ef					       endif		; DOUBLEBUFFER
   2997  274ef				   -	       ifconst	DEBUGWAITCOLOR
   2998  274ef				   -	       lda	#$41
   2999  274ef				   -	       sta	BACKGRND
   3000  274ef					       endif
   3001  274ef				    plotspritewait
   3002  274ef			a5 4d		       lda	visibleover
   3003  274f1			d0 fc		       bne	plotspritewait
   3004  274f3				    skipplotspritewait
   3005  274f3				   -	       ifconst	DEBUGWAITCOLOR
   3006  274f3				   -	       lda	#$0
   3007  274f3				   -	       sta	BACKGRND
   3008  274f3					       endif
   3009  274f3					       endif
   3010  274f3
   3011  274f3							;arguments: 
   3012  274f3							; temp1=lo graphicdata 
   3013  274f3							; temp2=hi graphicdata 
   3014  274f3							; temp3=palette | width byte
   3015  274f3							; temp4=x
   3016  274f3							; temp5=y
   3017  274f3							; temp6=mode
   3018  274f3			a5 46		       lda	temp5	;Y position
   3019  274f5			4a		       lsr		; 2 - Divide by 8 or 16
   3020  274f6			4a		       lsr		; 2
   3021  274f7			4a		       lsr		; 2
   3022  274f8					       if	WZONEHEIGHT = 16
   3023  274f8			4a		       lsr		; 2
   3024  274f9					       endif
   3025  274f9
   3026  274f9			aa		       tax
   3027  274fa
   3028  274fa					       ifnconst	NOLIMITCHECKING
   3029  274fa
   3030  274fa							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   3031  274fa
   3032  274fa			c9 0c		       cmp	#WZONECOUNT
   3033  274fc
   3034  274fc			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   3035  274fe							; otherwise, check to see if the bottom half is in zone 0...
   3036  274fe
   3037  274fe					       if	WZONEHEIGHT = 16
   3038  274fe			c9 0f		       cmp	#15
   3039  27500				   -	       else
   3040  27500				   -	       cmp	#31
   3041  27500					       endif
   3042  27500
   3043  27500			d0 05		       bne	exitplotsprite1
   3044  27502			a2 00		       ldx	#0
   3045  27504			4c 3d f5	       jmp	continueplotsprite2
   3046  27507				    exitplotsprite1
   3047  27507			60		       rts
   3048  27508
   3049  27508				    continueplotsprite1
   3050  27508					       endif
   3051  27508
   3052  27508				   -	       ifconst	VSCROLL
   3053  27508				   -	       ldy	Xx3,x
   3054  27508				   -	       lda	DLLMEM+11,y
   3055  27508					       else		; !VSCROLL
   3056  27508			bd 5e f7	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3057  2750b					       endif		; !VSCROLL
   3058  2750b				   -	       ifconst	DOUBLEBUFFER
   3059  2750b				   -	       clc
   3060  2750b				   -	       adc	doublebufferdloffset
   3061  2750b					       endif		; DOUBLEBUFFER
   3062  2750b			85 63		       sta	dlpnt
   3063  2750d				   -	       ifconst	VSCROLL
   3064  2750d				   -	       lda	DLLMEM+10,y
   3065  2750d					       else		; !VSCROLL
   3066  2750d			bd 52 f7	       lda	DLPOINTH,x
   3067  27510					       endif		; !VSCROLL
   3068  27510				   -	       ifconst	DOUBLEBUFFER
   3069  27510				   -	       adc	#0
   3070  27510					       endif		; DOUBLEBUFFER
   3071  27510			85 64		       sta	dlpnt+1
   3072  27512
   3073  27512							;Create DL entry for upper part of sprite
   3074  27512
   3075  27512			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3076  27514
   3077  27514				   -	       ifconst	CHECKOVERWRITE
   3078  27514				   -	       cpy	#DLLASTOBJ
   3079  27514				   -	       beq	checkcontinueplotsprite2
   3080  27514				   -continueplotsprite1a
   3081  27514					       endif
   3082  27514
   3083  27514			a5 42		       lda	temp1	; graphic data, lo byte
   3084  27516			91 63		       sta	(dlpnt),y	;Low byte of data address
   3085  27518
   3086  27518					       ifnconst	ATOMICSPRITEUPDATE
   3087  27518			c8		       iny
   3088  27519			a5 47		       lda	temp6
   3089  2751b			91 63		       sta	(dlpnt),y
   3090  2751d				   -	       else
   3091  2751d				   -	       iny
   3092  2751d				   -	       sty	temp8
   3093  2751d					       endif
   3094  2751d
   3095  2751d			c8		       iny
   3096  2751e
   3097  2751e			a5 46		       lda	temp5	;Y position
   3098  27520			29 0f		       and	#(WZONEHEIGHT - 1)
   3099  27522			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   3100  27524			05 43		       ora	temp2	; graphic data, hi byte
   3101  27526			91 63		       sta	(dlpnt),y
   3102  27528
   3103  27528			c8		       iny
   3104  27529			a5 44		       lda	temp3	;palette|width
   3105  2752b			91 63		       sta	(dlpnt),y
   3106  2752d
   3107  2752d			c8		       iny
   3108  2752e			a5 45		       lda	temp4	;Horizontal position
   3109  27530			91 63		       sta	(dlpnt),y
   3110  27532
   3111  27532			c8		       iny
   3112  27533			94 65		       sty	dlend,x
   3113  27535
   3114  27535				   -	       ifconst	ALWAYSTERMINATE
   3115  27535				   -	       iny
   3116  27535				   -	       lda	#0
   3117  27535				   -	       sta	(dlpnt),y
   3118  27535					       endif
   3119  27535
   3120  27535				   -	       ifconst	ATOMICSPRITEUPDATE
   3121  27535				   -	       ldy	temp8
   3122  27535				   -	       lda	temp6
   3123  27535				   -	       sta	(dlpnt),y
   3124  27535					       endif
   3125  27535
   3126  27535				    checkcontinueplotsprite2
   3127  27535
   3128  27535			90 33		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   3129  27537
   3130  27537							;Create DL entry for lower part of sprite
   3131  27537
   3132  27537			e8		       inx		;Next region
   3133  27538
   3134  27538					       ifnconst	NOLIMITCHECKING
   3135  27538			e0 0c		       cpx	#WZONECOUNT
   3136  2753a
   3137  2753a			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3138  2753c			60		       rts
   3139  2753d				    continueplotsprite2
   3140  2753d					       endif
   3141  2753d
   3142  2753d				   -	       ifconst	VSCROLL
   3143  2753d				   -	       ldy	Xx3,x
   3144  2753d				   -	       lda	DLLMEM+11,y
   3145  2753d					       else		; !VSCROLL
   3146  2753d			bd 5e f7	       lda	DLPOINTL,x	;Get pointer to next DL
   3147  27540					       endif		; !VSCROLL
   3148  27540				   -	       ifconst	DOUBLEBUFFER
   3149  27540				   -	       clc
   3150  27540				   -	       adc	doublebufferdloffset
   3151  27540					       endif		; DOUBLEBUFFER
   3152  27540			85 63		       sta	dlpnt
   3153  27542				   -	       ifconst	VSCROLL
   3154  27542				   -	       lda	DLLMEM+10,y
   3155  27542					       else		; !VSCROLL
   3156  27542			bd 52 f7	       lda	DLPOINTH,x
   3157  27545					       endif		; !VSCROLL
   3158  27545				   -	       ifconst	DOUBLEBUFFER
   3159  27545				   -	       adc	#0
   3160  27545					       endif		; DOUBLEBUFFER
   3161  27545			85 64		       sta	dlpnt+1
   3162  27547			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3163  27549
   3164  27549				   -	       ifconst	CHECKOVERWRITE
   3165  27549				   -	       cpy	#DLLASTOBJ
   3166  27549				   -	       bne	continueplotsprite2a
   3167  27549				   -	       rts
   3168  27549				   -continueplotsprite2a
   3169  27549					       endif
   3170  27549
   3171  27549			a5 42		       lda	temp1	; graphic data, lo byte
   3172  2754b			91 63		       sta	(dlpnt),y
   3173  2754d
   3174  2754d					       ifnconst	ATOMICSPRITEUPDATE
   3175  2754d			c8		       iny
   3176  2754e			a5 47		       lda	temp6
   3177  27550			91 63		       sta	(dlpnt),y
   3178  27552				   -	       else
   3179  27552				   -	       iny
   3180  27552				   -	       sty	temp8
   3181  27552					       endif
   3182  27552
   3183  27552			c8		       iny
   3184  27553
   3185  27553			a5 46		       lda	temp5	;Y position
   3186  27555			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   3187  27557			05 43		       ora	temp2	; graphic data, hi byte
   3188  27559			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   3189  2755b			91 63		       sta	(dlpnt),y
   3190  2755d
   3191  2755d			c8		       iny
   3192  2755e
   3193  2755e			a5 44		       lda	temp3	;palette|width
   3194  27560			91 63		       sta	(dlpnt),y
   3195  27562
   3196  27562			c8		       iny
   3197  27563
   3198  27563			a5 45		       lda	temp4	;Horizontal position
   3199  27565			91 63		       sta	(dlpnt),y
   3200  27567
   3201  27567			c8		       iny
   3202  27568			94 65		       sty	dlend,x
   3203  2756a
   3204  2756a				   -	       ifconst	ALWAYSTERMINATE
   3205  2756a				   -	       iny
   3206  2756a				   -	       lda	#0
   3207  2756a				   -	       sta	(dlpnt),y
   3208  2756a					       endif
   3209  2756a
   3210  2756a				   -	       ifconst	ATOMICSPRITEUPDATE
   3211  2756a				   -	       ldy	temp8
   3212  2756a				   -	       lda	temp6
   3213  2756a				   -	       sta	(dlpnt),y
   3214  2756a					       endif
   3215  2756a
   3216  2756a				    doneSPDL
   3217  2756a			60		       rts
   3218  2756b
   3219  2756b				   -	       ifconst	VSCROLL
   3220  2756b				   -			; x3 table for fast DLL parsing
   3221  2756b				   -Xx3
   3222  2756b				   -	       .byte	0,3,6,9,12,15,18,21,24,27
   3223  2756b				   -	       .byte	30,33,36,39,42,45,48,51,54,57
   3224  2756b				   -	       .byte	60,63,66,69,72,75,78,81,84,87
   3225  2756b				   -maskscrollsprite
   3226  2756b				   -	       .byte	$00,%11000000,($D0+WZONEHEIGHT),0,160	; 5*2 + 32*3 = 106 cycles
   3227  2756b				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3228  2756b				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3229  2756b				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3230  2756b				   -	       .byte	$00,%01000000,($D0+WZONEHEIGHT),16,160	; 5*2 + 16*3 =  58 cycles
   3231  2756b				   -			; MAX	============ 467 cycles
   3232  2756b				   -			; MIN	============  59 cycles
   3233  2756b				   -maskscrollspriteend
   3234  2756b					       endif		; VSCROLL
   3235  2756b
   3236  2756b				    lockzonex
   3237  2756b				   -	       ifconst	ZONELOCKS
   3238  2756b				   -	       ldy	dlend,x
   3239  2756b				   -	       cpy	#DLLASTOBJ
   3240  2756b				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3241  2756b				   -	       lda	DLPOINTL,x
   3242  2756b				   -	       ifconst	DOUBLEBUFFER
   3243  2756b				   -	       clc
   3244  2756b				   -	       adc	doublebufferdloffset
   3245  2756b				   -	       endif		; DOUBLEBUFFER
   3246  2756b				   -	       sta	dlpnt
   3247  2756b				   -	       lda	DLPOINTH,x
   3248  2756b				   -	       ifconst	DOUBLEBUFFER
   3249  2756b				   -	       adc	#0
   3250  2756b				   -	       endif		; DOUBLEBUFFER
   3251  2756b				   -	       sta	dlpnt+1
   3252  2756b				   -	       iny
   3253  2756b				   -	       lda	#0
   3254  2756b				   -	       sta	(dlpnt),y
   3255  2756b				   -	       dey
   3256  2756b				   -	       tya
   3257  2756b				   -	       ldy	#(DLLASTOBJ-1)
   3258  2756b				   -	       sta	(dlpnt),y
   3259  2756b				   -	       iny
   3260  2756b				   -	       sty	dlend,x
   3261  2756b				   -lockzonexreturn
   3262  2756b				   -	       rts
   3263  2756b					       endif		; ZONELOCKS
   3264  2756b				    unlockzonex
   3265  2756b				   -	       ifconst	ZONELOCKS
   3266  2756b				   -	       ldy	dlend,x
   3267  2756b				   -	       cpy	#DLLASTOBJ
   3268  2756b				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3269  2756b				   -	       lda	DLPOINTL,x
   3270  2756b				   -	       ifconst	DOUBLEBUFFER
   3271  2756b				   -	       clc
   3272  2756b				   -	       adc	doublebufferdloffset
   3273  2756b				   -	       endif		; DOUBLEBUFFER
   3274  2756b				   -	       sta	dlpnt
   3275  2756b				   -	       lda	DLPOINTH,x
   3276  2756b				   -	       ifconst	DOUBLEBUFFER
   3277  2756b				   -	       adc	#0
   3278  2756b				   -	       endif		; DOUBLEBUFFER
   3279  2756b				   -	       sta	dlpnt+1
   3280  2756b				   -	       dey
   3281  2756b				   -	       lda	(dlpnt),y
   3282  2756b				   -	       tay
   3283  2756b				   -	       sty	dlend,x
   3284  2756b				   -unlockzonexreturn
   3285  2756b					       endif		; ZONELOCKS
   3286  2756b			60		       rts
   3287  2756c
   3288  2756c				    plotcharloop
   3289  2756c							; ** read from a data indirectly pointed to from temp8,temp9
   3290  2756c							; ** format is: lo_data, hi_data, palette|width, x, y
   3291  2756c							; ** format ends with lo_data | hi_data = 0
   3292  2756c
   3293  2756c				   -	       ifconst	DOUBLEBUFFER
   3294  2756c				   -	       lda	doublebufferstate
   3295  2756c				   -	       bne	skipplotcharloopwait
   3296  2756c					       endif		; DOUBLEBUFFER
   3297  2756c				   -	       ifconst	DEBUGWAITCOLOR
   3298  2756c				   -	       lda	#$61
   3299  2756c				   -	       sta	BACKGRND
   3300  2756c					       endif
   3301  2756c				    plotcharloopwait
   3302  2756c			a5 4d		       lda	visibleover
   3303  2756e			d0 fc		       bne	plotcharloopwait
   3304  27570				   -	       ifconst	DEBUGWAITCOLOR
   3305  27570				   -	       lda	#0
   3306  27570				   -	       sta	BACKGRND
   3307  27570					       endif
   3308  27570				    skipplotcharloopwait
   3309  27570				    plotcharlooploop
   3310  27570			a0 00		       ldy	#0
   3311  27572			b1 49		       lda	(temp8),y
   3312  27574			85 42		       sta	temp1
   3313  27576			c8		       iny
   3314  27577			b1 49		       lda	(temp8),y
   3315  27579			85 43		       sta	temp2
   3316  2757b			05 42		       ora	temp1
   3317  2757d			d0 01		       bne	plotcharloopcontinue
   3318  2757f							;the pointer=0, so return
   3319  2757f			60		       rts
   3320  27580				    plotcharloopcontinue
   3321  27580			c8		       iny
   3322  27581			b1 49		       lda	(temp8),y
   3323  27583			85 44		       sta	temp3
   3324  27585			c8		       iny
   3325  27586			b1 49		       lda	(temp8),y
   3326  27588			85 45		       sta	temp4
   3327  2758a			c8		       iny
   3328  2758b			b1 49		       lda	(temp8),y
   3329  2758d							;sta temp5 ; not needed with our late entry.
   3330  2758d			20 a6 f5	       jsr	plotcharactersskipentry
   3331  27590			a5 49		       lda	temp8
   3332  27592			18		       clc
   3333  27593			69 05		       adc	#5
   3334  27595			85 49		       sta	temp8
   3335  27597			a5 4a		       lda	temp9
   3336  27599			69 00		       adc	#0
   3337  2759b			85 4a		       sta	temp9
   3338  2759d			4c 70 f5	       jmp	plotcharlooploop
   3339  275a0
   3340  275a0				    plotcharacters
   3341  275a0				   -	       ifconst	DOUBLEBUFFER
   3342  275a0				   -	       lda	doublebufferstate
   3343  275a0				   -	       bne	skipplotcharacterswait
   3344  275a0					       endif		; DOUBLEBUFFER
   3345  275a0				   -	       ifconst	DEBUGWAITCOLOR
   3346  275a0				   -	       lda	#$41
   3347  275a0				   -	       sta	BACKGRND
   3348  275a0					       endif
   3349  275a0				    plotcharacterswait
   3350  275a0			a5 4d		       lda	visibleover
   3351  275a2			d0 fc		       bne	plotcharacterswait
   3352  275a4				   -	       ifconst	DEBUGWAITCOLOR
   3353  275a4				   -	       sta	BACKGRND
   3354  275a4					       endif
   3355  275a4				    skipplotcharacterswait
   3356  275a4							;arguments: 
   3357  275a4							; temp1=lo charactermap
   3358  275a4							; temp2=hi charactermap
   3359  275a4							; temp3=palette | width byte
   3360  275a4							; temp4=x
   3361  275a4							; temp5=y
   3362  275a4
   3363  275a4			a5 46		       lda	temp5	;Y position
   3364  275a6
   3365  275a6				    plotcharactersskipentry
   3366  275a6
   3367  275a6							;ifconst ZONEHEIGHT
   3368  275a6							; if ZONEHEIGHT = 16
   3369  275a6							; and #$0F
   3370  275a6							; endif
   3371  275a6							; if ZONEHEIGHT = 8
   3372  275a6							; and #$1F
   3373  275a6							; endif
   3374  275a6							;else
   3375  275a6							; and #$0F
   3376  275a6							;endif
   3377  275a6
   3378  275a6			aa		       tax
   3379  275a7
   3380  275a7				   -	       ifconst	VSCROLL
   3381  275a7				   -	       ldy	Xx3,x
   3382  275a7				   -	       lda	DLLMEM+11,y
   3383  275a7					       else		; !VSCROLL
   3384  275a7			bd 5e f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3385  275aa					       endif		; !VSCROLL
   3386  275aa				   -	       ifconst	DOUBLEBUFFER
   3387  275aa				   -	       clc
   3388  275aa				   -	       adc	doublebufferdloffset
   3389  275aa					       endif		; DOUBLEBUFFER
   3390  275aa			85 63		       sta	dlpnt
   3391  275ac				   -	       ifconst	VSCROLL
   3392  275ac				   -	       lda	DLLMEM+10,y
   3393  275ac					       else		; !VSCROLL
   3394  275ac			bd 52 f7	       lda	DLPOINTH,x
   3395  275af					       endif		; !VSCROLL
   3396  275af				   -	       ifconst	DOUBLEBUFFER
   3397  275af				   -	       adc	#0
   3398  275af					       endif		; DOUBLEBUFFER
   3399  275af			85 64		       sta	dlpnt+1
   3400  275b1
   3401  275b1							;Create DL entry for the characters
   3402  275b1
   3403  275b1			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3404  275b3
   3405  275b3				   -	       ifconst	CHECKOVERWRITE
   3406  275b3				   -	       cpy	#DLLASTOBJ
   3407  275b3				   -	       bne	continueplotcharacters
   3408  275b3				   -	       rts
   3409  275b3				   -continueplotcharacters
   3410  275b3					       endif
   3411  275b3
   3412  275b3			a5 42		       lda	temp1	; character map data, lo byte
   3413  275b5			91 63		       sta	(dlpnt),y	;(1) store low address
   3414  275b7
   3415  275b7			c8		       iny
   3416  275b8			ad 06 21	       lda	charactermode
   3417  275bb			91 63		       sta	(dlpnt),y	;(2) store mode
   3418  275bd
   3419  275bd			c8		       iny
   3420  275be			a5 43		       lda	temp2	; character map, hi byte
   3421  275c0			91 63		       sta	(dlpnt),y	;(3) store high address
   3422  275c2
   3423  275c2			c8		       iny
   3424  275c3			a5 44		       lda	temp3	;palette|width
   3425  275c5			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3426  275c7
   3427  275c7			c8		       iny
   3428  275c8			a5 45		       lda	temp4	;Horizontal position
   3429  275ca			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3430  275cc
   3431  275cc			c8		       iny
   3432  275cd			94 65		       sty	dlend,x	; save display list end byte
   3433  275cf			60		       rts
   3434  275d0
   3435  275d0
   3436  275d0					       ifconst	plotvalueonscreen
   3437  275d0				    plotcharacterslive
   3438  275d0							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3439  275d0
   3440  275d0							;arguments: 
   3441  275d0							; temp1=lo charactermap
   3442  275d0							; temp2=hi charactermap
   3443  275d0							; temp3=palette | width byte
   3444  275d0							; temp4=x
   3445  275d0							; temp5=y
   3446  275d0
   3447  275d0			a5 46		       lda	temp5	;Y position
   3448  275d2
   3449  275d2			aa		       tax
   3450  275d3
   3451  275d3				   -	       ifconst	VSCROLL
   3452  275d3				   -	       ldy	Xx3,x
   3453  275d3				   -	       lda	DLLMEM+11,y
   3454  275d3					       else		; !VSCROLL
   3455  275d3			bd 5e f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3456  275d6					       endif		; !VSCROLL
   3457  275d6				   -	       ifconst	DOUBLEBUFFER
   3458  275d6				   -	       clc
   3459  275d6				   -	       adc	doublebufferdloffset
   3460  275d6					       endif		; DOUBLEBUFFER
   3461  275d6			85 63		       sta	dlpnt
   3462  275d8				   -	       ifconst	VSCROLL
   3463  275d8				   -	       lda	DLLMEM+10,y
   3464  275d8					       else		; !VSCROLL
   3465  275d8			bd 52 f7	       lda	DLPOINTH,x
   3466  275db					       endif		; !VSCROLL
   3467  275db				   -	       ifconst	DOUBLEBUFFER
   3468  275db				   -	       adc	#0
   3469  275db					       endif		; DOUBLEBUFFER
   3470  275db			85 64		       sta	dlpnt+1
   3471  275dd
   3472  275dd							;Create DL entry for the characters
   3473  275dd
   3474  275dd			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3475  275df
   3476  275df				   -	       ifconst	CHECKOVERWRITE
   3477  275df				   -	       cpy	#DLLASTOBJ
   3478  275df				   -	       bne	continueplotcharacterslive
   3479  275df				   -	       rts
   3480  275df				   -continueplotcharacterslive
   3481  275df					       endif
   3482  275df
   3483  275df			a5 42		       lda	temp1	; character map data, lo byte
   3484  275e1			91 63		       sta	(dlpnt),y	;(1) store low address
   3485  275e3
   3486  275e3			c8		       iny
   3487  275e4							; we don't add the second byte yet, since the charmap could briefly
   3488  275e4							; render without a proper character map address, width, or position.
   3489  275e4			ad 06 21	       lda	charactermode
   3490  275e7			91 63		       sta	(dlpnt),y	;(2) store mode
   3491  275e9
   3492  275e9			c8		       iny
   3493  275ea			a5 43		       lda	temp2	; character map, hi byte
   3494  275ec			91 63		       sta	(dlpnt),y	;(3) store high address
   3495  275ee
   3496  275ee			c8		       iny
   3497  275ef			a5 44		       lda	temp3	;palette|width
   3498  275f1			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3499  275f3
   3500  275f3			c8		       iny
   3501  275f4			a5 45		       lda	temp4	;Horizontal position
   3502  275f6			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3503  275f8
   3504  275f8			c8		       iny
   3505  275f9			94 65		       sty	dlend,x	; save display list end byte
   3506  275fb
   3507  275fb			60		       rts
   3508  275fc					       endif		;plotcharacterslive
   3509  275fc
   3510  275fc				   -	       ifconst	USED_PLOTVALUE
   3511  275fc				   -plotvalue
   3512  275fc				   -			; calling 7800basic command:
   3513  275fc				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3514  275fc				   -			; ...displays the variable as BCD digits
   3515  275fc				   -			;
   3516  275fc				   -			; asm sub arguments: 
   3517  275fc				   -			; temp1=lo charactermap
   3518  275fc				   -			; temp2=hi charactermap
   3519  275fc				   -			; temp3=palette | width byte
   3520  275fc				   -			; temp4=x
   3521  275fc				   -			; temp5=y
   3522  275fc				   -			; temp6=number of digits
   3523  275fc				   -			; temp7=lo variable
   3524  275fc				   -			; temp8=hi variable
   3525  275fc				   -			; temp9=character mode
   3526  275fc				   -
   3527  275fc				   -plotdigitcount =	temp6
   3528  275fc				   -
   3529  275fc				   -	       ifconst	ZONELOCKS
   3530  275fc				   -	       ldx	temp5
   3531  275fc				   -	       ldy	dlend,x
   3532  275fc				   -	       cpy	#DLLASTOBJ
   3533  275fc				   -	       bne	carryonplotvalue
   3534  275fc				   -	       rts
   3535  275fc				   -carryonplotvalue
   3536  275fc				   -	       endif
   3537  275fc				   -
   3538  275fc				   -	       lda	#0
   3539  275fc				   -	       tay
   3540  275fc				   -	       ldx	valbufend
   3541  275fc				   -
   3542  275fc				   -	       lda	plotdigitcount
   3543  275fc				   -	       and	#1
   3544  275fc				   -	       beq	pvnibble2char
   3545  275fc				   -	       lda	#0
   3546  275fc				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   3547  275fc				   -	       beq	pvnibble2char_skipnibble
   3548  275fc				   -
   3549  275fc				   -pvnibble2char
   3550  275fc				   -			; high nibble...
   3551  275fc				   -	       lda	(temp7),y
   3552  275fc				   -	       and	#$f0
   3553  275fc				   -	       lsr
   3554  275fc				   -	       lsr
   3555  275fc				   -	       lsr
   3556  275fc				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3557  275fc				   -	       lsr
   3558  275fc				   -	       endif
   3559  275fc				   -
   3560  275fc				   -	       clc
   3561  275fc				   -	       adc	temp1	; add the offset to character graphics to our value
   3562  275fc				   -	       sta	VALBUFFER,x
   3563  275fc				   -	       inx
   3564  275fc				   -	       dec	plotdigitcount
   3565  275fc				   -
   3566  275fc				   -pvnibble2char_skipnibble
   3567  275fc				   -			; low nibble...
   3568  275fc				   -	       lda	(temp7),y
   3569  275fc				   -	       and	#$0f
   3570  275fc				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3571  275fc				   -	       asl
   3572  275fc				   -	       endif
   3573  275fc				   -	       clc
   3574  275fc				   -	       adc	temp1	; add the offset to character graphics to our value
   3575  275fc				   -	       sta	VALBUFFER,x
   3576  275fc				   -	       inx
   3577  275fc				   -	       iny
   3578  275fc				   -
   3579  275fc				   -	       dec	plotdigitcount
   3580  275fc				   -	       bne	pvnibble2char
   3581  275fc				   -
   3582  275fc				   -			;point to the start of our valuebuffer
   3583  275fc				   -	       clc
   3584  275fc				   -	       lda	#<VALBUFFER
   3585  275fc				   -	       adc	valbufend
   3586  275fc				   -	       sta	temp1
   3587  275fc				   -	       lda	#>VALBUFFER
   3588  275fc				   -	       adc	#0
   3589  275fc				   -	       sta	temp2
   3590  275fc				   -
   3591  275fc				   -			;advance valbufend to the end of our value buffer
   3592  275fc				   -	       stx	valbufend
   3593  275fc				   -
   3594  275fc				   -	       ifnconst	plotvalueonscreen
   3595  275fc				   -	       jmp	plotcharacters
   3596  275fc				   -	       else
   3597  275fc				   -	       jmp	plotcharacterslive
   3598  275fc				   -	       endif
   3599  275fc				   -
   3600  275fc					       endif		; USED_PLOTVALUE
   3601  275fc
   3602  275fc
   3603  275fc				   -	       ifconst	USED_PLOTVALUEEXTRA
   3604  275fc				   -plotdigitcount =	temp6
   3605  275fc				   -plotvalueextra
   3606  275fc				   -			; calling 7800basic command:
   3607  275fc				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3608  275fc				   -			; ...displays the variable as BCD digits
   3609  275fc				   -			;
   3610  275fc				   -			; asm sub arguments: 
   3611  275fc				   -			; temp1=lo charactermap
   3612  275fc				   -			; temp2=hi charactermap
   3613  275fc				   -			; temp3=palette | width byte
   3614  275fc				   -			; temp4=x
   3615  275fc				   -			; temp5=y
   3616  275fc				   -			; temp6=number of digits
   3617  275fc				   -			; temp7=lo variable
   3618  275fc				   -			; temp8=hi variable
   3619  275fc				   -
   3620  275fc				   -	       lda	#0
   3621  275fc				   -	       tay
   3622  275fc				   -	       ldx	valbufend
   3623  275fc				   -	       ifnconst	plotvalueonscreen
   3624  275fc				   -	       sta	VALBUFFER,x
   3625  275fc				   -	       endif
   3626  275fc				   -
   3627  275fc				   -	       lda	plotdigitcount
   3628  275fc				   -	       and	#1
   3629  275fc				   -
   3630  275fc				   -	       bne	pvnibble2char_skipnibbleextra
   3631  275fc				   -
   3632  275fc				   -pvnibble2charextra
   3633  275fc				   -			; high nibble...
   3634  275fc				   -	       lda	(temp7),y
   3635  275fc				   -	       and	#$f0
   3636  275fc				   -	       lsr
   3637  275fc				   -	       lsr
   3638  275fc				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3639  275fc				   -	       lsr
   3640  275fc				   -	       endif
   3641  275fc				   -	       clc
   3642  275fc				   -	       adc	temp1	; add the offset to character graphics to our value
   3643  275fc				   -	       sta	VALBUFFER,x
   3644  275fc				   -	       inx
   3645  275fc				   -
   3646  275fc				   -			; second half of the digit
   3647  275fc				   -	       clc
   3648  275fc				   -	       adc	#1
   3649  275fc				   -	       sta	VALBUFFER,x
   3650  275fc				   -	       inx
   3651  275fc				   -
   3652  275fc				   -pvnibble2char_skipnibbleextra
   3653  275fc				   -			; low nibble...
   3654  275fc				   -	       lda	(temp7),y
   3655  275fc				   -	       and	#$0f
   3656  275fc				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3657  275fc				   -	       asl
   3658  275fc				   -	       endif
   3659  275fc				   -	       asl
   3660  275fc				   -
   3661  275fc				   -	       clc
   3662  275fc				   -	       adc	temp1	; add the offset to character graphics to our value
   3663  275fc				   -	       sta	VALBUFFER,x
   3664  275fc				   -	       inx
   3665  275fc				   -
   3666  275fc				   -	       clc
   3667  275fc				   -	       adc	#1
   3668  275fc				   -	       sta	VALBUFFER,x
   3669  275fc				   -	       inx
   3670  275fc				   -	       iny
   3671  275fc				   -
   3672  275fc				   -	       dec	plotdigitcount
   3673  275fc				   -	       bne	pvnibble2charextra
   3674  275fc				   -
   3675  275fc				   -			;point to the start of our valuebuffer
   3676  275fc				   -	       clc
   3677  275fc				   -	       lda	#<VALBUFFER
   3678  275fc				   -	       adc	valbufend
   3679  275fc				   -	       sta	temp1
   3680  275fc				   -	       lda	#>VALBUFFER
   3681  275fc				   -	       adc	#0
   3682  275fc				   -	       sta	temp2
   3683  275fc				   -
   3684  275fc				   -			;advance valbufend to the end of our value buffer
   3685  275fc				   -	       stx	valbufend
   3686  275fc				   -
   3687  275fc				   -	       ifnconst	plotvalueonscreen
   3688  275fc				   -	       jmp	plotcharacters
   3689  275fc				   -	       else
   3690  275fc				   -	       jmp	plotcharacterslive
   3691  275fc				   -	       endif
   3692  275fc					       endif		; USED_PLOTVALUEEXTRA
   3693  275fc
   3694  275fc				    boxcollision
   3695  275fc				   -	       ifconst	BOXCOLLISION
   3696  275fc				   -			; the worst case cycle-time for the code below is 43 cycles.
   3697  275fc				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3698  275fc				   -
   3699  275fc				   -			;__boxx1 = accumulator
   3700  275fc				   -			;__boxy1 = y
   3701  275fc				   -__boxw1    =	temp3
   3702  275fc				   -__boxh1    =	temp4
   3703  275fc				   -
   3704  275fc				   -__boxx2    =	temp5
   3705  275fc				   -__boxy2    =	temp6
   3706  275fc				   -__boxw2    =	temp7
   3707  275fc				   -__boxh2    =	temp8
   3708  275fc				   -
   3709  275fc				   -DoXCollisionCheck
   3710  275fc				   -			;lda __boxx1 ; skipped. already in the accumulator
   3711  275fc				   -	       cmp	__boxx2	;3
   3712  275fc				   -	       bcs	X1isbiggerthanX2	;2/3
   3713  275fc				   -X2isbiggerthanX1
   3714  275fc				   -			; carry is clear
   3715  275fc				   -	       adc	__boxw1	;3
   3716  275fc				   -	       cmp	__boxx2	;3
   3717  275fc				   -	       bcs	DoYCollisionCheck	;3/2
   3718  275fc				   -	       rts		;6 - carry clear, no collision
   3719  275fc				   -X1isbiggerthanX2
   3720  275fc				   -	       clc		;2
   3721  275fc				   -	       sbc	__boxw2	;3
   3722  275fc				   -	       cmp	__boxx2	;3
   3723  275fc				   -	       bcs	noboxcollision	;3/2
   3724  275fc				   -DoYCollisionCheck
   3725  275fc				   -	       tya		; 2 ; use to be "lda __boxy1"
   3726  275fc				   -	       cmp	__boxy2	;3
   3727  275fc				   -	       bcs	Y1isbiggerthanY2	;3/2
   3728  275fc				   -Y2isbiggerthanY1
   3729  275fc				   -			; carry is clear
   3730  275fc				   -	       adc	__boxh1	;3
   3731  275fc				   -	       cmp	__boxy2	;3
   3732  275fc				   -	       rts		;6 
   3733  275fc				   -Y1isbiggerthanY2
   3734  275fc				   -	       clc		;2
   3735  275fc				   -	       sbc	__boxh2	;3
   3736  275fc				   -	       cmp	__boxy2	;3
   3737  275fc				   -	       bcs	noboxcollision	;3/2
   3738  275fc				   -yesboxcollision
   3739  275fc				   -	       sec		;2
   3740  275fc				   -	       rts		;6
   3741  275fc				   -noboxcollision
   3742  275fc				   -	       clc		;2
   3743  275fc				   -	       rts		;6
   3744  275fc					       endif		; BOXCOLLISION
   3745  275fc
   3746  275fc				    randomize
   3747  275fc			a5 40		       lda	rand
   3748  275fe			4a		       lsr
   3749  275ff			26 41		       rol	rand16
   3750  27601			90 02		       bcc	noeor
   3751  27603			49 b4		       eor	#$B4
   3752  27605				    noeor
   3753  27605			85 40		       sta	rand
   3754  27607			45 41		       eor	rand16
   3755  27609			60		       rts
   3756  2760a
   3757  2760a							; *** bcd conversion routine courtesy Omegamatrix
   3758  2760a							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3759  2760a				   -	       ifconst	.calledfunction_converttobcd
   3760  2760a				   -converttobcd
   3761  2760a				   -			;value to convert is in the accumulator
   3762  2760a				   -	       sta	temp1
   3763  2760a				   -	       lsr
   3764  2760a				   -	       adc	temp1
   3765  2760a				   -	       ror
   3766  2760a				   -	       lsr
   3767  2760a				   -	       lsr
   3768  2760a				   -	       adc	temp1
   3769  2760a				   -	       ror
   3770  2760a				   -	       adc	temp1
   3771  2760a				   -	       ror
   3772  2760a				   -	       lsr
   3773  2760a				   -	       and	#$3C
   3774  2760a				   -	       sta	temp2
   3775  2760a				   -	       lsr
   3776  2760a				   -	       adc	temp2
   3777  2760a				   -	       adc	temp1
   3778  2760a				   -	       rts		; return the result in the accumulator
   3779  2760a					       endif		; .calledfunction_converttobcd
   3780  2760a
   3781  2760a				   -	       ifconst	.calledfunction_mul8
   3782  2760a				   -			; Y and A contain multiplicands, result in A
   3783  2760a				   -mul8
   3784  2760a				   -	       sty	temp1
   3785  2760a				   -	       sta	temp2
   3786  2760a				   -	       lda	#0
   3787  2760a				   -reptmul8
   3788  2760a				   -	       lsr	temp2
   3789  2760a				   -	       bcc	skipmul8
   3790  2760a				   -	       clc
   3791  2760a				   -	       adc	temp1
   3792  2760a				   -			;bcs donemul8 might save cycles?
   3793  2760a				   -skipmul8
   3794  2760a				   -			;beq donemul8 might save cycles?
   3795  2760a				   -	       asl	temp1
   3796  2760a				   -	       bne	reptmul8
   3797  2760a				   -donemul8
   3798  2760a				   -	       rts
   3799  2760a					       endif		; .calledfunction_mul8
   3800  2760a
   3801  2760a				   -	       ifconst	.calledfunction_div8
   3802  2760a				   -div8
   3803  2760a				   -			; A=numerator Y=denominator, result in A
   3804  2760a				   -	       cpy	#2
   3805  2760a				   -	       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3806  2760a				   -	       sty	temp1
   3807  2760a				   -	       ldy	#$ff
   3808  2760a				   -div8loop
   3809  2760a				   -	       sbc	temp1
   3810  2760a				   -	       iny
   3811  2760a				   -	       bcs	div8loop
   3812  2760a				   -div8end
   3813  2760a				   -	       tya
   3814  2760a				   -			; result in A
   3815  2760a				   -	       rts
   3816  2760a					       endif		; .calledfunction_div8
   3817  2760a
   3818  2760a				   -	       ifconst	.calledfunction_mul16
   3819  2760a				   -			; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3820  2760a				   -mul16
   3821  2760a				   -	       sty	temp1
   3822  2760a				   -	       sta	temp2
   3823  2760a				   -
   3824  2760a				   -	       lda	#0
   3825  2760a				   -	       ldx	#8
   3826  2760a				   -	       lsr	temp1
   3827  2760a				   -mul16_1
   3828  2760a				   -	       bcc	mul16_2
   3829  2760a				   -	       clc
   3830  2760a				   -	       adc	temp2
   3831  2760a				   -mul16_2
   3832  2760a				   -	       ror
   3833  2760a				   -	       ror	temp1
   3834  2760a				   -	       dex
   3835  2760a				   -	       bne	mul16_1
   3836  2760a				   -	       sta	temp2
   3837  2760a				   -	       rts
   3838  2760a					       endif		; .calledfunction_mul16
   3839  2760a
   3840  2760a				   -	       ifconst	.calledfunction_div16
   3841  2760a				   -			; div int/int
   3842  2760a				   -			; numerator in A, denom in temp1
   3843  2760a				   -			; returns with quotient in A, remainder in temp1
   3844  2760a				   -div16
   3845  2760a				   -	       sta	temp2
   3846  2760a				   -	       sty	temp1
   3847  2760a				   -	       lda	#0
   3848  2760a				   -	       ldx	#8
   3849  2760a				   -	       asl	temp2
   3850  2760a				   -div16_1
   3851  2760a				   -	       rol
   3852  2760a				   -	       cmp	temp1
   3853  2760a				   -	       bcc	div16_2
   3854  2760a				   -	       sbc	temp1
   3855  2760a				   -div16_2
   3856  2760a				   -	       rol	temp2
   3857  2760a				   -	       dex
   3858  2760a				   -	       bne	div16_1
   3859  2760a				   -	       sta	temp1
   3860  2760a				   -	       lda	temp2
   3861  2760a				   -	       rts
   3862  2760a					       endif		; .calledfunction_div16
   3863  2760a
   3864  2760a					       ifconst	bankswitchmode
   3865  2760a				    BS_jsr
   3866  2760a				   -	       ifconst	dumpbankswitch
   3867  2760a				   -	       sta	dumpbankswitch
   3868  2760a					       endif
   3869  2760a				   -	       ifconst	MCPDEVCART
   3870  2760a				   -	       ora	#$18
   3871  2760a				   -	       sta	$3000
   3872  2760a					       else
   3873  2760a			8d 00 80	       sta	$8000
   3874  2760d					       endif
   3875  2760d			68		       pla
   3876  2760e			aa		       tax
   3877  2760f			68		       pla
   3878  27610			60		       rts
   3879  27611
   3880  27611				    BS_return
   3881  27611			68		       pla		; bankswitch bank
   3882  27612				   -	       ifconst	dumpbankswitch
   3883  27612				   -	       sta	dumpbankswitch
   3884  27612					       endif
   3885  27612				   -	       ifconst	BANKRAM
   3886  27612				   -	       sta	currentbank
   3887  27612				   -	       ora	currentrambank
   3888  27612					       endif
   3889  27612				   -	       ifconst	MCPDEVCART
   3890  27612				   -	       ora	#$18
   3891  27612				   -	       sta	$3000
   3892  27612					       else
   3893  27612			8d 00 80	       sta	$8000
   3894  27615					       endif
   3895  27615			68		       pla		; bankswitch $0 flag
   3896  27616			60		       rts
   3897  27617					       endif
   3898  27617
   3899  27617				    checkselectswitch
   3900  27617			ad 82 02	       lda	SWCHB	; check the real select switch...
   3901  2761a			29 02		       and	#%00000010
   3902  2761c				    checkselectswitchreturn
   3903  2761c			60		       rts
   3904  2761d
   3905  2761d				    checkresetswitch
   3906  2761d			ad 82 02	       lda	SWCHB	; check the real reset switch...
   3907  27620			29 01		       and	#%00000001
   3908  27622			60		       rts
   3909  27623
   3910  27623				   -	       ifconst	FINESCROLLENABLED
   3911  27623				   -finescrolldlls
   3912  27623				   -	       ldx	temp1	; first DLL index x3
   3913  27623				   -	       lda	DLLMEM,x
   3914  27623				   -	       and	#%11110000
   3915  27623				   -	       ora	finescrolly
   3916  27623				   -	       sta	DLLMEM,x
   3917  27623				   -
   3918  27623				   -	       ldx	temp2	; last DLL index x3
   3919  27623				   -	       lda	DLLMEM,x
   3920  27623				   -	       and	#%11110000
   3921  27623				   -	       ora	finescrolly
   3922  27623				   -	       eor	#(WZONEHEIGHT-1)
   3923  27623				   -	       sta	DLLMEM,x
   3924  27623				   -	       rts
   3925  27623					       endif		; FINESCROLLENABLED
   3926  27623
   3927  27623				   -	       ifconst	USED_ADJUSTVISIBLE
   3928  27623				   -adjustvisible
   3929  27623				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3930  27623				   -	       jsr	waitforvblankstart	; ensure vblank just started
   3931  27623				   -	       ldx	visibleDLLstart
   3932  27623				   -findfirstinterrupt
   3933  27623				   -	       lda	DLLMEM,x
   3934  27623				   -	       bmi	foundfirstinterrupt
   3935  27623				   -	       inx
   3936  27623				   -	       inx
   3937  27623				   -	       inx
   3938  27623				   -	       bne	findfirstinterrupt
   3939  27623				   -foundfirstinterrupt
   3940  27623				   -	       and	#%01111111	; clear the interrupt bit
   3941  27623				   -	       sta	DLLMEM,x
   3942  27623				   -	       ifconst	DOUBLEBUFFER
   3943  27623				   -	       sta	DLLMEM+DBOFFSET,x
   3944  27623				   -	       endif		; DOUBLEBUFFER
   3945  27623				   -	       ldx	overscanDLLstart
   3946  27623				   -findlastinterrupt
   3947  27623				   -	       lda	DLLMEM,x
   3948  27623				   -	       bmi	foundlastinterrupt
   3949  27623				   -	       dex
   3950  27623				   -	       dex
   3951  27623				   -	       dex
   3952  27623				   -	       bne	findlastinterrupt
   3953  27623				   -foundlastinterrupt
   3954  27623				   -	       and	#%01111111	; clear the interrupt bit
   3955  27623				   -	       sta	DLLMEM,x
   3956  27623				   -	       ifconst	DOUBLEBUFFER
   3957  27623				   -	       sta	DLLMEM+DBOFFSET,x
   3958  27623				   -	       endif		; DOUBLEBUFFER
   3959  27623				   -			;now we need to set the new interrupts
   3960  27623				   -	       clc
   3961  27623				   -	       lda	temp1
   3962  27623				   -	       adc	visibleDLLstart
   3963  27623				   -	       tax
   3964  27623				   -	       lda	DLLMEM,x
   3965  27623				   -	       ora	#%10000000
   3966  27623				   -	       sta	DLLMEM,x
   3967  27623				   -	       ifconst	DOUBLEBUFFER
   3968  27623				   -	       sta	DLLMEM+DBOFFSET,x
   3969  27623				   -	       endif		; DOUBLEBUFFER
   3970  27623				   -	       clc
   3971  27623				   -	       lda	temp2
   3972  27623				   -	       adc	visibleDLLstart
   3973  27623				   -	       tax
   3974  27623				   -	       lda	DLLMEM,x
   3975  27623				   -	       ora	#%10000000
   3976  27623				   -	       sta	DLLMEM,x
   3977  27623				   -	       ifconst	DOUBLEBUFFER
   3978  27623				   -	       sta	DLLMEM+DBOFFSET,x
   3979  27623				   -	       endif		; DOUBLEBUFFER
   3980  27623				   -	       jsr	vblankresync
   3981  27623				   -	       rts
   3982  27623					       endif		; USED_ADJUSTVISIBLE
   3983  27623
   3984  27623				    vblankresync
   3985  27623			20 93 f6	       jsr	waitforvblankstart	; ensure vblank just started
   3986  27626			a9 00		       lda	#0
   3987  27628			85 4d		       sta	visibleover
   3988  2762a			a9 03		       lda	#3
   3989  2762c			8d b2 01	       sta	interruptindex
   3990  2762f			60		       rts
   3991  27630
   3992  27630				    createallgamedlls
   3993  27630			a0 3c		       ldy	#(DLLLUTEND-DLLLUT)
   3994  27632				    createallgamedllsloop
   3995  27632			88		       dey
   3996  27633			b9 57 f6	       lda	DLLLUT,y
   3997  27636			99 00 18	       sta	DLLMEM,y
   3998  27639				   -	       ifconst	DOUBLEBUFFER
   3999  27639				   -	       sta	DLLMEM+DBOFFSET,y
   4000  27639					       endif		; DOUBLEBUFFER
   4001  27639			c0 00		       cpy	#0
   4002  2763b			d0 f5		       bne	createallgamedllsloop
   4003  2763d
   4004  2763d				   -	       ifconst	DOUBLEBUFFER
   4005  2763d				   -	       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   4006  2763d				   -fixdoublebuffer
   4007  2763d				   -	       dey
   4008  2763d				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4009  2763d				   -	       clc
   4010  2763d				   -	       adc	#DOUBLEBUFFEROFFSET
   4011  2763d				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4012  2763d				   -	       dey
   4013  2763d				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4014  2763d				   -	       adc	#0
   4015  2763d				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4016  2763d				   -	       dey
   4017  2763d				   -	       bne	fixdoublebuffer
   4018  2763d					       endif
   4019  2763d
   4020  2763d				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   4021  2763d				   -			; N.B. banksets doesn't in-fact allow DL in cart-ram, so this conditional
   4022  2763d				   -			; is always skipped. This is here in case some day the limitation is
   4023  2763d				   -			; worked around, but it's untested. 
   4024  2763d				   -
   4025  2763d				   -			; With bankset cart ram, we added $8000 to the DL address so plot 
   4026  2763d				   -			; functions would hit the cart-ram write-address. We need to subtract $80
   4027  2763d				   -			; so Maria will read from the cart-ram read-address.
   4028  2763d				   -	       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   4029  2763d				   -fixbanksetaddresses
   4030  2763d				   -	       dey
   4031  2763d				   -	       dey
   4032  2763d				   -	       lda	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   4033  2763d				   -	       and	#%01111111
   4034  2763d				   -	       sta	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   4035  2763d				   -	       ifconst	DOUBLEBUFFER
   4036  2763d				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4037  2763d				   -	       and	#%01111111
   4038  2763d				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4039  2763d				   -	       endif		; DOUBLEBUFFER
   4040  2763d				   -	       dey
   4041  2763d				   -	       bne	fixbanksetaddresses
   4042  2763d					       endif		; BANKSET_DL_IN_CARTRAM
   4043  2763d
   4044  2763d			ad 09 21	       lda	paldetected
   4045  27640			f0 0a		       beq	skippaladjust
   4046  27642			a9 4f		       lda	#($0F|(WZONEHEIGHT*4))	; +15 lines
   4047  27644			8d 06 18	       sta	DLLMEM+6
   4048  27647				   -	       ifconst	DOUBLEBUFFER
   4049  27647				   -	       sta	DLLMEM+DBOFFSET+6
   4050  27647					       endif
   4051  27647					       if	WSCREENHEIGHT = 192
   4052  27647			a9 4d		       lda	#($0D|(WZONEHEIGHT*4))	; +6 lines
   4053  27649				   -	       else
   4054  27649				   -	       lda	#($07|(WZONEHEIGHT*4))	; +6 lines
   4055  27649					       endif		; 
   4056  27649			8d 03 18	       sta	DLLMEM+3
   4057  2764c				   -	       ifconst	DOUBLEBUFFER
   4058  2764c				   -	       sta	DLLMEM+DBOFFSET+3
   4059  2764c					       endif		; DOUBLEBUFFER
   4060  2764c
   4061  2764c				    skippaladjust
   4062  2764c
   4063  2764c							; save the DL markers...
   4064  2764c			a9 09		       lda	#(DLLLUTVISSTART-DLLLUT)
   4065  2764e			8d 3c 21	       sta	visibleDLLstart
   4066  27651			a9 2d		       lda	#(DLLLUTNONVISSTART-DLLLUT)
   4067  27653			8d 3d 21	       sta	overscanDLLstart
   4068  27656			60		       rts
   4069  27657
   4070  27657							; N.B. max DLL length is 112 bytes (for double-buffered)
   4071  27657
   4072  27657				    DLLLUT
   4073  27657					       if	WSCREENHEIGHT = 192
   4074  27657			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4075  2765a			47 21 00	       .byte.b	($07|(WZONEHEIGHT*4)),$21,$00	;  8 blank lines
   4076  2765d			40 21 00	       .byte.b	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4077  27660							;=25 blank lines
   4078  27660					       endif		; WSCREENHEIGHT = 192
   4079  27660				   -	       if	WSCREENHEIGHT = 208
   4080  27660				   -	       .byte	($0E|(WZONEHEIGHT*4)),$21,$00	; 15 blank lines
   4081  27660				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   4082  27660				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4083  27660				   -			;=17 blank lines
   4084  27660					       endif		; WSCREENHEIGHT = 208
   4085  27660				   -	       if	WSCREENHEIGHT = 224
   4086  27660				   -	       .byte	($06|(WZONEHEIGHT*4)),$21,$00	;  7 blank lines
   4087  27660				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   4088  27660				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4089  27660				   -			;= 9 blank lines
   4090  27660					       endif		; WSCREENHEIGHT = 224
   4091  27660
   4092  27660				    DLLLUTVISSTART
   4093  27660			cf 18 80	       .byte.b	($80|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE0ADDRESS,<ZONE0ADDRESS
   4094  27663							;	 ^--NMI 1: start of visible
   4095  27663			4f 19 20	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE1ADDRESS,<ZONE1ADDRESS
   4096  27666			4f 19 c0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE2ADDRESS,<ZONE2ADDRESS
   4097  27669			4f 1a 60	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE3ADDRESS,<ZONE3ADDRESS
   4098  2766c			4f 1b 00	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE4ADDRESS,<ZONE4ADDRESS
   4099  2766f			4f 1b a0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE5ADDRESS,<ZONE5ADDRESS
   4100  27672			4f 1c 40	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE6ADDRESS,<ZONE6ADDRESS
   4101  27675			4f 1c e0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE7ADDRESS,<ZONE7ADDRESS
   4102  27678			4f 1d 80	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE8ADDRESS,<ZONE8ADDRESS
   4103  2767b			4f 1e 20	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE9ADDRESS,<ZONE9ADDRESS
   4104  2767e			4f 1e c0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE10ADDRESS,<ZONE10ADDRESS
   4105  27681			4f 1f 60	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE11ADDRESS,<ZONE11ADDRESS
   4106  27684				   -	       ifconst	ZONE12ADDRESS
   4107  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE12ADDRESS,<ZONE12ADDRESS
   4108  27684					       endif
   4109  27684				   -	       ifconst	ZONE13ADDRESS
   4110  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE13ADDRESS,<ZONE13ADDRESS
   4111  27684					       endif
   4112  27684				   -	       ifconst	ZONE14ADDRESS
   4113  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE14ADDRESS,<ZONE14ADDRESS
   4114  27684					       endif
   4115  27684				   -	       ifconst	ZONE15ADDRESS
   4116  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE15ADDRESS,<ZONE15ADDRESS
   4117  27684					       endif
   4118  27684				   -	       ifconst	ZONE16ADDRESS
   4119  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE16ADDRESS,<ZONE16ADDRESS
   4120  27684					       endif
   4121  27684				   -	       ifconst	ZONE17ADDRESS
   4122  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE17ADDRESS,<ZONE17ADDRESS
   4123  27684					       endif
   4124  27684				   -	       ifconst	ZONE18ADDRESS
   4125  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE18ADDRESS,<ZONE18ADDRESS
   4126  27684					       endif
   4127  27684				   -	       ifconst	ZONE19ADDRESS
   4128  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE19ADDRESS,<ZONE19ADDRESS
   4129  27684					       endif
   4130  27684				   -	       ifconst	ZONE20ADDRESS
   4131  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE20ADDRESS,<ZONE20ADDRESS
   4132  27684					       endif
   4133  27684				   -	       ifconst	ZONE21ADDRESS
   4134  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE21ADDRESS,<ZONE21ADDRESS
   4135  27684					       endif
   4136  27684				   -	       ifconst	ZONE22ADDRESS
   4137  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE22ADDRESS,<ZONE22ADDRESS
   4138  27684					       endif
   4139  27684				   -	       ifconst	ZONE23ADDRESS
   4140  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE23ADDRESS,<ZONE23ADDRESS
   4141  27684					       endif
   4142  27684				   -	       ifconst	ZONE24ADDRESS
   4143  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE24ADDRESS,<ZONE24ADDRESS
   4144  27684					       endif
   4145  27684				   -	       ifconst	ZONE25ADDRESS
   4146  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE25ADDRESS,<ZONE25ADDRESS
   4147  27684					       endif
   4148  27684				   -	       ifconst	ZONE26ADDRESS
   4149  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE26ADDRESS,<ZONE26ADDRESS
   4150  27684					       endif
   4151  27684				   -	       ifconst	ZONE27ADDRESS
   4152  27684				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE27ADDRESS,<ZONE27ADDRESS
   4153  27684					       endif
   4154  27684				    DLLLUTNONVISSTART
   4155  27684			c3 21 00	       .byte.b	($83|(WZONEHEIGHT*4)),$21,$00	;  4 blank lines
   4156  27687							;	 ^--NMI 2: start of non-visible
   4157  27687			cf 21 00	       .byte.b	($8F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4158  2768a							;	 ^--NMI 3: start of overscan
   4159  2768a			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4160  2768d			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4161  27690			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4162  27693				    DLLLUTEND
   4163  27693							;echo "DLL size: ",[(DLLLUTEND-DLLLUT)]d,"bytes"
   4164  27693							;echo "DLL code size: ",[(DLLLUTEND-createallgamedlls)]d,"bytes"
   4165  27693
   4166  27693				    waitforvblankstart
   4167  27693				    vblankendwait
   4168  27693			24 28		       BIT	MSTAT
   4169  27695			30 fc		       bmi	vblankendwait
   4170  27697				    vblankstartwait
   4171  27697			24 28		       BIT	MSTAT
   4172  27699			10 fc		       bpl	vblankstartwait
   4173  2769b			60		       rts
   4174  2769c
   4175  2769c				   -	       ifconst	DOUBLEBUFFER
   4176  2769c				   -flipdisplaybufferreturn
   4177  2769c				   -	       rts
   4178  2769c				   -flipdisplaybuffer
   4179  2769c				   -	       ifconst	interrupthold
   4180  2769c				   -	       lda	#$FF
   4181  2769c				   -	       sta	interrupthold
   4182  2769c				   -	       endif
   4183  2769c				   -	       lda	doublebufferstate
   4184  2769c				   -	       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4185  2769c				   -
   4186  2769c				   -	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4187  2769c				   -
   4188  2769c				   -	       lda	doublebufferstate
   4189  2769c				   -	       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4190  2769c				   -	       tax
   4191  2769c				   -
   4192  2769c				   -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4193  2769c				   -
   4194  2769c				   -flipdisplaybufferwait1
   4195  2769c				   -	       lda	visibleover
   4196  2769c				   -	       beq	flipdisplaybufferwait1
   4197  2769c				   -
   4198  2769c				   -flipdisplaybufferwait
   4199  2769c				   -	       lda	visibleover
   4200  2769c				   -	       bne	flipdisplaybufferwait
   4201  2769c				   -
   4202  2769c				   -	       lda	doublebufferminimumframetarget
   4203  2769c				   -	       beq	skipminimumframecode
   4204  2769c				   -	       lda	doublebufferminimumframeindex
   4205  2769c				   -	       bne	flipdisplaybufferwait1
   4206  2769c				   -	       lda	doublebufferminimumframetarget
   4207  2769c				   -	       sta	doublebufferminimumframeindex
   4208  2769c				   -skipminimumframecode
   4209  2769c				   -
   4210  2769c				   -	       lda	DLLMEMLutHi,x
   4211  2769c				   -	       sta	DPPH
   4212  2769c				   -	       lda	DLLMEMLutLo,x
   4213  2769c				   -	       sta	DPPL
   4214  2769c				   -
   4215  2769c				   -	       lda	NewPageflipstate,x
   4216  2769c				   -	       sta	doublebufferstate
   4217  2769c				   -	       lda	NewPageflipoffset,x
   4218  2769c				   -	       sta	doublebufferdloffset
   4219  2769c				   -
   4220  2769c				   -	       ifnconst	BANKSET_DL_IN_CARTRAM
   4221  2769c				   -	       lda	doublebufferbufferdirty
   4222  2769c				   -	       beq	flipdisplaybufferreturn
   4223  2769c				   -
   4224  2769c				   -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4225  2769c				   -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4226  2769c				   -			; from the displayed buffer to the working buffer...
   4227  2769c				   -
   4228  2769c				   -	       lda	doublebufferdloffset
   4229  2769c				   -	       eor	#DOUBLEBUFFEROFFSET
   4230  2769c				   -	       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4231  2769c				   -
   4232  2769c				   -	       ldx	#(WZONECOUNT-1)
   4233  2769c				   -copybufferzoneloop
   4234  2769c				   -
   4235  2769c				   -	       lda	DLPOINTL,x
   4236  2769c				   -	       clc
   4237  2769c				   -	       adc	doublebufferdloffset
   4238  2769c				   -	       sta	temp1
   4239  2769c				   -	       lda	DLPOINTH,x
   4240  2769c				   -	       adc	#0
   4241  2769c				   -	       sta	temp2
   4242  2769c				   -
   4243  2769c				   -	       lda	DLPOINTL,x
   4244  2769c				   -	       clc
   4245  2769c				   -	       adc	temp6
   4246  2769c				   -	       sta	temp3
   4247  2769c				   -	       lda	DLPOINTH,x
   4248  2769c				   -	       adc	#0
   4249  2769c				   -	       sta	temp4
   4250  2769c				   -
   4251  2769c				   -	       lda	dlendsave,x
   4252  2769c				   -	       tay
   4253  2769c				   -copybuffercharsloop
   4254  2769c				   -	       lda	(temp3),y
   4255  2769c				   -	       sta	(temp1),y
   4256  2769c				   -	       dey
   4257  2769c				   -	       bpl	copybuffercharsloop
   4258  2769c				   -	       dex
   4259  2769c				   -	       bpl	copybufferzoneloop
   4260  2769c				   -	       lda	#0
   4261  2769c				   -	       sta	doublebufferbufferdirty
   4262  2769c				   -	       endif		; ! BANKSET_DL_IN_CARTRAM
   4263  2769c				   -	       rts
   4264  2769c				   -
   4265  2769c				   -doublebufferoff
   4266  2769c				   -	       lda	#1
   4267  2769c				   -	       sta	doublebufferstate
   4268  2769c				   -	       jsr	flipdisplaybuffer
   4269  2769c				   -	       lda	#0
   4270  2769c				   -	       sta	doublebufferstate
   4271  2769c				   -	       sta	doublebufferdloffset
   4272  2769c				   -	       rts
   4273  2769c				   -
   4274  2769c				   -DLLMEMLutLo
   4275  2769c				   -	       .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   4276  2769c				   -DLLMEMLutHi
   4277  2769c				   -	       .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   4278  2769c				   -NewPageflipstate
   4279  2769c				   -	       .byte	3,1
   4280  2769c				   -NewPageflipoffset
   4281  2769c				   -	       .byte	DOUBLEBUFFEROFFSET,0
   4282  2769c				   -
   4283  2769c					       endif		; DOUBLEBUFFER
   4284  2769c
   4285  2769c				   -	       ifconst	MOUSESUPPORT
   4286  2769c				   -
   4287  2769c				   -rotationalcompare
   4288  2769c				   -			; old = 00 01 10 11
   4289  2769c				   -	       .byte	$00, $01, $ff, $00	; new=00
   4290  2769c				   -	       .byte	$ff, $00, $00, $01	; new=01
   4291  2769c				   -	       .byte	$01, $00, $00, $ff	; new=10
   4292  2769c				   -	       .byte	$00, $ff, $01, $00	; new=11
   4293  2769c				   -
   4294  2769c				   -			; 0000YyXx st mouse
   4295  2769c				   -
   4296  2769c				   -			; 0000xyXY amiga mouse
   4297  2769c				   -
   4298  2769c				   -	       ifconst	MOUSEXONLY
   4299  2769c				   -amigatoataribits		; swap bits 1 and 4...
   4300  2769c				   -	       .byte	%0000, %0000, %0010, %0010
   4301  2769c				   -	       .byte	%0000, %0000, %0010, %0010
   4302  2769c				   -	       .byte	%0001, %0001, %0011, %0011
   4303  2769c				   -	       .byte	%0001, %0001, %0011, %0011
   4304  2769c				   -
   4305  2769c				   -			; null change bits
   4306  2769c				   -	       .byte	%0000, %0001, %0010, %0011
   4307  2769c				   -	       .byte	%0000, %0001, %0010, %0011
   4308  2769c				   -	       .byte	%0000, %0001, %0010, %0011
   4309  2769c				   -	       .byte	%0000, %0001, %0010, %0011
   4310  2769c				   -
   4311  2769c				   -	       else		; !MOUSEXONLY
   4312  2769c				   -
   4313  2769c				   -amigatoataribits		; swap bits 1 and 4...
   4314  2769c				   -	       .byte	%0000, %1000, %0010, %1010
   4315  2769c				   -	       .byte	%0100, %1100, %0110, %1110
   4316  2769c				   -	       .byte	%0001, %1001, %0011, %1011
   4317  2769c				   -	       .byte	%0101, %1101, %0111, %1111
   4318  2769c				   -			; null change bits
   4319  2769c				   -	       .byte	%0000, %0001, %0010, %0011
   4320  2769c				   -	       .byte	%0100, %0101, %0110, %0111
   4321  2769c				   -	       .byte	%1000, %1001, %1010, %1011
   4322  2769c				   -	       .byte	%1100, %1101, %1110, %1111
   4323  2769c				   -	       endif		; !MOUSEXONLY
   4324  2769c				   -
   4325  2769c					       endif		; MOUSESUPPORT
   4326  2769c
   4327  2769c				    mouse0update
   4328  2769c				   -	       ifconst	MOUSE0SUPPORT
   4329  2769c				   -
   4330  2769c				   -mousetableselect =	inttemp2
   4331  2769c				   -mousexdelta =	inttemp3
   4332  2769c				   -mouseydelta =	inttemp4
   4333  2769c				   -lastSWCHA  =	inttemp6
   4334  2769c				   -
   4335  2769c				   -			; 0000YyXx st mouse
   4336  2769c				   -			; 0000xyXY amiga mouse
   4337  2769c				   -
   4338  2769c				   -	       lda	#$ff
   4339  2769c				   -	       sta	lastSWCHA
   4340  2769c				   -
   4341  2769c				   -	       ldy	port0control
   4342  2769c				   -
   4343  2769c				   -	       lda	#%00010000
   4344  2769c				   -	       cpy	#9	; AMIGA?
   4345  2769c				   -	       bne	skipamigabitsfix0
   4346  2769c				   -	       lda	#0
   4347  2769c				   -skipamigabitsfix0
   4348  2769c				   -	       sta	mousetableselect
   4349  2769c				   -	       ifconst	DRIVINGBOOST
   4350  2769c				   -	       cpy	#6	; DRIVING?
   4351  2769c				   -	       bne	skipdriving0setup
   4352  2769c				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   4353  2769c				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   4354  2769c				   -			; the actual position. This actual position is stored in mousey0 
   4355  2769c				   -			; after the driver has run.
   4356  2769c				   -	       ldx	mousex0
   4357  2769c				   -	       lda	mousey0
   4358  2769c				   -	       stx	mousey0
   4359  2769c				   -	       sta	mousex0
   4360  2769c				   -skipdriving0setup
   4361  2769c				   -	       endif		; DRIVINGBOOST
   4362  2769c				   -
   4363  2769c				   -	       lda	#0
   4364  2769c				   -	       sta	mousexdelta
   4365  2769c				   -	       sta	mouseydelta
   4366  2769c				   -
   4367  2769c				   -	       ifnconst	MOUSETIME
   4368  2769c				   -	       ifnconst	MOUSEXONLY
   4369  2769c				   -	       lda	#180	; minimum for x+y
   4370  2769c				   -	       else
   4371  2769c				   -	       lda	#100	; minimum for just x
   4372  2769c				   -	       endif
   4373  2769c				   -	       else
   4374  2769c				   -	       lda	#MOUSETIME
   4375  2769c				   -	       endif
   4376  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   4377  2769c				   -
   4378  2769c				   -mouse0updateloop
   4379  2769c				   -	       lda	SWCHA
   4380  2769c				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4381  2769c				   -	       cmp	lastSWCHA
   4382  2769c				   -	       beq	mouse0loopcondition
   4383  2769c				   -	       sta	lastSWCHA
   4384  2769c				   -	       lsr
   4385  2769c				   -	       lsr
   4386  2769c				   -	       lsr
   4387  2769c				   -
   4388  2769c				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4389  2769c				   -
   4390  2769c				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4391  2769c				   -			; 0000YyXx st mouse
   4392  2769c				   -			; 0000xyXY amiga mouse
   4393  2769c				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4394  2769c				   -	       tay
   4395  2769c				   -	       lax	amigatoataribits,y
   4396  2769c				   -
   4397  2769c				   -	       ifnconst	MOUSEXONLY
   4398  2769c				   -			; first the Y...
   4399  2769c				   -	       and	#%00001100
   4400  2769c				   -	       ora	mousecodey0
   4401  2769c				   -	       tay
   4402  2769c				   -	       lda	rotationalcompare,y
   4403  2769c				   -	       clc
   4404  2769c				   -	       adc	mouseydelta
   4405  2769c				   -	       sta	mouseydelta
   4406  2769c				   -	       tya
   4407  2769c				   -	       lsr
   4408  2769c				   -	       lsr
   4409  2769c				   -	       sta	mousecodey0
   4410  2769c				   -	       txa
   4411  2769c				   -			; ...then the X...
   4412  2769c				   -	       and	#%00000011
   4413  2769c				   -	       tax
   4414  2769c				   -	       endif		; !MOUSEXONLY
   4415  2769c				   -
   4416  2769c				   -	       asl
   4417  2769c				   -	       asl
   4418  2769c				   -	       ora	mousecodex0
   4419  2769c				   -	       tay
   4420  2769c				   -	       lda	rotationalcompare,y
   4421  2769c				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4422  2769c				   -	       sta	mousexdelta
   4423  2769c				   -	       stx	mousecodex0
   4424  2769c				   -mouse0loopcondition
   4425  2769c				   -	       lda	TIMINT
   4426  2769c				   -	       bpl	mouse0updateloop
   4427  2769c				   -
   4428  2769c				   -			; *** adapt to selected device resolution. 
   4429  2769c				   -	       ldx	port0control
   4430  2769c				   -
   4431  2769c				   -	       ifconst	PRECISIONMOUSING
   4432  2769c				   -	       ldy	port0resolution
   4433  2769c				   -	       bne	mouse0halveddone
   4434  2769c				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4435  2769c				   -	       beq	mouse0halveddone
   4436  2769c				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4437  2769c				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4438  2769c				   -
   4439  2769c				   -	       lda	mousexdelta
   4440  2769c				   -	       cmp	#$80
   4441  2769c				   -	       ror		; do a signed divide by 2.
   4442  2769c				   -	       clc
   4443  2769c				   -	       adc	mousex0
   4444  2769c				   -	       sta	mousex0
   4445  2769c				   -	       ifnconst	MOUSEXONLY
   4446  2769c				   -	       lda	mouseydelta
   4447  2769c				   -	       clc
   4448  2769c				   -	       adc	mousey0
   4449  2769c				   -	       sta	mousey0
   4450  2769c				   -	       endif
   4451  2769c				   -			; at half resolution we just exit after updating x and y
   4452  2769c				   -	       jmp	LLRET0
   4453  2769c				   -mouse0halveddone
   4454  2769c				   -	       endif		; PRECISIONMOUSING
   4455  2769c				   -
   4456  2769c				   -	       ifnconst	MOUSEXONLY
   4457  2769c				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4458  2769c				   -	       ldy	port0resolution
   4459  2769c				   -	       dey
   4460  2769c				   -	       lda	#0
   4461  2769c				   -mousey0resolutionfix
   4462  2769c				   -	       clc
   4463  2769c				   -	       adc	mouseydelta
   4464  2769c				   -	       dey
   4465  2769c				   -	       bpl	mousey0resolutionfix
   4466  2769c				   -	       clc
   4467  2769c				   -	       adc	mousey0
   4468  2769c				   -	       sta	mousey0
   4469  2769c				   -	       endif		; MOUSEXONLY
   4470  2769c				   -
   4471  2769c				   -	       ldy	port0resolution
   4472  2769c				   -	       dey
   4473  2769c				   -	       lda	#0
   4474  2769c				   -mousex0resolutionfix
   4475  2769c				   -	       clc
   4476  2769c				   -	       adc	mousexdelta
   4477  2769c				   -	       dey
   4478  2769c				   -	       bpl	mousex0resolutionfix
   4479  2769c				   -	       ifnconst	DRIVINGBOOST
   4480  2769c				   -	       clc
   4481  2769c				   -	       adc	mousex0
   4482  2769c				   -	       sta	mousex0
   4483  2769c				   -	       else
   4484  2769c				   -	       cpx	#6
   4485  2769c				   -	       beq	carryonmouse0boost
   4486  2769c				   -	       clc
   4487  2769c				   -	       adc	mousex0
   4488  2769c				   -	       sta	mousex0
   4489  2769c				   -	       jmp	LLRET0
   4490  2769c				   -carryonmouse0boost
   4491  2769c				   -	       sta	mousexdelta
   4492  2769c				   -	       clc
   4493  2769c				   -	       adc	mousecodey0
   4494  2769c				   -	       sta	mousecodey0
   4495  2769c				   -	       clc
   4496  2769c				   -	       adc	mousex0
   4497  2769c				   -	       tay		; save the target X
   4498  2769c				   -	       adc	mousey0	; average in the smoothly-trailing X
   4499  2769c				   -	       ror
   4500  2769c				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   4501  2769c				   -	       sty	mousey0	; and mousey0 has the the target X
   4502  2769c				   -
   4503  2769c				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4504  2769c				   -			; A has mousex0, the smoothly trailing X
   4505  2769c				   -	       sbc	mousey0	; less the target X
   4506  2769c				   -	       bpl	skipabsolutedrive0
   4507  2769c				   -	       eor	#$ff
   4508  2769c				   -skipabsolutedrive0
   4509  2769c				   -	       cmp	#64	; just an unreasonably large change
   4510  2769c				   -	       bcc	skipdrivewrapfix0
   4511  2769c				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   4512  2769c				   -skipdrivewrapfix0
   4513  2769c				   -
   4514  2769c				   -			; get rid of the tweening if the distance travelled was very small
   4515  2769c				   -	       lda	mousexdelta
   4516  2769c				   -	       cmp	port0resolution
   4517  2769c				   -	       bcs	skipbetweenfix0
   4518  2769c				   -	       lda	mousex0
   4519  2769c				   -	       sta	mousey0
   4520  2769c				   -skipbetweenfix0
   4521  2769c				   -
   4522  2769c				   -drivingboostreductioncheck0
   4523  2769c				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4524  2769c				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4525  2769c				   -			; negated again because truncation during BCD math results in 
   4526  2769c				   -			; differing magnitudes, depending if the value is +ve or -ve.
   4527  2769c				   -driving0fix
   4528  2769c				   -	       lax	mousecodey0
   4529  2769c				   -	       cmp	#$80
   4530  2769c				   -	       bcs	driving0skipnegate1
   4531  2769c				   -	       eor	#$FF
   4532  2769c				   -	       adc	#1
   4533  2769c				   -	       sta	mousecodey0
   4534  2769c				   -driving0skipnegate1
   4535  2769c				   -	       cmp	#$80
   4536  2769c				   -	       ror
   4537  2769c				   -	       cmp	#$80
   4538  2769c				   -	       ror
   4539  2769c				   -	       cmp	#$80
   4540  2769c				   -	       ror
   4541  2769c				   -	       sta	inttemp1
   4542  2769c				   -	       lda	mousecodey0
   4543  2769c				   -	       sec
   4544  2769c				   -	       sbc	inttemp1
   4545  2769c				   -	       cpx	#$80
   4546  2769c				   -	       bcs	driving0skipnegate2
   4547  2769c				   -	       eor	#$FF
   4548  2769c				   -	       adc	#1
   4549  2769c				   -driving0skipnegate2
   4550  2769c				   -	       sta	mousecodey0
   4551  2769c				   -drivingboostdone0
   4552  2769c				   -	       endif		; DRIVINGBOOST
   4553  2769c				   -
   4554  2769c				   -	       jmp	LLRET0
   4555  2769c				   -
   4556  2769c					       endif		; MOUSE0SUPPORT
   4557  2769c
   4558  2769c				    mouse1update
   4559  2769c				   -	       ifconst	MOUSE1SUPPORT
   4560  2769c				   -
   4561  2769c				   -mousetableselect =	inttemp2
   4562  2769c				   -mousexdelta =	inttemp3
   4563  2769c				   -mouseydelta =	inttemp4
   4564  2769c				   -lastSWCHA  =	inttemp6
   4565  2769c				   -
   4566  2769c				   -			; 0000YyXx st mouse
   4567  2769c				   -			; 0000xyXY amiga mouse
   4568  2769c				   -
   4569  2769c				   -	       lda	#$ff
   4570  2769c				   -	       sta	lastSWCHA
   4571  2769c				   -
   4572  2769c				   -	       ldy	port1control
   4573  2769c				   -
   4574  2769c				   -	       lda	#%00010000
   4575  2769c				   -	       cpy	#9	; AMIGA?
   4576  2769c				   -	       bne	skipamigabitsfix1
   4577  2769c				   -	       lda	#0
   4578  2769c				   -skipamigabitsfix1
   4579  2769c				   -	       sta	mousetableselect
   4580  2769c				   -	       ifconst	DRIVINGBOOST
   4581  2769c				   -	       cpy	#6	; DRIVING?
   4582  2769c				   -	       bne	skipdriving1setup
   4583  2769c				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   4584  2769c				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   4585  2769c				   -			; the actual position. This actual position is stored in mousey1 
   4586  2769c				   -			; after the driver has run.
   4587  2769c				   -	       ldx	mousex1
   4588  2769c				   -	       lda	mousey1
   4589  2769c				   -	       stx	mousey1
   4590  2769c				   -	       sta	mousex1
   4591  2769c				   -skipdriving1setup
   4592  2769c				   -	       endif		; DRIVINGBOOST
   4593  2769c				   -
   4594  2769c				   -	       lda	#0
   4595  2769c				   -	       sta	mousexdelta
   4596  2769c				   -	       sta	mouseydelta
   4597  2769c				   -
   4598  2769c				   -	       ifnconst	MOUSETIME
   4599  2769c				   -	       ifnconst	MOUSEXONLY
   4600  2769c				   -	       lda	#180	; minimum for x+y
   4601  2769c				   -	       else
   4602  2769c				   -	       lda	#100	; minimum for just x
   4603  2769c				   -	       endif
   4604  2769c				   -	       else
   4605  2769c				   -	       lda	#MOUSETIME
   4606  2769c				   -	       endif
   4607  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   4608  2769c				   -
   4609  2769c				   -mouse1updateloop
   4610  2769c				   -	       lda	SWCHA
   4611  2769c				   -	       and	#%00001111
   4612  2769c				   -	       cmp	lastSWCHA
   4613  2769c				   -	       beq	mouse1loopcondition
   4614  2769c				   -	       sta	lastSWCHA
   4615  2769c				   -
   4616  2769c				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4617  2769c				   -
   4618  2769c				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4619  2769c				   -			; 0000YyXx st mouse
   4620  2769c				   -			; 0000xyXY amiga mouse
   4621  2769c				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4622  2769c				   -	       tay
   4623  2769c				   -	       lax	amigatoataribits,y
   4624  2769c				   -
   4625  2769c				   -	       ifnconst	MOUSEXONLY
   4626  2769c				   -			; first the Y...
   4627  2769c				   -	       and	#%00001100
   4628  2769c				   -	       ora	mousecodey1
   4629  2769c				   -	       tay
   4630  2769c				   -	       lda	rotationalcompare,y
   4631  2769c				   -	       clc
   4632  2769c				   -	       adc	mouseydelta
   4633  2769c				   -	       sta	mouseydelta
   4634  2769c				   -	       tya
   4635  2769c				   -	       lsr
   4636  2769c				   -	       lsr
   4637  2769c				   -	       sta	mousecodey1
   4638  2769c				   -	       txa
   4639  2769c				   -			; ...then the X...
   4640  2769c				   -	       and	#%00000011
   4641  2769c				   -	       tax
   4642  2769c				   -	       endif		; !MOUSEXONLY
   4643  2769c				   -
   4644  2769c				   -	       asl
   4645  2769c				   -	       asl
   4646  2769c				   -	       ora	mousecodex1
   4647  2769c				   -	       tay
   4648  2769c				   -	       lda	rotationalcompare,y
   4649  2769c				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4650  2769c				   -	       sta	mousexdelta
   4651  2769c				   -	       stx	mousecodex1
   4652  2769c				   -mouse1loopcondition
   4653  2769c				   -	       lda	TIMINT
   4654  2769c				   -	       bpl	mouse1updateloop
   4655  2769c				   -
   4656  2769c				   -			; *** adapt to selected device resolution. 
   4657  2769c				   -	       ldx	port1control
   4658  2769c				   -
   4659  2769c				   -	       ifconst	PRECISIONMOUSING
   4660  2769c				   -	       ldy	port1resolution
   4661  2769c				   -	       bne	mouse1halveddone
   4662  2769c				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4663  2769c				   -	       beq	mouse1halveddone
   4664  2769c				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4665  2769c				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4666  2769c				   -
   4667  2769c				   -	       lda	mousexdelta
   4668  2769c				   -	       cmp	#$80
   4669  2769c				   -	       ror		; do a signed divide by 2.
   4670  2769c				   -	       clc
   4671  2769c				   -	       adc	mousex1
   4672  2769c				   -	       sta	mousex1
   4673  2769c				   -	       ifnconst	MOUSEXONLY
   4674  2769c				   -	       lda	mouseydelta
   4675  2769c				   -	       clc
   4676  2769c				   -	       adc	mousey1
   4677  2769c				   -	       sta	mousey1
   4678  2769c				   -	       endif
   4679  2769c				   -			; at half resolution we just exit after updating x and y
   4680  2769c				   -	       jmp	LLRET1
   4681  2769c				   -mouse1halveddone
   4682  2769c				   -	       endif		; PRECISIONMOUSING
   4683  2769c				   -
   4684  2769c				   -	       ifnconst	MOUSEXONLY
   4685  2769c				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4686  2769c				   -	       ldy	port1resolution
   4687  2769c				   -	       dey
   4688  2769c				   -	       lda	#0
   4689  2769c				   -mousey1resolutionfix
   4690  2769c				   -	       clc
   4691  2769c				   -	       adc	mouseydelta
   4692  2769c				   -	       dey
   4693  2769c				   -	       bpl	mousey1resolutionfix
   4694  2769c				   -	       clc
   4695  2769c				   -	       adc	mousey1
   4696  2769c				   -	       sta	mousey1
   4697  2769c				   -	       endif		; MOUSEXONLY
   4698  2769c				   -
   4699  2769c				   -	       ldy	port1resolution
   4700  2769c				   -	       dey
   4701  2769c				   -	       lda	#0
   4702  2769c				   -mousex1resolutionfix
   4703  2769c				   -	       clc
   4704  2769c				   -	       adc	mousexdelta
   4705  2769c				   -	       dey
   4706  2769c				   -	       bpl	mousex1resolutionfix
   4707  2769c				   -	       ifnconst	DRIVINGBOOST
   4708  2769c				   -	       clc
   4709  2769c				   -	       adc	mousex1
   4710  2769c				   -	       sta	mousex1
   4711  2769c				   -	       else
   4712  2769c				   -	       cpx	#6
   4713  2769c				   -	       beq	carryonmouse1boost
   4714  2769c				   -	       clc
   4715  2769c				   -	       adc	mousex1
   4716  2769c				   -	       sta	mousex1
   4717  2769c				   -	       jmp	LLRET1
   4718  2769c				   -carryonmouse1boost
   4719  2769c				   -	       sta	mousexdelta
   4720  2769c				   -	       clc
   4721  2769c				   -	       adc	mousecodey1
   4722  2769c				   -	       sta	mousecodey1
   4723  2769c				   -	       clc
   4724  2769c				   -	       adc	mousex1
   4725  2769c				   -	       tay		; save the target X
   4726  2769c				   -	       adc	mousey1	; average in the smoothly-trailing X
   4727  2769c				   -	       ror
   4728  2769c				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   4729  2769c				   -	       sty	mousey1	; and mousey0 has the the target X
   4730  2769c				   -
   4731  2769c				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4732  2769c				   -			; A has mousex1, the smoothly trailing X
   4733  2769c				   -	       sbc	mousey1	; less the target X
   4734  2769c				   -	       bpl	skipabsolutedrive1
   4735  2769c				   -	       eor	#$ff
   4736  2769c				   -skipabsolutedrive1
   4737  2769c				   -	       cmp	#64	; just an unreasonably large change
   4738  2769c				   -	       bcc	skipdrivewrapfix1
   4739  2769c				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   4740  2769c				   -skipdrivewrapfix1
   4741  2769c				   -
   4742  2769c				   -			; get rid of the tweening if the distance travelled was very small
   4743  2769c				   -	       lda	mousexdelta
   4744  2769c				   -	       cmp	port1resolution
   4745  2769c				   -	       bcs	skipbetweenfix1
   4746  2769c				   -	       lda	mousex1
   4747  2769c				   -	       sta	mousey1
   4748  2769c				   -skipbetweenfix1
   4749  2769c				   -
   4750  2769c				   -drivingboostreductioncheck1
   4751  2769c				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4752  2769c				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4753  2769c				   -			; negated again because truncation during BCD math results in 
   4754  2769c				   -			; differing magnitudes, depending if the value is +ve or -ve.
   4755  2769c				   -driving1fix
   4756  2769c				   -	       lax	mousecodey1
   4757  2769c				   -	       cmp	#$80
   4758  2769c				   -	       bcs	driving0skipnegate1
   4759  2769c				   -	       eor	#$FF
   4760  2769c				   -	       adc	#1
   4761  2769c				   -	       sta	mousecodey1
   4762  2769c				   -driving0skipnegate1
   4763  2769c				   -	       cmp	#$80
   4764  2769c				   -	       ror
   4765  2769c				   -	       cmp	#$80
   4766  2769c				   -	       ror
   4767  2769c				   -	       cmp	#$80
   4768  2769c				   -	       ror
   4769  2769c				   -	       sta	inttemp1
   4770  2769c				   -	       lda	mousecodey1
   4771  2769c				   -	       sec
   4772  2769c				   -	       sbc	inttemp1
   4773  2769c				   -	       cpx	#$80
   4774  2769c				   -	       bcs	driving1skipnegate2
   4775  2769c				   -	       eor	#$FF
   4776  2769c				   -	       adc	#1
   4777  2769c				   -driving1skipnegate2
   4778  2769c				   -	       sta	mousecodey1
   4779  2769c				   -drivingboostdone1
   4780  2769c				   -	       endif		; DRIVINGBOOST
   4781  2769c				   -
   4782  2769c				   -	       jmp	LLRET1
   4783  2769c				   -
   4784  2769c					       endif		; MOUSE1SUPPORT
   4785  2769c
   4786  2769c
   4787  2769c				    trakball0update
   4788  2769c				   -	       ifconst	TRAKBALL0SUPPORT
   4789  2769c				   -	       ifnconst	TRAKTIME
   4790  2769c				   -	       ifnconst	TRAKXONLY
   4791  2769c				   -	       lda	#180	; minimum for x+y
   4792  2769c				   -	       else		; !TRAKXONLY
   4793  2769c				   -	       lda	#100	; minimum for just x
   4794  2769c				   -	       endif		; !TRAKXONLY
   4795  2769c				   -	       else		; !TRAKTIME
   4796  2769c				   -	       lda	#TRAKTIME
   4797  2769c				   -	       endif		; !TRAKTIME
   4798  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   4799  2769c				   -	       ldx	#0
   4800  2769c				   -	       ifnconst	TRAKXONLY
   4801  2769c				   -	       ldy	#0
   4802  2769c				   -	       endif		; TRAKXONLY
   4803  2769c				   -trakball0updateloop
   4804  2769c				   -	       lda	SWCHA
   4805  2769c				   -	       and	#%00110000
   4806  2769c				   -	       cmp	trakballcodex0
   4807  2769c				   -	       sta	trakballcodex0
   4808  2769c				   -	       beq	trakball0movementXdone
   4809  2769c				   -	       and	#%00010000
   4810  2769c				   -	       beq	trakball0negativeX
   4811  2769c				   -trakball0positiveX
   4812  2769c				   -			;(2 from beq)
   4813  2769c				   -	       inx		; 2
   4814  2769c				   -	       jmp	trakball0movementXdone	; 3
   4815  2769c				   -trakball0negativeX
   4816  2769c				   -			;(3 from beq)
   4817  2769c				   -	       dex		; 2
   4818  2769c				   -	       nop		; 2
   4819  2769c				   -trakball0movementXdone
   4820  2769c				   -
   4821  2769c				   -	       ifnconst	TRAKXONLY
   4822  2769c				   -	       lda	SWCHA
   4823  2769c				   -	       and	#%11000000
   4824  2769c				   -	       cmp	trakballcodey0
   4825  2769c				   -	       sta	trakballcodey0
   4826  2769c				   -	       beq	trakball0movementYdone
   4827  2769c				   -	       and	#%01000000
   4828  2769c				   -	       beq	trakball0negativeY
   4829  2769c				   -trakball0positiveY
   4830  2769c				   -			;(2 from beq)
   4831  2769c				   -	       iny		; 2
   4832  2769c				   -	       jmp	trakball0movementYdone	; 3
   4833  2769c				   -trakball0negativeY
   4834  2769c				   -			;(3 from beq)
   4835  2769c				   -	       dey		; 2
   4836  2769c				   -	       nop		; 2
   4837  2769c				   -trakball0movementYdone
   4838  2769c				   -	       endif		; !TRAKXONLY
   4839  2769c				   -
   4840  2769c				   -	       lda	TIMINT
   4841  2769c				   -	       bpl	trakball0updateloop
   4842  2769c				   -	       lda	#0
   4843  2769c				   -	       cpx	#0
   4844  2769c				   -	       beq	trakball0skipXadjust
   4845  2769c				   -	       clc
   4846  2769c				   -trakball0Xloop
   4847  2769c				   -	       adc	port0resolution
   4848  2769c				   -	       dex
   4849  2769c				   -	       bne	trakball0Xloop
   4850  2769c				   -	       clc
   4851  2769c				   -	       adc	trakballx0
   4852  2769c				   -	       sta	trakballx0
   4853  2769c				   -trakball0skipXadjust
   4854  2769c				   -	       ifnconst	TRAKXONLY
   4855  2769c				   -	       lda	#0
   4856  2769c				   -	       cpy	#0
   4857  2769c				   -	       beq	trakball0skipYadjust
   4858  2769c				   -	       clc
   4859  2769c				   -trakball0yloop
   4860  2769c				   -	       adc	port0resolution
   4861  2769c				   -	       dey
   4862  2769c				   -	       bne	trakball0yloop
   4863  2769c				   -	       clc
   4864  2769c				   -	       adc	trakbally0
   4865  2769c				   -	       sta	trakbally0
   4866  2769c				   -trakball0skipYadjust
   4867  2769c				   -	       endif		; !TRAKXONLY
   4868  2769c				   -
   4869  2769c				   -	       jmp	LLRET0
   4870  2769c					       endif
   4871  2769c
   4872  2769c
   4873  2769c
   4874  2769c				    trakball1update
   4875  2769c				   -	       ifconst	TRAKBALL1SUPPORT
   4876  2769c				   -	       ifnconst	TRAKTIME
   4877  2769c				   -	       ifnconst	TRAKXONLY
   4878  2769c				   -	       lda	#180	; minimum for x+y
   4879  2769c				   -	       else		; !TRAKXONLY
   4880  2769c				   -	       lda	#100	; minimum for just x
   4881  2769c				   -	       endif		; !TRAKXONLY
   4882  2769c				   -	       else		; !TRAKTIME
   4883  2769c				   -	       lda	#TRAKTIME
   4884  2769c				   -	       endif		; !TRAKTIME
   4885  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   4886  2769c				   -	       ldx	#0
   4887  2769c				   -	       ifnconst	TRAKXONLY
   4888  2769c				   -	       ldy	#0
   4889  2769c				   -	       endif		; TRAKXONLY
   4890  2769c				   -trakball1updateloop
   4891  2769c				   -	       lda	SWCHA
   4892  2769c				   -	       and	#%00000011
   4893  2769c				   -	       cmp	trakballcodex1
   4894  2769c				   -	       sta	trakballcodex1
   4895  2769c				   -	       beq	trakball1movementXdone
   4896  2769c				   -	       and	#%00000001
   4897  2769c				   -	       beq	trakball1negativeX
   4898  2769c				   -trakball1positiveX
   4899  2769c				   -			;(2 from beq)
   4900  2769c				   -	       inx		; 2
   4901  2769c				   -	       jmp	trakball1movementXdone	; 3
   4902  2769c				   -trakball1negativeX
   4903  2769c				   -			;(3 from beq)
   4904  2769c				   -	       dex		; 2
   4905  2769c				   -	       nop		; 2
   4906  2769c				   -trakball1movementXdone
   4907  2769c				   -
   4908  2769c				   -	       ifnconst	TRAKXONLY
   4909  2769c				   -	       lda	SWCHA
   4910  2769c				   -	       and	#%00001100
   4911  2769c				   -	       cmp	trakballcodey1
   4912  2769c				   -	       sta	trakballcodey1
   4913  2769c				   -	       beq	trakball1movementYdone
   4914  2769c				   -	       and	#%00000100
   4915  2769c				   -	       beq	trakball1negativeY
   4916  2769c				   -trakball1positiveY
   4917  2769c				   -			;(2 from beq)
   4918  2769c				   -	       iny		; 2
   4919  2769c				   -	       jmp	trakball1movementYdone	; 3
   4920  2769c				   -trakball1negativeY
   4921  2769c				   -			;(3 from beq)
   4922  2769c				   -	       dey		; 2
   4923  2769c				   -	       nop		; 2
   4924  2769c				   -trakball1movementYdone
   4925  2769c				   -	       endif		; !TRAKXONLY
   4926  2769c				   -
   4927  2769c				   -	       lda	TIMINT
   4928  2769c				   -	       bpl	trakball1updateloop
   4929  2769c				   -	       lda	#0
   4930  2769c				   -	       cpx	#0
   4931  2769c				   -	       beq	trakball1skipXadjust
   4932  2769c				   -	       clc
   4933  2769c				   -trakball1Xloop
   4934  2769c				   -	       adc	port1resolution
   4935  2769c				   -	       dex
   4936  2769c				   -	       bne	trakball1Xloop
   4937  2769c				   -	       clc
   4938  2769c				   -	       adc	trakballx1
   4939  2769c				   -	       sta	trakballx1
   4940  2769c				   -trakball1skipXadjust
   4941  2769c				   -	       ifnconst	TRAKXONLY
   4942  2769c				   -	       lda	#0
   4943  2769c				   -	       cpy	#0
   4944  2769c				   -	       beq	trakball1skipYadjust
   4945  2769c				   -	       clc
   4946  2769c				   -trakball1yloop
   4947  2769c				   -	       adc	port1resolution
   4948  2769c				   -	       dey
   4949  2769c				   -	       bne	trakball1yloop
   4950  2769c				   -	       clc
   4951  2769c				   -	       adc	trakbally1
   4952  2769c				   -	       sta	trakbally1
   4953  2769c				   -trakball1skipYadjust
   4954  2769c				   -	       endif		; !TRAKXONLY
   4955  2769c				   -
   4956  2769c				   -	       jmp	LLRET1
   4957  2769c					       endif
   4958  2769c
   4959  2769c
   4960  2769c				    paddleport0update
   4961  2769c				   -	       ifconst	PADDLE0SUPPORT
   4962  2769c				   -	       lda	#6
   4963  2769c				   -	       sta	VBLANK	; start charging the paddle caps
   4964  2769c				   -	       lda	#0	; use PADDLE timing
   4965  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   4966  2769c				   -
   4967  2769c				   -paddleport0updateloop
   4968  2769c				   -	       lda	INPT0
   4969  2769c				   -	       bmi	skippaddle0setposition
   4970  2769c				   -	       sty	paddleposition0
   4971  2769c				   -skippaddle0setposition
   4972  2769c				   -	       ifconst	TWOPADDLESUPPORT
   4973  2769c				   -	       lda	INPT1
   4974  2769c				   -	       bmi	skippaddle1setposition
   4975  2769c				   -	       sty	paddleposition1
   4976  2769c				   -skippaddle1setposition
   4977  2769c				   -	       endif
   4978  2769c				   -	       ldy	INTIM
   4979  2769c				   -	       cpy	#TIMEOFFSET
   4980  2769c				   -	       bcs	paddleport0updateloop
   4981  2769c				   -
   4982  2769c				   -	       lda	#%10000110
   4983  2769c				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4984  2769c				   -	       sec
   4985  2769c				   -	       lda	paddleposition0
   4986  2769c				   -	       sbc	#TIMEOFFSET
   4987  2769c				   -	       ifconst	PADDLESCALEX2
   4988  2769c				   -	       asl
   4989  2769c				   -	       endif
   4990  2769c				   -
   4991  2769c				   -	       ifnconst	PADDLESMOOTHINGOFF
   4992  2769c				   -	       clc
   4993  2769c				   -	       adc	paddleprevious0
   4994  2769c				   -	       ror
   4995  2769c				   -	       sta	paddleprevious0
   4996  2769c				   -	       endif
   4997  2769c				   -
   4998  2769c				   -	       sta	paddleposition0
   4999  2769c				   -
   5000  2769c				   -	       ifconst	TWOPADDLESUPPORT
   5001  2769c				   -	       sec
   5002  2769c				   -	       lda	paddleposition1
   5003  2769c				   -	       sbc	#TIMEOFFSET
   5004  2769c				   -	       ifconst	PADDLESCALEX2
   5005  2769c				   -	       asl
   5006  2769c				   -	       endif
   5007  2769c				   -
   5008  2769c				   -	       ifnconst	PADDLESMOOTHINGOFF
   5009  2769c				   -	       clc
   5010  2769c				   -	       adc	paddleprevious1
   5011  2769c				   -	       ror
   5012  2769c				   -	       sta	paddleprevious1
   5013  2769c				   -	       endif
   5014  2769c				   -	       sta	paddleposition1
   5015  2769c				   -	       endif		; TWOPADDLESUPPORT
   5016  2769c				   -
   5017  2769c				   -	       jmp	LLRET0
   5018  2769c					       endif
   5019  2769c
   5020  2769c				    paddleport1update
   5021  2769c				   -	       ifconst	PADDLE1SUPPORT
   5022  2769c				   -	       lda	#6
   5023  2769c				   -	       sta	VBLANK	; start charging the paddle caps
   5024  2769c				   -
   5025  2769c				   -	       lda	#0	; use PADDLE timing
   5026  2769c				   -	       jsr	SETTIM64T	; INTIM is in Y
   5027  2769c				   -
   5028  2769c				   -paddleport1updateloop
   5029  2769c				   -	       lda	INPT2
   5030  2769c				   -	       bmi	skippaddle2setposition
   5031  2769c				   -	       sty	paddleposition2
   5032  2769c				   -skippaddle2setposition
   5033  2769c				   -	       ifconst	TWOPADDLESUPPORT
   5034  2769c				   -	       lda	INPT3
   5035  2769c				   -	       bmi	skippaddle3setposition
   5036  2769c				   -	       sty	paddleposition3
   5037  2769c				   -skippaddle3setposition
   5038  2769c				   -	       endif
   5039  2769c				   -	       ldy	INTIM
   5040  2769c				   -	       cpy	#TIMEOFFSET
   5041  2769c				   -	       bcs	paddleport1updateloop
   5042  2769c				   -
   5043  2769c				   -	       lda	#%10000110
   5044  2769c				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   5045  2769c				   -	       sec
   5046  2769c				   -	       lda	paddleposition2
   5047  2769c				   -	       sbc	#TIMEOFFSET
   5048  2769c				   -	       ifconst	PADDLESCALEX2
   5049  2769c				   -	       asl
   5050  2769c				   -	       endif
   5051  2769c				   -
   5052  2769c				   -	       ifnconst	PADDLESMOOTHINGOFF
   5053  2769c				   -	       clc
   5054  2769c				   -	       adc	paddleprevious2
   5055  2769c				   -	       ror
   5056  2769c				   -	       sta	paddleprevious2
   5057  2769c				   -	       endif
   5058  2769c				   -
   5059  2769c				   -	       sta	paddleposition2
   5060  2769c				   -
   5061  2769c				   -	       ifconst	TWOPADDLESUPPORT
   5062  2769c				   -	       sec
   5063  2769c				   -	       lda	paddleposition3
   5064  2769c				   -	       sbc	#TIMEOFFSET
   5065  2769c				   -	       ifconst	PADDLESCALEX2
   5066  2769c				   -	       asl
   5067  2769c				   -	       endif
   5068  2769c				   -
   5069  2769c				   -	       ifnconst	PADDLESMOOTHINGOFF
   5070  2769c				   -	       clc
   5071  2769c				   -	       adc	paddleprevious3
   5072  2769c				   -	       ror
   5073  2769c				   -	       sta	paddleprevious3
   5074  2769c				   -	       endif
   5075  2769c				   -	       sta	paddleposition3
   5076  2769c				   -	       endif		; TWOPADDLESUPPORT
   5077  2769c				   -
   5078  2769c				   -	       jmp	LLRET1
   5079  2769c					       endif
   5080  2769c
   5081  2769c
   5082  2769c				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   5083  2769c				   -	       ifconst	PADDLESUPPORT
   5084  2769c				   -			; x=0|1 for port, rather than paddle #. 
   5085  2769c				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   5086  2769c				   -			; game wants to support 2 paddles, up to the game to instead test the 
   5087  2769c				   -			; joystick right+left directions instead.
   5088  2769c				   -	       lda	SWCHA	; top of nibble is first paddle button
   5089  2769c				   -	       cpx	#0	; port 0?
   5090  2769c				   -	       beq	skippaddleport2shift
   5091  2769c				   -	       asl		; shift second port to upper nibble
   5092  2769c				   -	       asl
   5093  2769c				   -	       asl
   5094  2769c				   -	       asl
   5095  2769c				   -skippaddleport2shift
   5096  2769c				   -	       and	#%10000000
   5097  2769c				   -	       eor	#%10000000	; invert
   5098  2769c				   -	       sta	sINPT1,x
   5099  2769c				   -	       jmp	buttonreadloopreturn
   5100  2769c					       endif		; PADDLESUPPORT
   5101  2769c
   5102  2769c				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   5103  2769c				   -	       ifconst	MOUSESUPPORT
   5104  2769c				   -			; stick the mouse buttons in the correct shadow register...
   5105  2769c				   -	       txa
   5106  2769c				   -	       asl
   5107  2769c				   -	       tay		; y=x*2
   5108  2769c				   -	       lda	INPT4,x
   5109  2769c				   -	       eor	#%10000000
   5110  2769c				   -	       lsr
   5111  2769c				   -	       sta	sINPT1,x
   5112  2769c				   -
   5113  2769c				   -	       lda	INPT1,y
   5114  2769c				   -	       and	#%10000000
   5115  2769c				   -	       eor	#%10000000
   5116  2769c				   -	       ora	sINPT1,x
   5117  2769c				   -	       sta	sINPT1,x
   5118  2769c				   -	       jmp	buttonreadloopreturn
   5119  2769c					       endif		; MOUSESUPPORT
   5120  2769c
   5121  2769c				   -	       ifconst	KEYPADSUPPORT
   5122  2769c				   -			; ** select keypad rows 0 to 3 over 4 frames...
   5123  2769c				   -keypadrowselect
   5124  2769c				   -	       inc	keypadcounter
   5125  2769c				   -	       ldy	#0
   5126  2769c				   -	       lda	port0control
   5127  2769c				   -	       cmp	#7
   5128  2769c				   -	       bne	skipport0val
   5129  2769c				   -	       iny		; y=y+1
   5130  2769c				   -skipport0val
   5131  2769c				   -	       lda	port1control
   5132  2769c				   -	       cmp	#7
   5133  2769c				   -	       bne	skipport1val
   5134  2769c				   -	       iny
   5135  2769c				   -	       iny		; y=y+2
   5136  2769c				   -skipport1val
   5137  2769c				   -	       cpy	#0
   5138  2769c				   -	       beq	exitkeypadrowselect
   5139  2769c				   -	       lda	keyrowdirectionmask,y
   5140  2769c				   -	       sta	CTLSWA
   5141  2769c				   -	       tya
   5142  2769c				   -	       asl
   5143  2769c				   -	       asl
   5144  2769c				   -	       sta	inttemp1
   5145  2769c				   -	       lda	keypadcounter
   5146  2769c				   -	       and	#3
   5147  2769c				   -	       ora	inttemp1
   5148  2769c				   -	       tax
   5149  2769c				   -	       lda	keyrowselectvalue,x
   5150  2769c				   -	       sta	SWCHA
   5151  2769c				   -exitkeypadrowselect
   5152  2769c				   -	       rts
   5153  2769c				   -
   5154  2769c				   -keyrowdirectionmask
   5155  2769c				   -	       .byte	#%00000000	; 0 : port0=input port1=input
   5156  2769c				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   5157  2769c				   -	       .byte	#%00001111	; 2 : port0=input port1=output
   5158  2769c				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   5159  2769c				   -
   5160  2769c				   -keyrowselectvalue
   5161  2769c				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   5162  2769c				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   5163  2769c				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   5164  2769c				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   5165  2769c					       endif		; KEYPADSUPPORT
   5166  2769c
   5167  2769c				   -	       ifconst	KEYPADSUPPORT
   5168  2769c				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   5169  2769c				   -keypadcolumnread
   5170  2769c				   -	       lda	port0control
   5171  2769c				   -	       cmp	#7
   5172  2769c				   -	       bne	skipkeypadcolumnread0
   5173  2769c				   -	       lda	keypadcounter
   5174  2769c				   -	       and	#3
   5175  2769c				   -	       asl		; x2 because keypad variables are interleaved
   5176  2769c				   -	       tax
   5177  2769c				   -	       lda	#0
   5178  2769c				   -	       sta	keypadmatrix0a,x
   5179  2769c				   -	       lda	INPT0
   5180  2769c				   -	       cmp	#$80
   5181  2769c				   -	       rol	keypadmatrix0a,x
   5182  2769c				   -	       lda	INPT1
   5183  2769c				   -	       cmp	#$80
   5184  2769c				   -	       rol	keypadmatrix0a,x
   5185  2769c				   -	       lda	INPT4
   5186  2769c				   -	       cmp	#$80
   5187  2769c				   -	       rol	keypadmatrix0a,x
   5188  2769c				   -	       lda	keypadmatrix0a,x
   5189  2769c				   -	       eor	#%00000111
   5190  2769c				   -	       sta	keypadmatrix0a,x
   5191  2769c				   -skipkeypadcolumnread0
   5192  2769c				   -
   5193  2769c				   -	       lda	port1control
   5194  2769c				   -	       cmp	#7
   5195  2769c				   -	       bne	skipkeypadcolumnread1
   5196  2769c				   -	       lda	keypadcounter
   5197  2769c				   -	       and	#3
   5198  2769c				   -	       asl		; x2 because keypad variables are interleaved
   5199  2769c				   -	       tax
   5200  2769c				   -	       lda	#0
   5201  2769c				   -	       sta	keypadmatrix1a,x
   5202  2769c				   -	       rol	keypadmatrix1a,x
   5203  2769c				   -	       lda	INPT2
   5204  2769c				   -	       cmp	#$80
   5205  2769c				   -	       rol	keypadmatrix1a,x
   5206  2769c				   -	       lda	INPT3
   5207  2769c				   -	       cmp	#$80
   5208  2769c				   -	       rol	keypadmatrix1a,x
   5209  2769c				   -	       lda	INPT5
   5210  2769c				   -	       cmp	#$80
   5211  2769c				   -	       rol	keypadmatrix1a,x
   5212  2769c				   -	       lda	keypadmatrix1a,x
   5213  2769c				   -	       eor	#%00000111
   5214  2769c				   -	       sta	keypadmatrix1a,x
   5215  2769c				   -skipkeypadcolumnread1
   5216  2769c				   -	       rts
   5217  2769c					       endif		; KEYPADSUPPORT
   5218  2769c
   5219  2769c				    setportforinput
   5220  2769c			ad 81 02	       lda	CTLSWA
   5221  2769f			3d ce f3	       and	SWCHA_DIRMASK,x
   5222  276a2			8d 81 02	       sta	CTLSWA
   5223  276a5			60		       rts
   5224  276a6
   5225  276a6				    setonebuttonmode
   5226  276a6			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5227  276a8			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5228  276aa			a9 14		       lda	#$14
   5229  276ac			8d 83 02	       sta	CTLSWB
   5230  276af			ad 82 02	       lda	SWCHB
   5231  276b2			1d cc f6	       ora	thisjoy2buttonbit,x	; disable: write 1 to the 2-button bit
   5232  276b5			8d 82 02	       sta	SWCHB
   5233  276b8			60		       rts
   5234  276b9
   5235  276b9				    settwobuttonmode
   5236  276b9			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5237  276bb			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5238  276bd			a9 14		       lda	#$14
   5239  276bf			8d 83 02	       sta	CTLSWB
   5240  276c2			ad 82 02	       lda	SWCHB
   5241  276c5			3d cd f6	       and	thisjoy2buttonbit+1,x	; enable: write 0 to the 2-button bit
   5242  276c8			8d 82 02	       sta	SWCHB
   5243  276cb			60		       rts
   5244  276cc
   5245  276cc				    thisjoy2buttonbit
   5246  276cc							; p0	p1   p0
   5247  276cc			04 10 04	       .byte.b	$04, $10, $04
   5248  276cf
   5249  276cf							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5250  276cf
   5251  276cf				    START
   5252  276cf				    start
   5253  276cf
   5254  276cf							;******** more or less the Atari recommended startup procedure
   5255  276cf
   5256  276cf			78		       sei
   5257  276d0			d8		       cld
   5258  276d1
   5259  276d1					       ifnconst	NOTIALOCK
   5260  276d1			a9 07		       lda	#$07
   5261  276d3				   -	       else
   5262  276d3				   -	       lda	#$06
   5263  276d3					       endif
   5264  276d3			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   5265  276d5			a9 7f		       lda	#$7F
   5266  276d7			85 3c		       sta	CTRL	;disable DMA
   5267  276d9			a9 00		       lda	#$00
   5268  276db			85 38		       sta	OFFSET
   5269  276dd					       ifnconst	NOTIALOCK
   5270  276dd			85 01		       sta	INPTCTRL
   5271  276df			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   5272  276e1					       endif
   5273  276e1			a2 ff		       ldx	#$FF
   5274  276e3			9a		       txs
   5275  276e4
   5276  276e4							;************** Clear Memory
   5277  276e4
   5278  276e4							; ** Clear 1800-27FF, pg0+pg1 memory.
   5279  276e4				    ClearMemPages
   5280  276e4			a9 00		       lda	#0
   5281  276e6			a8		       tay		; y=0
   5282  276e7			85 80		       sta	$80
   5283  276e9			a2 18		       ldx	#$18
   5284  276eb				    ClearMemPagesLoop
   5285  276eb			86 81		       stx	$81	; needed for when we step on ZP memory
   5286  276ed			91 80		       sta	($80),y	;Store data
   5287  276ef			c8		       iny		;Next byte
   5288  276f0			d0 f9		       bne	ClearMemPagesLoop
   5289  276f2			e8		       inx
   5290  276f3			e0 28		       cpx	#$28
   5291  276f5			d0 f4		       bne	ClearMemPagesLoop
   5292  276f7			85 81		       sta	$81
   5293  276f9
   5294  276f9							;seed random number with hopefully-random timer value
   5295  276f9			a9 01		       lda	#1
   5296  276fb			0d 84 02	       ora	INTIM
   5297  276fe			85 40		       sta	rand
   5298  27700
   5299  27700							; detect the console type...
   5300  27700				    pndetectvblankstart
   5301  27700			a5 28		       lda	MSTAT
   5302  27702			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5303  27704				    pndetectvblankover
   5304  27704			a5 28		       lda	MSTAT
   5305  27706			30 fc		       bmi	pndetectvblankover	; then wait for it to be over
   5306  27708			a0 00		       ldy	#$00
   5307  2770a			a2 00		       ldx	#$00
   5308  2770c				    pndetectvblankhappening
   5309  2770c			a5 28		       lda	MSTAT
   5310  2770e			30 07		       bmi	pndetectinvblank	; if VBLANK starts, exit our counting loop 
   5311  27710			85 24		       sta	WSYNC
   5312  27712			85 24		       sta	WSYNC
   5313  27714			e8		       inx
   5314  27715			d0 f5		       bne	pndetectvblankhappening
   5315  27717				    pndetectinvblank
   5316  27717			e0 7d		       cpx	#125
   5317  27719			90 02		       bcc	pndetecispal
   5318  2771b			a0 01		       ldy	#$01
   5319  2771d				    pndetecispal
   5320  2771d			8c 09 21	       sty	paldetected
   5321  27720
   5322  27720			20 30 f6	       jsr	createallgamedlls
   5323  27723
   5324  27723			a9 18		       lda	#>DLLMEM
   5325  27725			85 2c		       sta	DPPH
   5326  27727			a9 00		       lda	#<DLLMEM
   5327  27729			85 30		       sta	DPPL
   5328  2772b
   5329  2772b				   -	       ifconst	pokeysupport
   5330  2772b				   -			; pokey support is compiled in, so try to detect it...
   5331  2772b				   -	       jsr	detectpokeylocation
   5332  2772b					       endif
   5333  2772b
   5334  2772b			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   5335  2772d			8d b8 01	       sta	port0control
   5336  27730			8d b9 01	       sta	port1control
   5337  27733
   5338  27733							;Setup port A to read mode
   5339  27733							;lda #$00
   5340  27733							;sta SWCHA
   5341  27733							;sta CTLSWA
   5342  27733
   5343  27733				   -	       ifconst	HSSUPPORT
   5344  27733				   -	       ifconst	bankswitchmode
   5345  27733				   -	       ifconst	included.hiscore.asm.bank
   5346  27733				   -	       ifconst	MCPDEVCART
   5347  27733				   -	       lda	#($18 | included.hiscore.asm.bank)
   5348  27733				   -	       ifconst	dumpbankswitch
   5349  27733				   -	       sta	dumpbankswitch
   5350  27733				   -	       endif
   5351  27733				   -	       sta	$3000
   5352  27733				   -	       else
   5353  27733				   -	       lda	#(included.hiscore.asm.bank)
   5354  27733				   -	       ifconst	dumpbankswitch
   5355  27733				   -	       sta	dumpbankswitch
   5356  27733				   -	       endif
   5357  27733				   -	       sta	$8000
   5358  27733				   -	       endif
   5359  27733				   -	       endif		; included.hiscore.asm.bank
   5360  27733				   -	       endif		; bankswitchmode
   5361  27733				   -			; try to detect HSC
   5362  27733				   -	       jsr	detecthsc
   5363  27733				   -	       and	#1
   5364  27733				   -	       sta	hsdevice
   5365  27733				   -skipHSCdetect
   5366  27733				   -			; try to detect AtariVox eeprom
   5367  27733				   -	       jsr	detectatarivoxeeprom
   5368  27733				   -	       and	#2
   5369  27733				   -	       ora	hsdevice
   5370  27733				   -	       cmp	#3
   5371  27733				   -	       bne	storeAinhsdevice
   5372  27733				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5373  27733				   -			; Later we should check each device's priority byte if set, instead, 
   5374  27733				   -	       lda	#2
   5375  27733				   -storeAinhsdevice
   5376  27733				   -	       sta	hsdevice
   5377  27733				   -	       lda	#$ff
   5378  27733				   -	       sta	hsdifficulty
   5379  27733				   -	       sta	hsgameslot
   5380  27733				   -	       sta	hsnewscoreline
   5381  27733					       endif		; HSSUPPORT
   5382  27733
   5383  27733				   -	       ifconst	AVOXVOICE
   5384  27733				   -	       jsr	silenceavoxvoice
   5385  27733					       endif
   5386  27733
   5387  27733				   -	       ifconst	RMT
   5388  27733				   -	       ifconst	RMTVOLUME
   5389  27733				   -	       lda	#$F0	; default to full RMT volume
   5390  27733				   -	       sta	rmtvolume
   5391  27733				   -	       ifconst	TIAVOLUME
   5392  27733				   -	       sta	tiavolume
   5393  27733				   -	       endif		; TIAVOLUME
   5394  27733				   -	       endif		; RMTVOLUME
   5395  27733					       else		; !RMT
   5396  27733				   -	       ifconst	TIAVOLUME
   5397  27733				   -	       lda	#$F0	; default to full TIA volume
   5398  27733				   -	       sta	tiavolume
   5399  27733					       endif		; TIAVOLUME
   5400  27733					       endif		; RMT
   5401  27733
   5402  27733					       ifconst	bankswitchmode
   5403  27733							; we need to switch to the first bank as a default. this needs to
   5404  27733							; happen before DMA, in case there's a topscreenroutine in bank 0
   5405  27733				   -	       ifconst	MCPDEVCART
   5406  27733				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5407  27733				   -	       ifconst	dumpbankswitch
   5408  27733				   -	       sta	dumpbankswitch
   5409  27733				   -	       endif
   5410  27733				   -	       sta	$3000
   5411  27733					       else
   5412  27733			a9 00		       lda	#0
   5413  27735				   -	       ifconst	dumpbankswitch
   5414  27735				   -	       sta	dumpbankswitch
   5415  27735					       endif
   5416  27735			8d 00 80	       sta	$8000
   5417  27738					       endif
   5418  27738					       endif
   5419  27738
   5420  27738							; CTRL 76543210
   5421  27738							; 7 colorburst kill
   5422  27738							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5423  27738							; 4 character width 1=2 byte chars, 0=1 byte chars
   5424  27738							; 3 border control 0=background color border, 1=black border
   5425  27738							; 2 kangaroo mode 0=transparency, 1=kangaroo
   5426  27738							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5427  27738
   5428  27738				   -	       ifconst	DOUBLEWIDE
   5429  27738				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5430  27738					       else
   5431  27738			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5432  2773a					       endif
   5433  2773a
   5434  2773a			20 93 f6	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   5435  2773d
   5436  2773d			85 3c		       sta	CTRL
   5437  2773f			8d 07 21	       sta	sCTRL
   5438  27742
   5439  27742			20 23 f6	       jsr	vblankresync
   5440  27745
   5441  27745			a2 01		       ldx	#1
   5442  27747			20 b9 f6	       jsr	settwobuttonmode
   5443  2774a			a2 00		       ldx	#0
   5444  2774c			20 b9 f6	       jsr	settwobuttonmode
   5445  2774f
   5446  2774f					       ifnconst	.altgamestart
   5447  2774f			4c 00 80	       jmp	game
   5448  27752				   -	       else
   5449  27752				   -	       jmp	.altgamestart
   5450  27752					       endif
   5451  27752
   5452  27752							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5453  27752
   5454  27752							;************** Setup DLL entries
   5455  27752
   5456  27752							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5457  27752					       ifnconst	SCREENHEIGHT
   5458  27752			00 c0	    WSCREENHEIGHT =	192
   5459  27752				   -	       else
   5460  27752				   -WSCREENHEIGHT =	SCREENHEIGHT
   5461  27752					       endif
   5462  27752
   5463  27752				   -	       ifnconst	ZONEHEIGHT
   5464  27752				   -WZONEHEIGHT =	16
   5465  27752					       else
   5466  27752			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   5467  27752					       endif
   5468  27752
   5469  27752					       ifnconst	ZONECOUNT
   5470  27752				   -	       ifconst	VSCROLL
   5471  27752				   -WZONECOUNT =	((WSCREENHEIGHT/WZONEHEIGHT)+1)
   5472  27752					       else		; !VSCROLL
   5473  27752			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5474  27752					       endif		; !VSCROLL
   5475  27752				   -	       else
   5476  27752				   -	       ifconst	VSCROLL
   5477  27752				   -WZONECOUNT =	(ZONECOUNT+1)
   5478  27752				   -	       else		; !VSCROLL
   5479  27752				   -WZONECOUNT =	ZONECOUNT
   5480  27752				   -	       endif		; !VSCROLL
   5481  27752					       endif
   5482  27752
   5483  27752							; top of the frame, non-visible lines. this is based on NTSC,
   5484  27752							; but we add in extra NV lines at the end of the display to ensure
   5485  27752							; our PAL friends can play the game without it crashing.
   5486  27752			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   5487  27752
   5488  27752					       ifnconst	DLMEMSTART
   5489  27752					       ifnconst	DOUBLEBUFFER
   5490  27752			18 80	    WDLMEMSTART =	$1880
   5491  27752				   -	       else
   5492  27752				   -WDLMEMSTART =	$18E0
   5493  27752					       endif		; DOUBLEBUFFER
   5494  27752				   -	       else
   5495  27752				   -WDLMEMSTART =	DLMEMSTART
   5496  27752					       endif
   5497  27752
   5498  27752					       ifnconst	DLMEMEND
   5499  27752				   -	       ifconst	EXTRADLMEMORY
   5500  27752				   -WDLMEMEND  =	$23FF
   5501  27752					       else
   5502  27752			1f ff	    WDLMEMEND  =	$1FFF
   5503  27752					       endif
   5504  27752				   -	       else
   5505  27752				   -WDLMEMEND  =	DLMEMEND
   5506  27752					       endif
   5507  27752
   5508  27752
   5509  27752				    WMEMSIZE   SET	(WDLMEMEND-WDLMEMSTART+1)
   5510  27752
   5511  27752				   -	       ifconst	VSCROLL
   5512  27752				   -	       ifnconst	DOUBLEBUFFER
   5513  27752				   -			; give the last zone extra ram for the dma mask objects...
   5514  27752				   -WMEMSIZE   SET	(WMEMSIZE-(maskscrollspriteend-maskscrollsprite))
   5515  27752				   -	       endif		; DOUBLEBUFFER
   5516  27752					       endif		; VSCROLL
   5517  27752
   5518  27752					       ifnconst	DOUBLEBUFFER
   5519  27752			00 9b	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5520  27752				   -	       else
   5521  27752				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5522  27752					       endif
   5523  27752
   5524  27752			00 9d	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5525  27752				   -	       if	TDOUBLEBUFFEROFFSET > 255
   5526  27752				   -DOUBLEBUFFEROFFSET =	255
   5527  27752					       else
   5528  27752			00 9d	    DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5529  27752					       endif
   5530  27752
   5531  27752				   -	       ifconst	EXTRADLMEMORY
   5532  27752				   -SECONDDLHALFSTART SET	$2300
   5533  27752					       endif
   5534  27752
   5535  27752				    DLPOINTH
   5536  27752				    DLINDEX    SET	0
   5537  27752					       REPEAT	WZONECOUNT
   5538  27752				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27752				   -	       ifconst	EXTRADLMEMORY
   5540  27752				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27752				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27752				   -	       else
   5543  27752				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27752				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27752				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27752				   -	       endif
   5547  27752				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27752					       endif		; EXTRADLMEMORY
   5549  27752							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27752			18		       .byte.b	>TMPMEMADDRESS
   5551  27752				    DLINDEX    SET	DLINDEX + 1
   5537  27752					       REPEND
   5538  27752				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27753				   -	       ifconst	EXTRADLMEMORY
   5540  27753				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27753				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27753				   -	       else
   5543  27753				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27753				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27753				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27753				   -	       endif
   5547  27753				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27753					       endif		; EXTRADLMEMORY
   5549  27753							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27753			19		       .byte.b	>TMPMEMADDRESS
   5551  27753				    DLINDEX    SET	DLINDEX + 1
   5537  27753					       REPEND
   5538  27753				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27754				   -	       ifconst	EXTRADLMEMORY
   5540  27754				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27754				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27754				   -	       else
   5543  27754				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27754				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27754				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27754				   -	       endif
   5547  27754				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27754					       endif		; EXTRADLMEMORY
   5549  27754							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27754			19		       .byte.b	>TMPMEMADDRESS
   5551  27754				    DLINDEX    SET	DLINDEX + 1
   5537  27754					       REPEND
   5538  27754				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27755				   -	       ifconst	EXTRADLMEMORY
   5540  27755				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27755				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27755				   -	       else
   5543  27755				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27755				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27755				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27755				   -	       endif
   5547  27755				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27755					       endif		; EXTRADLMEMORY
   5549  27755							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27755			1a		       .byte.b	>TMPMEMADDRESS
   5551  27755				    DLINDEX    SET	DLINDEX + 1
   5537  27755					       REPEND
   5538  27755				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27756				   -	       ifconst	EXTRADLMEMORY
   5540  27756				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27756				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27756				   -	       else
   5543  27756				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27756				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27756				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27756				   -	       endif
   5547  27756				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27756					       endif		; EXTRADLMEMORY
   5549  27756							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27756			1b		       .byte.b	>TMPMEMADDRESS
   5551  27756				    DLINDEX    SET	DLINDEX + 1
   5537  27756					       REPEND
   5538  27756				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27757				   -	       ifconst	EXTRADLMEMORY
   5540  27757				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27757				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27757				   -	       else
   5543  27757				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27757				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27757				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27757				   -	       endif
   5547  27757				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27757					       endif		; EXTRADLMEMORY
   5549  27757							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27757			1b		       .byte.b	>TMPMEMADDRESS
   5551  27757				    DLINDEX    SET	DLINDEX + 1
   5537  27757					       REPEND
   5538  27757				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27758				   -	       ifconst	EXTRADLMEMORY
   5540  27758				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27758				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27758				   -	       else
   5543  27758				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27758				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27758				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27758				   -	       endif
   5547  27758				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27758					       endif		; EXTRADLMEMORY
   5549  27758							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27758			1c		       .byte.b	>TMPMEMADDRESS
   5551  27758				    DLINDEX    SET	DLINDEX + 1
   5537  27758					       REPEND
   5538  27758				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  27759				   -	       ifconst	EXTRADLMEMORY
   5540  27759				   -	       if	TMPMEMADDRESS > $1FFF
   5541  27759				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  27759				   -	       else
   5543  27759				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  27759				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  27759				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  27759				   -	       endif
   5547  27759				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  27759					       endif		; EXTRADLMEMORY
   5549  27759							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  27759			1c		       .byte.b	>TMPMEMADDRESS
   5551  27759				    DLINDEX    SET	DLINDEX + 1
   5537  27759					       REPEND
   5538  27759				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  2775a				   -	       ifconst	EXTRADLMEMORY
   5540  2775a				   -	       if	TMPMEMADDRESS > $1FFF
   5541  2775a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  2775a				   -	       else
   5543  2775a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  2775a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  2775a				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  2775a				   -	       endif
   5547  2775a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  2775a					       endif		; EXTRADLMEMORY
   5549  2775a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  2775a			1d		       .byte.b	>TMPMEMADDRESS
   5551  2775a				    DLINDEX    SET	DLINDEX + 1
   5537  2775a					       REPEND
   5538  2775a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  2775b				   -	       ifconst	EXTRADLMEMORY
   5540  2775b				   -	       if	TMPMEMADDRESS > $1FFF
   5541  2775b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  2775b				   -	       else
   5543  2775b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  2775b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  2775b				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  2775b				   -	       endif
   5547  2775b				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  2775b					       endif		; EXTRADLMEMORY
   5549  2775b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  2775b			1e		       .byte.b	>TMPMEMADDRESS
   5551  2775b				    DLINDEX    SET	DLINDEX + 1
   5537  2775b					       REPEND
   5538  2775b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  2775c				   -	       ifconst	EXTRADLMEMORY
   5540  2775c				   -	       if	TMPMEMADDRESS > $1FFF
   5541  2775c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  2775c				   -	       else
   5543  2775c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  2775c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  2775c				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  2775c				   -	       endif
   5547  2775c				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  2775c					       endif		; EXTRADLMEMORY
   5549  2775c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  2775c			1e		       .byte.b	>TMPMEMADDRESS
   5551  2775c				    DLINDEX    SET	DLINDEX + 1
   5537  2775c					       REPEND
   5538  2775c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5539  2775d				   -	       ifconst	EXTRADLMEMORY
   5540  2775d				   -	       if	TMPMEMADDRESS > $1FFF
   5541  2775d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5542  2775d				   -	       else
   5543  2775d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5544  2775d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5545  2775d				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5546  2775d				   -	       endif
   5547  2775d				   -	       endif		; TMPMEMADDRESS > $1FFF
   5548  2775d					       endif		; EXTRADLMEMORY
   5549  2775d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5550  2775d			1f		       .byte.b	>TMPMEMADDRESS
   5551  2775d				    DLINDEX    SET	DLINDEX + 1
   5552  2775e					       REPEND
   5553  2775e
   5554  2775e				   -	       ifconst	EXTRADLMEMORY
   5555  2775e				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5556  2775e					       endif
   5557  2775e
   5558  2775e
   5559  2775e				    DLPOINTL
   5560  2775e				    DLINDEX    SET	0
   5561  2775e					       REPEAT	WZONECOUNT
   5562  2775e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  2775e				   -	       ifconst	EXTRADLMEMORY
   5564  2775e				   -	       if	TMPMEMADDRESS > $1FFF
   5565  2775e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  2775e				   -	       else
   5567  2775e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  2775e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  2775e				   -	       endif
   5570  2775e				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  2775e					       endif		; EXTRADLMEMORY
   5572  2775e			80		       .byte.b	<TMPMEMADDRESS
   5573  2775e				    DLINDEX    SET	DLINDEX + 1
   5561  2775e					       REPEND
   5562  2775e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  2775f				   -	       ifconst	EXTRADLMEMORY
   5564  2775f				   -	       if	TMPMEMADDRESS > $1FFF
   5565  2775f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  2775f				   -	       else
   5567  2775f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  2775f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  2775f				   -	       endif
   5570  2775f				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  2775f					       endif		; EXTRADLMEMORY
   5572  2775f			20		       .byte.b	<TMPMEMADDRESS
   5573  2775f				    DLINDEX    SET	DLINDEX + 1
   5561  2775f					       REPEND
   5562  2775f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27760				   -	       ifconst	EXTRADLMEMORY
   5564  27760				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27760				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27760				   -	       else
   5567  27760				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27760				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27760				   -	       endif
   5570  27760				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27760					       endif		; EXTRADLMEMORY
   5572  27760			c0		       .byte.b	<TMPMEMADDRESS
   5573  27760				    DLINDEX    SET	DLINDEX + 1
   5561  27760					       REPEND
   5562  27760				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27761				   -	       ifconst	EXTRADLMEMORY
   5564  27761				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27761				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27761				   -	       else
   5567  27761				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27761				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27761				   -	       endif
   5570  27761				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27761					       endif		; EXTRADLMEMORY
   5572  27761			60		       .byte.b	<TMPMEMADDRESS
   5573  27761				    DLINDEX    SET	DLINDEX + 1
   5561  27761					       REPEND
   5562  27761				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27762				   -	       ifconst	EXTRADLMEMORY
   5564  27762				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27762				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27762				   -	       else
   5567  27762				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27762				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27762				   -	       endif
   5570  27762				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27762					       endif		; EXTRADLMEMORY
   5572  27762			00		       .byte.b	<TMPMEMADDRESS
   5573  27762				    DLINDEX    SET	DLINDEX + 1
   5561  27762					       REPEND
   5562  27762				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27763				   -	       ifconst	EXTRADLMEMORY
   5564  27763				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27763				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27763				   -	       else
   5567  27763				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27763				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27763				   -	       endif
   5570  27763				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27763					       endif		; EXTRADLMEMORY
   5572  27763			a0		       .byte.b	<TMPMEMADDRESS
   5573  27763				    DLINDEX    SET	DLINDEX + 1
   5561  27763					       REPEND
   5562  27763				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27764				   -	       ifconst	EXTRADLMEMORY
   5564  27764				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27764				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27764				   -	       else
   5567  27764				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27764				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27764				   -	       endif
   5570  27764				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27764					       endif		; EXTRADLMEMORY
   5572  27764			40		       .byte.b	<TMPMEMADDRESS
   5573  27764				    DLINDEX    SET	DLINDEX + 1
   5561  27764					       REPEND
   5562  27764				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27765				   -	       ifconst	EXTRADLMEMORY
   5564  27765				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27765				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27765				   -	       else
   5567  27765				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27765				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27765				   -	       endif
   5570  27765				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27765					       endif		; EXTRADLMEMORY
   5572  27765			e0		       .byte.b	<TMPMEMADDRESS
   5573  27765				    DLINDEX    SET	DLINDEX + 1
   5561  27765					       REPEND
   5562  27765				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27766				   -	       ifconst	EXTRADLMEMORY
   5564  27766				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27766				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27766				   -	       else
   5567  27766				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27766				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27766				   -	       endif
   5570  27766				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27766					       endif		; EXTRADLMEMORY
   5572  27766			80		       .byte.b	<TMPMEMADDRESS
   5573  27766				    DLINDEX    SET	DLINDEX + 1
   5561  27766					       REPEND
   5562  27766				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27767				   -	       ifconst	EXTRADLMEMORY
   5564  27767				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27767				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27767				   -	       else
   5567  27767				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27767				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27767				   -	       endif
   5570  27767				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27767					       endif		; EXTRADLMEMORY
   5572  27767			20		       .byte.b	<TMPMEMADDRESS
   5573  27767				    DLINDEX    SET	DLINDEX + 1
   5561  27767					       REPEND
   5562  27767				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27768				   -	       ifconst	EXTRADLMEMORY
   5564  27768				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27768				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27768				   -	       else
   5567  27768				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27768				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27768				   -	       endif
   5570  27768				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27768					       endif		; EXTRADLMEMORY
   5572  27768			c0		       .byte.b	<TMPMEMADDRESS
   5573  27768				    DLINDEX    SET	DLINDEX + 1
   5561  27768					       REPEND
   5562  27768				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5563  27769				   -	       ifconst	EXTRADLMEMORY
   5564  27769				   -	       if	TMPMEMADDRESS > $1FFF
   5565  27769				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5566  27769				   -	       else
   5567  27769				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5568  27769				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5569  27769				   -	       endif
   5570  27769				   -	       endif		; TMPMEMADDRESS > $1FFF
   5571  27769					       endif		; EXTRADLMEMORY
   5572  27769			60		       .byte.b	<TMPMEMADDRESS
   5573  27769				    DLINDEX    SET	DLINDEX + 1
   5574  2776a					       REPEND
   5575  2776a
   5576  2776a
   5577  2776a				    DLINDEX    SET	0
   5578  2776a					       REPEAT	WZONECOUNT
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			18 80	    ZONE0ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			19 20	    ZONE1ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			19 c0	    ZONE2ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1a 60	    ZONE3ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1b 00	    ZONE4ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1b a0	    ZONE5ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1c 40	    ZONE6ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1c e0	    ZONE7ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1d 80	    ZONE8ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1e 20	    ZONE9ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1e c0	    ZONE10ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5578  2776a					       REPEND
   5579  2776a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5580  2776a				   -	       ifconst	EXTRADLMEMORY
   5581  2776a				   -	       if	TMPMEMADDRESS > $1FFF
   5582  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5583  2776a				   -	       else
   5584  2776a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5585  2776a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5586  2776a				   -	       endif
   5587  2776a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5588  2776a					       endif		; EXTRADLMEMORY
   5589  2776a
   5590  2776a			1f 60	    ZONE11ADDRESS =	TMPMEMADDRESS
   5591  2776a				    LASTZONEADDRESS SET	TMPMEMADDRESS
   5592  2776a
   5593  2776a				    DLINDEX    SET	DLINDEX + 1
   5594  2776a					       REPEND
   5595  2776a
   5596  2776a
     $1880 to $1fff used as zone memory, allowing 31 display objects per zone.
   5597  2776a					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5598  2776a
   5599  2776a				    DLHEIGHT
   5600  2776a					       REPEAT	WZONECOUNT
   5601  2776a			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776a					       REPEND
   5601  2776b			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776b					       REPEND
   5601  2776c			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776c					       REPEND
   5601  2776d			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776d					       REPEND
   5601  2776e			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776e					       REPEND
   5601  2776f			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  2776f					       REPEND
   5601  27770			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  27770					       REPEND
   5601  27771			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  27771					       REPEND
   5601  27772			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  27772					       REPEND
   5601  27773			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  27773					       REPEND
   5601  27774			0f		       .byte.b	(WZONEHEIGHT-1)
   5600  27774					       REPEND
   5601  27775			0f		       .byte.b	(WZONEHEIGHT-1)
   5602  27776					       REPEND
   5603  27776
   5604  27776							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5605  27776
   5606  27776							; a simple guard, than ensures the 7800basic code hasn't
   5607  27776							; spilled into the encryption area...
     2056 bytes left in the 7800basic reserved area.
   5608  27776					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5609  27776				   -	       if	(*>$FF7D)
   5610  27776				   -	       echo
   5611  27776				   -	       echo	"***************************"
   5612  27776				   -	       echo	"*** Abort: ROM Overflow ***"
   5613  27776				   -	       echo	"***************************"
   5614  27776				   -	       ERR		; abort the assembly
   5615  27776					       endif
   5616  27776
   5617  27776							; throw a compile
   5618  27776				   -	       ifconst	RMT
   5619  27776				   -	       ifnconst	pokeysupport
   5620  27776				   -	       echo
   5621  27776				   -	       echo	"************************************************************"
   5622  27776				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   5623  27776				   -	       echo	"************************************************************"
   5624  27776				   -	       ERR		; abort
   5625  27776				   -	       endif		; pokeysupport
   5626  27776				   -	       ifnconst	pokeyaddress
   5627  27776				   -	       echo
   5628  27776				   -	       echo	"************************************************************"
   5629  27776				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   5630  27776				   -	       echo	"************************************************************"
   5631  27776				   -	       ERR		; abort
   5632  27776				   -	       endif		; pokeyaddress
   5633  27776					       endif
   5634  27776
   5635  27776							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5636  27776
   5637  27776				   -	       ifconst	DEV
   5638  27776				   -	       ifnconst	ZONEHEIGHT
   5639  27776				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5640  27776				   -	       else
   5641  27776				   -	       if	ZONEHEIGHT = 8
   5642  27776				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5643  27776				   -	       else
   5644  27776				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5645  27776				   -	       endif
   5646  27776				   -	       endif
   5647  27776					       endif
   5648  27776
   5649  27776				   -	       if	START_OF_ROM = .
   5650  27776				   -	       .byte	0
   5651  27776					       endif
   5652  27776				    START_OF_ROM SET	0
   5653  27776
   5654  27776							; FF7E/FF7F contains the 7800basic crc checksum word
   5655  27776
   5656  27776							; FF80 - FFF7 contains the 7800 encryption key 
   5657  27776
   5658  27776				   -	       ifnconst	bankswitchmode
   5659  27776				   -	       ORG	$FFF8
   5660  27776					       else
   5661  27776					       ifconst	ROM128K
   5662  27ff8					       ORG	$27FF8
   5663  27ff8					       RORG	$FFF8
   5664  27ff8					       endif
   5665  27ff8				   -	       ifconst	ROM144K
   5666  27ff8				   -	       ORG	$27FF8
   5667  27ff8				   -	       RORG	$FFF8
   5668  27ff8					       endif
   5669  27ff8				   -	       ifconst	ROM256K
   5670  27ff8				   -	       ORG	$47FF8
   5671  27ff8				   -	       RORG	$FFF8
   5672  27ff8					       endif
   5673  27ff8				   -	       ifconst	ROM272K
   5674  27ff8				   -	       ORG	$47FF8
   5675  27ff8				   -	       RORG	$FFF8
   5676  27ff8					       endif
   5677  27ff8				   -	       ifconst	ROM512K
   5678  27ff8				   -	       ORG	$87FF8
   5679  27ff8				   -	       RORG	$FFF8
   5680  27ff8					       endif
   5681  27ff8				   -	       ifconst	ROM528K
   5682  27ff8				   -	       ORG	$87FF8
   5683  27ff8				   -	       RORG	$FFF8
   5684  27ff8					       endif
   5685  27ff8					       endif
   5686  27ff8
   5687  27ff8
   5688  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   5689  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5690  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5691  27ffa
   5692  27ffa							;Vectors
   5693  27ffa			c9 f1		       .word.w	NMI
   5694  27ffc			cf f6		       .word.w	START
   5695  27ffe			28 f2		       .word.w	IRQ
   5696  28000
